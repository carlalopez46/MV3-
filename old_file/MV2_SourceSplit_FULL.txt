
======================================================================
FILE PATH: AsyncFileIO.js
======================================================================

/*
Copyright © 1992-2021 Progress Software Corporation and/or one of its subsidiaries or affiliates. All rights reserved.
*/


// Provides access to files using Native Messaging Host technology


var afio = (function () {
    const fio_host = "com.ipswitch.imacros.fio";

    function NodeObject(transferrable_node) {
        if (!transferrable_node || !transferrable_node._path)
            throw new Error("NodeObject can not be constructed");
        this._path = transferrable_node._path;
        if (typeof(transferrable_node._is_dir_int) != "undefined")
            this._is_dir_int = transferrable_node._is_dir_int;
    };

    NodeObject.prototype.__defineGetter__("path", function() {
        return this._path;
    });

    NodeObject.prototype.__defineGetter__("leafName", function() {
        // special treatment of root dir or drive letters
        if (__is_windows()) {
            if (/^[a-z]:\\?$/i.test(this._path))
                return "";
        } else {
            if (this._path == "/")
                return "";
        }

        return this._path.split(__psep()).pop();
    });

    NodeObject.prototype.__defineGetter__("parent", function() {
        // special treatment of root dir or drive letters
        // return the node itself
        if (__is_windows()) {
            if (/^[a-z]:\\?$/i.test(this._path))
                return new NodeObject(this);
        } else {
            if (this._path == "/")
                return new NodeObject(this);
        }

        var a = this._path.split(__psep()); a.pop();
        if (!__is_windows() && a.length == 1 && a[0] == "")
            a[0] = "/";
        return new NodeObject({_path: a.join(__psep())});
    });

    NodeObject.prototype.__defineGetter__("isDirCached", function() {
        return typeof(this._is_dir_int) != "undefined";
    });

    NodeObject.prototype.__defineGetter__("is_dir", function() {
        return this._is_dir_int;
    });

    NodeObject.prototype.exists = function() {
        var self = this;
        return new Promise(function(resolve, reject) {
            var req = {method: "node_exists", node: self};
            chrome.runtime.sendNativeMessage(fio_host, req, function(result) {
                if (chrome.runtime.lastError)
                    reject(chrome.runtime.lastError);
                else
                    resolve(result.exists);
            });
        });
    };


    NodeObject.prototype.isDir = function() {
        var self = this;
        return new Promise(function(resolve, reject) {
            if (self.isDirCached) {
                resolve(self.is_dir);
                return;
            }
            var req = {method: "node_isDir", node: self};
            chrome.runtime.sendNativeMessage(fio_host, req, function(result) {
                if (chrome.runtime.lastError)
                    reject(chrome.runtime.lastError);
                else
                    resolve(result.isDir);
            });
        });
    };


    NodeObject.prototype.isWritable = function() {
        var self = this;
        return new Promise(function(resolve, reject) {
            var req = {method: "node_isWritable", node: self};
            chrome.runtime.sendNativeMessage(fio_host, req, function(result) {
                if (chrome.runtime.lastError)
                    reject(chrome.runtime.lastError);
                else
                    resolve(result.isWritable);
            });
        });
    };


    NodeObject.prototype.isReadable = function() {
        var self = this;
        return new Promise(function(resolve, reject) {
            var req = {method: "node_isReadable", node: self};
            chrome.runtime.sendNativeMessage(fio_host, req, function(result) {
                if (chrome.runtime.lastError)
                    reject(chrome.runtime.lastError);
                else
                    resolve(result.isReadable);
            });
        });
    };


    // append part of the name
    NodeObject.prototype.append = function(bit) {
        while (bit[0] == __psep())
            bit = bit.substring(1);
        this._path += this._path[this._path.length-1] == __psep() ?
            bit : __psep()+bit;
    };

    NodeObject.prototype.clone = function() {
        return new NodeObject(this);
    };

    // copyTo(NodeObject dest)
    NodeObject.prototype.copyTo = function(node) {
        var self = this;
        return new Promise(function(resolve, reject) {
            if (!node) {
                reject(new Error("NodeObject.copyTo() no dest node provided"));
                return;
            }
            var req = {method: "node_copyTo", src: self, dst: node};
            chrome.runtime.sendNativeMessage(fio_host, req, function(result) {
                if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                    return;
                }

                if (result.error) {
                    reject(new Error(result.error));
                    return;
                }

                resolve();
            });
        });
    };


    // moveTo(NodeObject dest)
    NodeObject.prototype.moveTo = function(node) {
        var self = this;
        return new Promise(function(resolve, reject) {
            if (!node) {
                reject(new Error("NodeObject.moveTo() no dest node provided"));
                return;
            }
            var req = {method: "node_moveTo", src: self, dst: node};
            chrome.runtime.sendNativeMessage(fio_host, req, function(result) {
                if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                    return;
                }

                if (result.error) {
                    reject(new Error(result.error));
                    return;
                }

                resolve();
            });
        });
    };


    // remove()
    NodeObject.prototype.remove = function() {
        var self = this;
        return new Promise(function(resolve, reject) {
            var req = {method: "node_remove", node: self};
            chrome.runtime.sendNativeMessage(fio_host, req, function(result) {
                if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                    return;
                }

                if (result.error) {
                    reject(undefined, new Error(result.error));
                    return;
                }

                resolve();
            });
        });
    };


    // afio implementation
    var obj = {};

    /* Quick test for the availability of the host */
    obj.isInstalled = function() {
        return new Promise(function(resolve, reject) {
            var req = {method: "isInstalled", version:Storage.getChar("version")};
            chrome.runtime.sendNativeMessage(fio_host, req, function(result) {
                resolve(!chrome.runtime.lastError);
            });
        });
    };

    /* Query limits */
    obj.queryLimits = function() {
        return new Promise(function(resolve, reject) {
            var req = {method: "queryLimits"};
            chrome.runtime.sendNativeMessage(fio_host, req, function(result) {
                if(chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError)
                } else if (result.error) {
                    reject(result.error)
                } else {
                    resolve(result)
                }
            });
        });
    };


    /*
      openNode(String path)
    */
    obj.openNode = function(path) {
        if (!path) throw new Error("afio.openNode() no path provided");
        return new NodeObject({_path: path});
    };


    /*
      readTextFile(NodeObject node)
        returns the content of for the given node object or error in case file
        can not be read.
    */
    obj.readTextFile = function(node) {
        return new Promise(function(resolve, reject) {
            if (!node) {
                reject(new Error("afio.readTextFile() no file node provided"));
                return;
            }
            var req = {method: "readTextFile", node: node};
            chrome.runtime.sendNativeMessage(fio_host, req, function(result) {
                if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                    return;
                }

                if (result.error) {
                    reject(new Error(result.error));
                    return;
                }

                resolve(result.data);
            });
        });
    };


    /*
     writeTextFile(NodeObject node, String data)
       resolves with no arguments on success
    */

    obj.writeTextFile = function(node, data) {
        return new Promise(function(resolve, reject) {
            if (!node) {
                reject(new Error("afio.writeTextFile() no file node provided"));
                return;
            }
            var req = {method: "writeTextFile", node: node, data: (data || "")};
            chrome.runtime.sendNativeMessage(fio_host, req, function(result) {
                if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                    return;
                }

                if (result.error) {
                    reject(new Error(result.error));
                    return;
                }

                resolve();
            });
        });
    };

    /*
      appendTextFile(NodeObject node, String data)
        resolves with no arguments on success
    */

    obj.appendTextFile = function(node, data) {
        return new Promise(function(resolve, reject) {
            if (!node) {
                reject(new Error("afio.appendTextFile() no file provided"));
                return;
            }
            var req = {method: "appendTextFile",
                       node: node, data: (data || "")};
            chrome.runtime.sendNativeMessage(fio_host, req, function(result) {
                if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                    return;
                }
                if (result.error) {
                    reject(new Error(result.error));
                    return;
                }
                resolve();
            });
        });
    };


    /*
     getNodesIndir(NodeObject node, [optional] String filter)
        resolves with an array of nodes representing directory listing.
    */
    obj.getNodesInDir = function(node, filter) {
        return new Promise(function(resolve, reject) {
            if (!node) {
                reject(new Error("afio.getNodesInDir() no file node provided"));
                return;
            }
            node.isDir().then(function(is_dir) {
                if (!is_dir) {
                    reject(new Error(
                        "afio.getNodesInDir() node is not a directory"
                    ));
                    return;
                }
                var req = {method: "getNodesInDir", node: node};
                if (typeof filter == "string")
                    req.filter = filter;
                chrome.runtime.sendNativeMessage(
                    fio_host, req, function(result) {
                        if (chrome.runtime.lastError) {
                            reject(chrome.runtime.lastError);
                            return;
                        }

                        if (result.error) {
                            reject(new Error(result.error));
                            return;
                        }

                        if (typeof(filter) == "function")
                            resolve(result.nodes.map(function(x) {
                                return new NodeObject(x);
                            }).filter(filter));
                        else
                            resolve(result.nodes.map(function(x) {
                                return new NodeObject(x);
                            }));
                    }
                );
            }).catch(reject);
        });
    };

    /*
     getLogicalDrives()
        resolves with an array of nodes representing root logical drives on
        Windows or just an array containing single element "/" for *nix system.
    */
    obj.getLogicalDrives = function() {
        return new Promise(function(resolve, reject) {
            var req = {method: "getLogicalDrives"};
            chrome.runtime.sendNativeMessage(fio_host, req, function(result) {
                if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                    return;
                }

                if (result.error) {
                    reject(new Error(result.error));
                    return;
                }

                resolve(result.nodes.map(function(x) {
                    return new NodeObject(x);
                }));
            });
        });
    };


    /*
     getDefaultDir(String name)
        resolves with a node for the corresponding default dir or null if
        it hasn't been set yet.
    */
    obj.getDefaultDir = function(name) {
        var self = this;
        return new Promise(function(resolve, reject) {
            if (!/^(?:downpath|datapath|logpath|savepath)$/.test(name)) {
                reject(new Error("afio.getDefaultDir() wrong dir name "+name));
                return;
            }

            if (localStorage["def"+name]) {
                resolve(self.openNode(localStorage["def"+name]));
                return;
            }

            // not initialized yet, so we have to ask host to do that
            var req = {method: "getDefaultDir", name: name};
            chrome.runtime.sendNativeMessage(fio_host, req, function(result) {
                if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                    return;
                }
                if (result.error) {
                    reject(new Error(result.error));
                    return;
                }
                resolve(new NodeObject(result.node));
            });
        });
    };

    /*
     makeDirectory(NodeObject node)
        resolves with no arguments on success
    */
    obj.makeDirectory = function(node) {
        return new Promise(function(resolve, reject) {
            if (!node) {
                reject(new Error("afio.makeDirectory() node is not provided"));
                return;
            }

            var req = {method: "makeDirectory", node: node};
            chrome.runtime.sendNativeMessage(fio_host, req, function(result) {
                if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                    return;
                }

                if (result.error) {
                    reject(new Error(result.error));
                    return;
                }

                resolve();
            });
        });
    };

    /*
     writeImageToFile(NodeObject node, imageDataType imageData)
      imageDataType is
       {
        image: <base64 encoded string>,
        encoding: <encoding type, now only base64 supported>,
        mimeType: <image MIME type>
       };
      resolves with no arguments on success
    */
    obj.writeImageToFile = function(node, data) {
        return new Promise(function(resolve, reject) {
            if (!node) {
                reject(
                    new Error("afio.writeImageToFile() node is not provided")
                );
                return;
            }

            if (!data || !data.image || !data.encoding || !data.mimeType) {
                reject(
                    new Error("afio.writeImageToFile() imageData is "+
                              "not provided or has wrong type")
                );
                return;
            }

            var req = {method: "writeImageToFile", node: node, imageData: data};
            chrome.runtime.sendNativeMessage(fio_host, req, function(result) {
                if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                    return;
                }

                resolve();
            });
        });
    };


    return obj;
}) ();



======================================================================
FILE PATH: background.js
======================================================================
/*
 * Background Service Worker for iMacros MV3
 * Replaces bg.html from MV2
 */

/* global chrome */

// MV3 Service Worker Polyfills for DOM-dependent code
// These provide compatibility shims for code expecting a DOM environment

// Create a minimal window/document shim for compatibility
// This allows legacy code to run without immediate crashes
const globalThis_shim = globalThis || self;

// Store message event listeners for manual dispatch
// Each entry is {handler, options} to support proper duplicate prevention and removal
const messageEventListeners = [];

if (typeof window === 'undefined') {
    globalThis_shim.window = globalThis_shim;
}

if (typeof document === 'undefined') {
    globalThis_shim.document = {
        getElementById: function (id) {
            // Sandbox iframe handling for MV3
            if (id === 'sandbox') {
                console.warn('[iMacros MV3] Sandbox iframe not available in service worker, using offscreen document pattern');
                // Return a proxy object that handles postMessage
                return {
                    contentWindow: {
                        postMessage: function (data, targetOrigin) {
                            // Forward to offscreen document or handle differently
                            handleSandboxMessage(data);
                        }
                    }
                };
            }
            return null;
        },
        createEvent: function (eventType) {
            console.warn('[iMacros MV3] document.createEvent called in service worker:', eventType);
            return {
                initEvent: function () { },
                initCustomEvent: function () { }
            };
        },
        createElement: function (tag) {
            console.warn('[iMacros MV3] document.createElement called in service worker:', tag);
            return {};
        },
        createElementNS: function (namespace, tag) {
            console.warn('[iMacros MV3] document.createElementNS called in service worker:', namespace, tag);
            // Return a more complete mock element to avoid TypeErrors
            // Used by SCREENSHOT/SAVEAS commands which need canvas support
            return {
                style: {},  // Prevent "cannot read property 'width' of undefined"
                width: 0,
                height: 0,
                getContext: function () {
                    console.error('[iMacros MV3] Canvas operations not supported in service worker. Use offscreen document instead.');
                    return null;
                },
                toDataURL: function () {
                    throw new Error('[iMacros MV3] Canvas.toDataURL not supported in service worker');
                }
            };
        },
        implementation: {
            createDocument: function (namespaceURI, qualifiedName, doctype) {
                console.warn('[iMacros MV3] document.implementation.createDocument called in service worker');
                // Return a more complete XML document mock
                // Used by profiler output features
                const mockElement = {
                    nodeName: qualifiedName,
                    appendChild: function (child) { return child; },
                    setAttribute: function () { },
                    textContent: ''
                };
                return {
                    documentElement: mockElement,  // Prevent "cannot read property 'appendChild' of undefined"
                    createElement: function (name) {
                        return {
                            nodeName: name,
                            appendChild: function (child) { return child; },
                            setAttribute: function () { },
                            setAttributeNode: function () { },
                            textContent: ''
                        };
                    },
                    createAttribute: function (name) {
                        return {
                            name: name,
                            nodeValue: '',
                            value: ''
                        };
                    },
                    createTextNode: function (text) {
                        return { nodeValue: text, textContent: text };
                    },
                    appendChild: function (child) {
                        mockElement.appendChild(child);
                        return child;
                    }
                };
            }
        },
        addEventListener: function (event, handler) {
            // No-op in service worker context
            console.warn('[iMacros MV3] document.addEventListener ignored in service worker:', event);
        }
    };
}

// Add window.addEventListener shim with message listener tracking
// CRITICAL: Always override addEventListener, even if native one exists from window=self
// This ensures message events are captured in messageEventListeners for postMessage shim
//
// WARNING: This file is ONLY for MV3 Service Worker environments!
// The always-override approach bypasses native message event propagation.
// DO NOT load this file in DOM window contexts or you will break native events.
const nativeAddEventListener = globalThis_shim.window.addEventListener;
const nativeRemoveEventListener = globalThis_shim.window.removeEventListener;
const nativePostMessage = globalThis_shim.window.postMessage;

// Helper function to normalize event listener options for comparison
// Per spec, two listeners are the same if they have the same handler AND capture value
function normalizeListenerOptions(options) {
    // Handle boolean useCapture (legacy API)
    if (typeof options === 'boolean') {
        return { capture: options, once: false };
    }
    // Handle options object
    if (options && typeof options === 'object') {
        return {
            capture: !!options.capture,
            once: !!options.once
        };
    }
    // Undefined or null defaults to capture: false, once: false
    return { capture: false, once: false };
}

// Helper function to check if two listener entries match
function listenersMatch(entry, handler, options) {
    if (entry.handler !== handler) {
        return false;
    }
    const normalized1 = normalizeListenerOptions(entry.options);
    const normalized2 = normalizeListenerOptions(options);
    return normalized1.capture === normalized2.capture;
}

// Helper function to invoke event listener (supports both function and object with handleEvent)
// Per DOM spec: handler can be a function OR an object with handleEvent method
function invokeEventListener(handler, event, thisArg) {
    if (typeof handler === 'function') {
        handler.call(thisArg, event);
    } else if (handler && typeof handler.handleEvent === 'function') {
        handler.handleEvent(event);
    } else {
        console.warn('[iMacros MV3] Invalid event listener:', handler);
    }
}

globalThis_shim.window.addEventListener = function (event, handler, options) {
    if (event === 'load') {
        // Service workers don't have a load event, execute immediately with event object
        // Per DOM spec: 'this' inside handler should be currentTarget (window)
        // Supports both function and object with handleEvent method
        setTimeout(() => {
            invokeEventListener(handler, {
                type: 'load',
                target: globalThis_shim.window,
                currentTarget: globalThis_shim.window
            }, globalThis_shim.window);
        }, 0);
    } else if (event === 'message') {
        // Store message listeners so we can manually dispatch to them
        // Prevent duplicate registration: same handler + same capture value (per spec)
        const existingIndex = messageEventListeners.findIndex(entry =>
            listenersMatch(entry, handler, options)
        );
        if (existingIndex === -1) {
            messageEventListeners.push({ handler, options });
        }
    } else if (nativeAddEventListener) {
        // Delegate other events to native implementation
        nativeAddEventListener.call(globalThis_shim.window, event, handler, options);
    } else {
        console.warn('[iMacros MV3] window.addEventListener ignored in service worker:', event);
    }
};

// Add window.removeEventListener shim to prevent memory leaks
globalThis_shim.window.removeEventListener = function (event, handler, options) {
    if (event === 'message') {
        // Remove handler from messageEventListeners array
        // Must match both handler AND capture value (per spec)
        const index = messageEventListeners.findIndex(entry =>
            listenersMatch(entry, handler, options)
        );
        if (index !== -1) {
            messageEventListeners.splice(index, 1);
        }
    } else if (nativeRemoveEventListener) {
        // Delegate other events to native implementation
        nativeRemoveEventListener.call(globalThis_shim.window, event, handler, options);
    } else {
        console.warn('[iMacros MV3] window.removeEventListener ignored in service worker:', event);
    }
};

// Add window.postMessage shim that dispatches to stored listeners
globalThis_shim.window.postMessage = function (message, targetOrigin) {
    // Manually dispatch to all registered message listeners
    const event = {
        data: message,
        origin: targetOrigin || '*',
        source: globalThis_shim.window,
        type: 'message',
        currentTarget: globalThis_shim.window,
        target: globalThis_shim.window
    };

    // Call all registered message listeners
    // Use for loop (not forEach) to support 'once' option removal during iteration
    for (let i = messageEventListeners.length - 1; i >= 0; i--) {
        const entry = messageEventListeners[i];
        try {
            // Per DOM spec: 'this' inside handler should be currentTarget (window)
            // Supports both function and object with handleEvent method
            invokeEventListener(entry.handler, event, globalThis_shim.window);

            // If 'once' option is true, remove listener after first call (per spec)
            const normalized = normalizeListenerOptions(entry.options);
            if (normalized.once) {
                messageEventListeners.splice(i, 1);
            }
        } catch (err) {
            console.error('[iMacros MV3] Error in message handler:', err);
        }
    }
};

// Add window.open shim - uses chrome.windows.create and returns mock window object
if (!globalThis_shim.window.open) {
    globalThis_shim.window.open = function (url, target, features) {
        console.debug('[iMacros MV3] window.open called, using chrome.windows.create instead');

        // Create a mock window object to prevent "cannot set property of null" errors
        // This allows code like `win.args = {...}` to work without crashing
        const mockWindow = {
            id: null,  // Will be set when window is created (or -1 on error)
            args: null,
            closed: false,
            error: null,  // Will be set if creation fails
            close: function () {
                this.closed = true;
                console.warn('[iMacros MV3] Mock window.close() called - no action taken');
            }
        };

        // Convert to chrome.windows.create for actual window creation
        chrome.windows.create({
            url: chrome.runtime.getURL(url),
            type: 'popup',
            focused: true
        }).then(w => {
            // Validate window ID (Chrome API spec says id is optional)
            if (!w || typeof w.id !== 'number' || w.id <= 0) {
                console.error('[iMacros MV3] Invalid or missing window ID:', w?.id);
                mockWindow.id = -1;
                mockWindow.error = new Error('Invalid window ID returned from chrome.windows.create');
                return;
            }
            // Store the actual window ID in the mock object
            // This allows dialogUtils.setArgs to use the window ID
            mockWindow.id = w.id;
            console.log('[iMacros MV3] Window created successfully with ID:', w.id);
        }).catch(err => {
            console.error('[iMacros MV3] Failed to create window:', err);
            // Set id to -1 to signal error and stop polling in dialogUtils
            mockWindow.id = -1;
            mockWindow.error = err;
        });

        // Return mock window object so callers can set properties without errors
        return mockWindow;
    };
}

// Add window.dispatchEvent shim
if (!globalThis_shim.window.dispatchEvent) {
    globalThis_shim.window.dispatchEvent = function (event) {
        console.warn('[iMacros MV3] window.dispatchEvent ignored in service worker');
        return true;
    };
}

// Add XMLSerializer shim for XML document serialization
if (typeof XMLSerializer === 'undefined') {
    globalThis_shim.XMLSerializer = function () { };
    globalThis_shim.XMLSerializer.prototype.serializeToString = function (doc) {
        console.warn('[iMacros MV3] XMLSerializer.serializeToString called in service worker');
        // Return a basic XML string representation
        if (doc && doc.documentElement) {
            return '<?xml version="1.0"?><' + doc.documentElement.nodeName + '/>';
        }
        return '<?xml version="1.0"?>';
    };
}

// Offscreen document for sandbox evaluation
// In MV3, service workers can't use eval or iframes, so we use an offscreen document
let offscreenDocumentCreating = null;

async function ensureOffscreenDocument() {
    // Check if offscreen document already exists
    if (await chrome.offscreen.hasDocument?.()) {
        return;
    }

    // If creation is in progress, wait for it
    if (offscreenDocumentCreating) {
        await offscreenDocumentCreating;
        return;
    }

    // Create offscreen document
    // Use offscreen.html (with chrome API access) instead of sandbox.html (sandboxed, no API access)
    // Use IFRAME_SCRIPTING for Chrome 109+ compatibility (WORKERS only available in 113+)
    offscreenDocumentCreating = chrome.offscreen.createDocument({
        url: 'offscreen.html',
        reasons: [
            chrome.offscreen.Reason?.IFRAME_SCRIPTING || 'IFRAME_SCRIPTING',
            chrome.offscreen.Reason?.CLIPBOARD || 'CLIPBOARD'
        ],
        justification: 'Offscreen document for evaluating macro expressions and clipboard access'
    }).catch(err => {
        console.error('[iMacros MV3] Failed to create offscreen document:', err);
        offscreenDocumentCreating = null;
        throw err;
    });

    await offscreenDocumentCreating;
    offscreenDocumentCreating = null;
}

// Sandbox message handler for MV3
// In MV3, we use offscreen documents instead of eval (which violates CSP)
async function handleSandboxMessage(data) {
    if (data.type === 'eval_in_sandbox') {
        console.log('[iMacros MV3] Sandbox eval requested:', data);

        try {
            // Ensure offscreen document exists
            // Note: chrome.offscreen API requires Chrome 109+
            if (chrome.offscreen && chrome.offscreen.createDocument) {
                await ensureOffscreenDocument();

                // Forward the eval request to the offscreen document and wait for response
                // The offscreen document will evaluate and return the result
                chrome.runtime.sendMessage(data, (response) => {
                    if (chrome.runtime.lastError) {
                        console.error('[iMacros MV3] Failed to send message to offscreen:', chrome.runtime.lastError);
                        const errorResponse = {
                            type: 'eval_in_sandbox_result',
                            id: data.id,
                            result: null,
                            error: chrome.runtime.lastError.message
                        };
                        window.postMessage(errorResponse, '*');
                        return;
                    }

                    // Forward the response from offscreen to MacroPlayer via window.postMessage
                    if (response && response.type === 'eval_in_sandbox_result') {
                        window.postMessage(response, '*');
                    }
                });
            } else {
                // Fallback: If offscreen API not available, return error
                console.error('[iMacros MV3] Offscreen API not available (requires Chrome 109+)');
                const response = {
                    type: 'eval_in_sandbox_result',
                    id: data.id,
                    result: null,
                    error: 'Sandbox evaluation requires Chrome 109+ (Offscreen API)'
                };

                if (typeof window !== 'undefined' && window.postMessage) {
                    window.postMessage(response, '*');
                }
            }
        } catch (error) {
            console.error('[iMacros MV3] Sandbox error:', error);
            const response = {
                type: 'eval_in_sandbox_result',
                id: data.id,
                result: null,
                error: error.toString()
            };

            if (typeof window !== 'undefined' && window.postMessage) {
                window.postMessage(response, '*');
            }
        }
    }
}

// Add localStorage polyfill for MV3 Service Worker
// Service workers don't have access to localStorage, so we create a shim using chrome.storage.local
// bg.js startup logic and any imported scripts must see a populated cache before running startup checks
let localStorageInitPromise = Promise.resolve(true);
if (typeof localStorage === 'undefined') {
    console.log('[iMacros MV3] Creating localStorage polyfill using chrome.storage.local');

    // In-memory cache for synchronous access
    // This allows existing synchronous code to work without modification
    const localStorageCache = {};
    const STORAGE_PREFIX = 'localStorage_';

    // Load cache using top-level await so importScripts() happens after data is ready
    localStorageInitPromise = (async () => {
        try {
            const startTime = Date.now();
            console.log('[iMacros MV3] Loading localStorage cache from chrome.storage.local');
            const result = await chrome.storage.local.get(null);

            // Populate cache with all localStorage items
            // IMPORTANT: Only set values that aren't already in cache to avoid overwriting
            // values written by setItem() during initialization (race condition protection)
            let count = 0;
            for (const key in result) {
                if (key.startsWith(STORAGE_PREFIX)) {
                    const actualKey = key.substring(STORAGE_PREFIX.length);
                    // Only populate if key doesn't already exist in cache
                    if (!(actualKey in localStorageCache)) {
                        localStorageCache[actualKey] = result[key];
                        count++;
                    }
                }
            }

            const duration = Date.now() - startTime;
            console.log(`[iMacros MV3] localStorage cache loaded: ${count} items in ${duration}ms`);
            console.log('[iMacros MV3] localStorage polyfill initialized successfully');
            return true;  // Signal successful initialization
        } catch (error) {
            console.error('[iMacros MV3] Failed to load localStorage cache:', error);
            // Continue with empty cache rather than blocking extension startup
            return false;
        }
    })();

    // Expose initialization promise for bg.js startup logic to await
    globalThis.localStorageInitPromise = localStorageInitPromise;

    // Persist a value to chrome.storage.local
    // This happens asynchronously in the background
    function persistToStorage(key, value) {
        const storageKey = STORAGE_PREFIX + key;
        if (value === undefined || value === null) {
            chrome.storage.local.remove(storageKey).catch(err => {
                console.error('[iMacros MV3] Failed to remove from chrome.storage.local:', err);
            });
        } else {
            chrome.storage.local.set({ [storageKey]: value }).catch(err => {
                console.error('[iMacros MV3] Failed to persist to chrome.storage.local:', err);
            });
        }
    }

    // Create localStorage polyfill object
    const localStoragePolyfill = {
        getItem: function (key) {
            if (key in localStorageCache) {
                return localStorageCache[key];
            }
            return null;
        },

        setItem: function (key, value) {
            const stringValue = String(value);
            localStorageCache[key] = stringValue;
            persistToStorage(key, stringValue);
        },

        removeItem: function (key) {
            delete localStorageCache[key];
            persistToStorage(key, null);
        },

        clear: function () {
            // Get all localStorage keys
            const keys = Object.keys(localStorageCache);

            // Clear cache
            for (const key of keys) {
                delete localStorageCache[key];
            }

            // Clear from chrome.storage.local
            const storageKeys = keys.map(k => STORAGE_PREFIX + k);
            if (storageKeys.length > 0) {
                chrome.storage.local.remove(storageKeys).catch(err => {
                    console.error('[iMacros MV3] Failed to clear chrome.storage.local:', err);
                });
            }
        },

        key: function (index) {
            const keys = Object.keys(localStorageCache);
            return keys[index] || null;
        },

        get length() {
            return Object.keys(localStorageCache).length;
        }
    };

    // Support bracket notation (localStorage[key])
    // This is a common pattern in legacy code
    const handler = {
        get: function (target, prop) {
            if (prop === 'length') {
                return Object.keys(localStorageCache).length;
            }
            if (typeof target[prop] !== 'undefined') {
                return target[prop];
            }
            return target.getItem(prop);
        },
        set: function (target, prop, value) {
            if (prop === 'getItem' || prop === 'setItem' || prop === 'removeItem' ||
                prop === 'clear' || prop === 'key' || prop === 'length') {
                return false; // Don't allow overwriting methods
            }
            target.setItem(prop, value);
            return true;
        },
        deleteProperty: function (target, prop) {
            target.removeItem(prop);
            return true;
        },
        has: function (target, prop) {
            return prop in localStorageCache || prop in target;
        },
        ownKeys: function (target) {
            return Object.keys(localStorageCache);
        },
        getOwnPropertyDescriptor: function (target, prop) {
            if (prop in localStorageCache) {
                return {
                    value: localStorageCache[prop],
                    writable: true,
                    enumerable: true,
                    configurable: true
                };
            }
            return Object.getOwnPropertyDescriptor(target, prop);
        }
    };

    globalThis_shim.localStorage = new Proxy(localStoragePolyfill, handler);

    console.log('[iMacros MV3] localStorage polyfill ready with pre-loaded cache');
} else {
    // Ensure downstream code can still await the init promise even if native localStorage exists
    globalThis.localStorageInitPromise = localStorageInitPromise;
}

// Wait for the localStorage cache to finish loading before importing dependent scripts
// NOTE: Top-level await is NOT allowed in classic Service Workers (without type: module)
// We must allow importScripts to run immediately. Dependent scripts should ideally
// wait for localStorageInitPromise if they need to access localStorage immediately on startup.
/*
try {
    await localStorageInitPromise;
    console.log('[iMacros MV3] localStorage cache ready before loading bg.js dependencies');
} catch (err) {
    console.error('[iMacros MV3] localStorage cache failed to load before importScripts:', err);
}
*/

// Import all dependencies using importScripts
// IMPORTANT: Load order matters - context.js must be loaded before nm_connector.js
// because nm_connector.js references the global 'context' object
// GlobalErrorLogger.js must be loaded before errorLogger.js for compatibility layer
importScripts(
    'utils.js',
    'GlobalErrorLogger.js', // New unified error logging system
    'errorLogger.js',       // Legacy error logger (now uses GlobalErrorLogger as backend)
    'context.js',          // Define context first
    'nm_connector.js',     // Uses context
    'communicator.js',
    'badge.js',
    'variable-manager.js', // Variable manager for macro chaining
    'mplayer.js',
    'mrecorder.js',
    'rijndael.js',
    'VirtualFileService.js',
    'WindowsPathMappingService.js',
    'FileSystemAccessService.js',
    'FileSyncBridge.js',
    'AsyncFileIO.js',
    'bg.js'
);

// Helper function to find context by panel ID
function findContextByPanelId(panelWindowId) {
    if (typeof context === 'undefined') return null;
    for (let win_id in context) {
        if (context[win_id] && context[win_id].panelId === panelWindowId) {
            return context[win_id];
        }
    }
    return null;
}

// Helper function to create a panel window proxy for MV3
// This replaces the direct window object reference used in MV2
function createPanelProxy(panelWindowId) {
    // Helper function to send messages to the panel
    function sendToPanel(type, data) {
        chrome.runtime.sendMessage({
            type: type,
            panelWindowId: panelWindowId,
            data: data
        }, function (response) {
            if (chrome.runtime.lastError) {
                console.debug('[iMacros MV3] Error sending to panel:', chrome.runtime.lastError);
            }
        });
    }

    return {
        // Check if window is closed
        get closed() {
            // Return cached state based on panelClosing flag
            const ctx = findContextByPanelId(panelWindowId);
            return !ctx || ctx.panelClosing === true;
        },

        // Close the panel window
        close: function () {
            chrome.windows.remove(panelWindowId, function () {
                if (chrome.runtime.lastError) {
                    console.debug('[iMacros MV3] Error closing panel:', chrome.runtime.lastError);
                }
            });
        },

        // Update panel UI state
        updatePanel: function (state) {
            // Broadcast message with panelWindowId so the specific panel can check if it's the target
            chrome.runtime.sendMessage({
                type: 'UPDATE_PANEL_STATE',
                panelWindowId: panelWindowId,
                state: state
            }, function (response) {
                if (chrome.runtime.lastError) {
                    console.debug('[iMacros MV3] Error updating panel state:', chrome.runtime.lastError);
                }
            });
        },

        // Show lines in the macro view
        showLines: function (code) {
            sendToPanel('PANEL_SHOW_LINES', { code: code });
        },

        // Set status line message
        setStatLine: function (txt, type) {
            sendToPanel('PANEL_SET_STAT_LINE', { txt: txt, type: type });
        },

        // Add a line to the macro view
        addLine: function (txt) {
            sendToPanel('PANEL_ADD_LINE', { txt: txt });
        },

        // Highlight a specific line
        highlightLine: function (line) {
            sendToPanel('PANEL_HIGHLIGHT_LINE', { line: line });
        },

        // Show macro tree view
        showMacroTree: function () {
            sendToPanel('PANEL_SHOW_MACRO_TREE', {});
        },

        // Set loop value
        setLoopValue: function (value) {
            sendToPanel('PANEL_SET_LOOP_VALUE', { value: value });
        },

        // Show info
        showInfo: function (args) {
            sendToPanel('PANEL_SHOW_INFO', { args: args });
        },

        // Remove last line from macro view
        removeLastLine: function () {
            sendToPanel('PANEL_REMOVE_LAST_LINE', {});
        },

        // Frames property for accessing iframes within panel
        // In MV3, we can't directly access frames, so we provide methods instead
        get frames() {
            return {
                // Provide a way to reload the tree-iframe
                'tree-iframe': {
                    get contentDocument() {
                        // Return a proxy that can reload the tree
                        return {
                            get defaultView() {
                                return {
                                    get location() {
                                        return {
                                            reload: function () {
                                                sendToPanel('PANEL_RELOAD_TREE', {});
                                            }
                                        };
                                    }
                                };
                            }
                        };
                    }
                }
            };
        },

        // Window dimensions - cached from actual window
        // These are updated when panel is created/resized
        get outerWidth() {
            const ctx = findContextByPanelId(panelWindowId);
            return ctx?.panelWidth || 210; // Default width
        },

        get outerHeight() {
            const ctx = findContextByPanelId(panelWindowId);
            return ctx?.panelHeight || 600; // Default height
        }
    };
}

// Security: Whitelist of allowed background functions and context methods
// This prevents arbitrary code execution via message passing
const ALLOWED_BG_FUNCTIONS = new Set([
    'getLimits',
    'edit',
    'save',
    'addTab',
    'isPersonalVersion',
    'xhr'
]);

const ALLOWED_CONTEXT_METHODS = {
    'mplayer': new Set(['play', 'pause', 'unpause', 'stop']),
    'recorder': new Set(['start', 'stop', 'saveAs', 'capture'])
};

// Add message listener for MV3 compatibility - replacement for getBackgroundPage()
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    if (message.type === 'GET_BACKGROUND_CONTEXT') {
        // Return context information that UI pages might need
        // This replaces the need for getBackgroundPage()
        sendResponse({
            context: typeof context !== 'undefined' ? context : null,
            Storage: typeof Storage !== 'undefined' ? Storage : null,
            // Note: Functions can't be serialized, so this is limited
            // UI pages may need to send messages for specific operations
        });
        return true; // Keep the message channel open for async response
    }

    // Handle panel initialization
    if (message.type === 'PANEL_LOADED') {
        try {
            // MV3: Create a proxy object that simulates the panel window for MV3
            const panelWindowId = message.panelWindowId;
            const panelProxy = createPanelProxy(panelWindowId);
            const win_id = onPanelLoaded(panelProxy, panelWindowId);
            sendResponse({ success: true, win_id: win_id });
        } catch (error) {
            console.error('[iMacros MV3] Error in PANEL_LOADED:', error);
            sendResponse({ success: false, error: error.message });
        }
        return true;
    }

    // Handle panel view updates from options page
    if (message.type === 'UPDATE_PANEL_VIEWS') {
        try {
            if (typeof context === 'undefined') {
                sendResponse({ success: false, error: 'Context not available' });
                return true;
            }
            // In MV3, broadcast message to all extension pages (panels)
            // Panel pages listen with chrome.runtime.onMessage, not tabs.sendMessage
            // This is a broadcast, so all open panels will receive and refresh
            chrome.runtime.sendMessage({
                type: 'REFRESH_PANEL_TREE'
            }, function (response) {
                if (chrome.runtime.lastError) {
                    // Expected if no panels are open
                    console.debug('[iMacros MV3] No panels to update:', chrome.runtime.lastError);
                }
            });

            sendResponse({ success: true });
        } catch (error) {
            console.error('[iMacros MV3] Error in UPDATE_PANEL_VIEWS:', error);
            sendResponse({ success: false, error: error.message });
        }
        return true;
    }

    // Handle localStorage cache reload request from options page
    if (message.type === 'RELOAD_LOCALSTORAGE_CACHE') {
        try {
            console.log('[iMacros MV3] Reloading localStorage cache from chrome.storage.local');
            // Reload the cache by calling the initialization function again
            if (typeof globalThis.reloadLocalStorageCache === 'function') {
                globalThis.reloadLocalStorageCache().then(() => {
                    console.log('[iMacros MV3] localStorage cache reloaded successfully');
                    sendResponse({ success: true });
                }).catch(err => {
                    console.error('[iMacros MV3] Failed to reload localStorage cache:', err);
                    sendResponse({ success: false, error: err.message });
                });
            } else {
                // Fallback: manually reload from chrome.storage.local
                chrome.storage.local.get(null, (items) => {
                    if (chrome.runtime.lastError) {
                        sendResponse({ success: false, error: chrome.runtime.lastError.message });
                        return;
                    }
                    // Update the localStorage polyfill cache
                    for (const key in items) {
                        if (key.startsWith('localStorage_')) {
                            const localKey = key.substring(13); // Remove 'localStorage_' prefix
                            localStorage.setItem(localKey, items[key]);
                        }
                    }
                    console.log('[iMacros MV3] localStorage cache reloaded successfully (fallback method)');
                    sendResponse({ success: true });
                });
            }
        } catch (error) {
            console.error('[iMacros MV3] Error in RELOAD_LOCALSTORAGE_CACHE:', error);
            sendResponse({ success: false, error: error.message });
        }
        return true;
    }

    // Handle dialog result from popup dialogs (MV3 compatible)
    if (message.type === 'SET_DIALOG_RESULT') {
        try {
            const { windowId, response } = message;
            if (typeof dialogUtils !== 'undefined') {
                dialogUtils.setDialogResult(windowId, response);
                sendResponse({ success: true });
            } else {
                sendResponse({ success: false, error: 'dialogUtils not available' });
            }
        } catch (error) {
            console.error('[iMacros MV3] Error in SET_DIALOG_RESULT:', error);
            sendResponse({ success: false, error: error.message });
        }
        return true;
    }

    // Handle dialog args request from popup dialogs (MV3 compatible)
    if (message.type === 'GET_DIALOG_ARGS') {
        try {
            const { windowId } = message;
            if (typeof dialogUtils !== 'undefined') {
                const args = dialogUtils.getDialogArgs(windowId);
                sendResponse({ success: true, args: args });
            } else {
                sendResponse({ success: false, error: 'dialogUtils not available' });
            }
        } catch (error) {
            console.error('[iMacros MV3] Error in GET_DIALOG_ARGS:', error);
            sendResponse({ success: false, error: error.message });
        }
        return true;
    }

    // Handle get panel ID request
    if (message.type === 'GET_PANEL_ID') {
        const { win_id } = message;
        try {
            if (typeof context === 'undefined' || !context[win_id]) {
                sendResponse({ success: false, error: 'Context not found for win_id: ' + win_id });
                return true;
            }
            sendResponse({ success: true, panelId: context[win_id].panelId });
        } catch (error) {
            console.error('[iMacros MV3] Error in GET_PANEL_ID:', error);
            sendResponse({ success: false, error: error.message });
        }
        return true;
    }

    // Handle temp password setting
    if (message.type === 'SET_TEMP_PASSWORD') {
        try {
            if (typeof Rijndael !== 'undefined') {
                Rijndael.tempPassword = message.password;
                sendResponse({ success: true });
            } else {
                sendResponse({ success: false, error: 'Rijndael not available' });
            }
        } catch (error) {
            console.error('[iMacros MV3] Error in SET_TEMP_PASSWORD:', error);
            sendResponse({ success: false, error: error.message });
        }
        return true;
    }

    // Handle mplayer pause state check
    if (message.type === 'CHECK_MPLAYER_PAUSED') {
        const { win_id } = message;
        try {
            if (typeof context === 'undefined' || !context[win_id]) {
                sendResponse({ success: false, error: 'Context not found for win_id: ' + win_id });
                return true;
            }
            const mplayer = context[win_id].mplayer;
            const isPaused = !!(mplayer && (mplayer.paused || mplayer.pauseIsPending));
            sendResponse({ success: true, isPaused: isPaused });
        } catch (error) {
            console.error('[iMacros MV3] Error in CHECK_MPLAYER_PAUSED:', error);
            sendResponse({ success: false, error: error.message });
        }
        return true;
    }

    // Handle recorder state check
    if (message.type === 'GET_RECORDER_STATE') {
        const { win_id } = message;
        try {
            if (typeof context === 'undefined' || !context[win_id]) {
                sendResponse({ success: false, error: 'Context not found for win_id: ' + win_id });
                return true;
            }
            const recorder = context[win_id].recorder;
            if (recorder) {
                sendResponse({
                    success: true,
                    recording: recorder.recording,
                    actions: recorder.actions || []
                });
            } else {
                sendResponse({ success: false, error: 'Recorder not available' });
            }
        } catch (error) {
            console.error('[iMacros MV3] Error in GET_RECORDER_STATE:', error);
            sendResponse({ success: false, error: error.message });
        }
        return true;
    }

    // Handle macro save (callback-based save function)
    if (message.type === 'SAVE_MACRO') {
        const { macro, overwrite } = message;
        try {
            // save() is callback-based, need to wrap it
            if (typeof save !== 'function') {
                sendResponse({ success: false, error: 'save function not available' });
                return true;
            }

            save(macro, overwrite, function (result) {
                // result contains {error, skipped, name} or success indicator
                if (result && result.error) {
                    sendResponse({ success: false, error: result.error, result: result });
                } else {
                    sendResponse({ success: true, result: result });
                }
            });
            return true; // Keep message channel open for async callback
        } catch (error) {
            console.error('[iMacros MV3] Error in SAVE_MACRO:', error);
            sendResponse({ success: false, error: error.message });
            return true;
        }
    }

    // Handle generic function calls from UI pages
    if (message.type === 'CALL_BG_FUNCTION') {
        const { functionName, args: funcArgs } = message;

        try {
            // Security check: Only allow whitelisted functions
            if (!ALLOWED_BG_FUNCTIONS.has(functionName)) {
                console.error('[iMacros MV3] Function not allowed:', functionName);
                sendResponse({ success: false, error: 'Function not allowed: ' + functionName });
                return true;
            }

            // Get the function from global scope
            let func = globalThis[functionName];

            if (typeof func !== 'function') {
                console.error('[iMacros MV3] Function not found:', functionName);
                sendResponse({ success: false, error: 'Function not found: ' + functionName });
                return true;
            }

            // Call the function with provided arguments
            const result = func.apply(globalThis, funcArgs || []);

            // Handle Promise results
            if (result && typeof result.then === 'function') {
                result.then(value => {
                    sendResponse({ success: true, result: value });
                }).catch(error => {
                    console.error('[iMacros MV3] Promise error in', functionName, ':', error);
                    sendResponse({ success: false, error: error.message || String(error) });
                });
                return true; // Keep message channel open for async response
            } else {
                // Synchronous result
                sendResponse({ success: true, result: result });
            }
        } catch (error) {
            console.error('[iMacros MV3] Error calling', functionName, ':', error);
            sendResponse({ success: false, error: error.message || String(error) });
        }
        return true;
    }

    // Handle context property access
    if (message.type === 'GET_CONTEXT_PROPERTY') {
        const { win_id, property } = message;

        try {
            if (typeof context === 'undefined' || !context[win_id]) {
                sendResponse({ success: false, error: 'Context not found for win_id: ' + win_id });
                return true;
            }

            const value = context[win_id][property];

            // We can't serialize functions or complex objects, so return a reference
            if (typeof value === 'function') {
                sendResponse({ success: true, isFunction: true });
            } else if (typeof value === 'object' && value !== null) {
                sendResponse({ success: true, isObject: true, type: value.constructor.name });
            } else {
                sendResponse({ success: true, value: value });
            }
        } catch (error) {
            console.error('[iMacros MV3] Error getting context property:', error);
            sendResponse({ success: false, error: error.message });
        }
        return true;
    }

    // Handle context method calls (like mplayer.play, recorder.start, etc.)
    if (message.type === 'CALL_CONTEXT_METHOD') {
        const { win_id, objectPath, methodName, args: methodArgs } = message;

        try {
            if (typeof context === 'undefined' || !context[win_id]) {
                sendResponse({ success: false, error: 'Context not found for win_id: ' + win_id });
                return true;
            }

            // Security check: Only allow whitelisted object paths and methods
            if (!objectPath || !ALLOWED_CONTEXT_METHODS[objectPath]) {
                console.error('[iMacros MV3] Object path not allowed:', objectPath);
                sendResponse({ success: false, error: 'Object path not allowed: ' + objectPath });
                return true;
            }
            if (!ALLOWED_CONTEXT_METHODS[objectPath].has(methodName)) {
                console.error('[iMacros MV3] Method not allowed:', objectPath + '.' + methodName);
                sendResponse({ success: false, error: 'Method not allowed: ' + objectPath + '.' + methodName });
                return true;
            }

            // Navigate to the object (e.g., context[win_id].mplayer)
            let obj = context[win_id];
            if (objectPath) {
                const parts = objectPath.split('.');
                for (let part of parts) {
                    obj = obj[part];
                    if (!obj) {
                        sendResponse({ success: false, error: 'Object path not found: ' + objectPath });
                        return true;
                    }
                }
            }

            // Call the method
            const method = obj[methodName];
            if (typeof method !== 'function') {
                sendResponse({ success: false, error: 'Method not found: ' + methodName });
                return true;
            }

            const result = method.apply(obj, methodArgs || []);

            // Handle Promise results
            if (result && typeof result.then === 'function') {
                result.then(value => {
                    sendResponse({ success: true, result: value });
                }).catch(error => {
                    console.error('[iMacros MV3] Promise error in', objectPath + '.' + methodName, ':', error);
                    sendResponse({ success: false, error: error.message || String(error) });
                });
                return true; // Keep message channel open for async response
            } else {
                sendResponse({ success: true, result: result });
            }
        } catch (error) {
            console.error('[iMacros MV3] Error calling context method:', error);
            sendResponse({ success: false, error: error.message || String(error) });
        }
        return true;
    }

    /* global context */
    // Handle login dialog processing (MV3 compatible replacement for getBackgroundPage)
    if (message.type === 'HANDLE_LOGIN_DIALOG') {
        try {
            const { username, password, args } = message;

            if (!args || !args.recorder || !args.cypherData) {
                sendResponse({ success: false, error: 'Missing required args' });
                return true;
            }

            // Encrypt password if needed
            let pwd = password;
            if (args.cypherData.encrypt) {
                if (typeof Rijndael !== 'undefined') {
                    pwd = Rijndael.encryptString(pwd, args.cypherData.key);
                } else {
                    console.error('[iMacros MV3] Rijndael not available for password encryption');
                    sendResponse({ success: false, error: 'Rijndael not available' });
                    return true;
                }
            }

            // Record the ONLOGIN command
            const rec = "ONLOGIN USER=" + username + " PASSWORD=" + pwd;

            // Remove previously recorded ONLOGIN command if exists
            const l = args.recorder.actions.length;
            const match_part = "ONLOGIN USER=";
            if (l && args.recorder.actions[l - 1].indexOf(match_part) === 0) {
                args.recorder.actions.pop();

                // Update panel to remove last line
                if (typeof context !== 'undefined' && context[args.recorder.win_id]) {
                    const panel = context[args.recorder.win_id].panelWindow;
                    if (panel && !panel.closed) {
                        panel.removeLastLine();
                    }
                }
            }

            // Record the new action
            args.recorder.recordAction(rec);

            // Prepare auth response (authCredentials needs plain password for HTTP authentication)
            const response = {
                authCredentials: {
                    username: username,
                    password: password  // Use plain password for HTTP authentication
                }
            };

            sendResponse({ success: true, response: response });
        } catch (error) {
            console.error('[iMacros MV3] Error in HANDLE_LOGIN_DIALOG:', error);
            sendResponse({ success: false, error: error.message });
        }
        return true;
    }

    // Handle panel closing notification
    if (message.type === 'PANEL_CLOSING') {
        const { win_id, panelBox } = message;
        try {
            // Save panel dimensions if provided
            if (panelBox && panelBox.left !== undefined && panelBox.top !== undefined) {
                chrome.storage.local.set({ 'panel-box': panelBox }, function () {
                    if (chrome.runtime.lastError) {
                        console.error('[iMacros MV3] Failed to save panel position:', chrome.runtime.lastError);
                    } else {
                        console.debug('[iMacros MV3] Panel position saved:', panelBox);
                    }
                });
            }

            // Mark that the panel is closing and cache final dimensions
            if (typeof context !== 'undefined' && context[win_id]) {
                context[win_id].panelClosing = true;
                // Cache final panel dimensions before closing
                if (panelBox && panelBox.width !== undefined && panelBox.height !== undefined) {
                    context[win_id].panelWidth = panelBox.width;
                    context[win_id].panelHeight = panelBox.height;
                }
            }
            sendResponse({ success: true });
        } catch (error) {
            console.error('[iMacros MV3] Error in PANEL_CLOSING:', error);
            sendResponse({ success: false, error: error.message });
        }
        return true;
    }

    // Note: eval_in_sandbox_result is now handled via sendResponse callback
    // in handleSandboxMessage, not as a separate incoming message
});

// MV3: Listen for window removals to clean up panel context
// Panel position is saved in PANEL_CLOSING handler before window closes
chrome.windows.onRemoved.addListener(function (windowId) {
    if (typeof context === 'undefined') {
        return;
    }

    // Find and clean up the context with matching panelId
    for (let win_id in context) {
        const ctx = context[win_id];
        if (ctx && ctx.panelId === windowId) {
            // Clean up panel references
            delete ctx.panelId;
            delete ctx.panelWindow;
            delete ctx.panelClosing;
            console.debug('[iMacros MV3] Panel context cleaned up for win_id:', win_id);
            break;
        }
    }
});

console.log('[iMacros MV3] Background service worker initialized');



======================================================================
FILE PATH: badge.js
======================================================================
/*
Copyright © 1992-2021 Progress Software Corporation and/or one of its subsidiaries or affiliates. All rights reserved.
*/

// Handy wrapper for browser action functions
// (badge is not really good naming for the object)
var badge = {
    // execute callback for all tabs in window
    // callback is function(tab) {...}
    forAllTabs: function(win_id, callback) {
        // for some stupid reason windows.get(win) does not
        // contain "tabs" property, so we have to get All windows
        chrome.windows.getAll({populate: true}, function(ws) {
            ws.forEach(function(win) {
                if (win.id == win_id) {
                    win.tabs.forEach(function(tab) {
                        callback(tab);
                    });
                    return;
                }
            });
        });
    },


    setBackgroundColor: function(win_id, color) {
        this.forAllTabs(win_id, function(tab) {
            chrome.browserAction.setBadgeBackgroundColor(
                {tabId: tab.id, color: color}
            );
        });
    },


    setText: function(win_id, text) {
        this.forAllTabs(win_id, function(tab) {
            chrome.browserAction.setBadgeText(
                {tabId: tab.id, text: text}
            );
        });
    },


    setIcon: function(win_id, icon) {
        this.forAllTabs(win_id, function(tab) {
                chrome.browserAction.setIcon(
                    {tabId: tab.id, path: icon}
                );
        });
    },


    set: function(win_id, details) {
        switch (details.status) {
        case "tag_wait":
            this.setBackgroundColor(win_id, [209, 211, 212,255]); // light gray
            break;

        case "loading":            
            this.setBackgroundColor(win_id, [250, 187, 24,255]); // yellow
            break;

        case "waiting":
            this.setBackgroundColor(win_id, [162, 208, 116,255]); // green
            break;

        case "playing":
            this.setBackgroundColor(win_id, [76, 196, 209,255]); // blue
            break;

        case "recording":
            this.setBackgroundColor(win_id, [241, 86, 76,255]); // red
            break;
        };

        this.setText(win_id, details.text.toString());
    },


    clearText: function(win_id) {
        this.setText(win_id,  "");
    }
};



======================================================================
FILE PATH: beforePlay.js
======================================================================
/*
Copyright © 1992-2021 Progress Software Corporation and/or one of its subsidiaries or affiliates. All rights reserved.
*/


function play() {
    var m = {
        source: args.source,
        name: args.name,
        bookmark_id: args.bookmark_id
    };
    var win_id = args.win_id;
    var showAgain = document.getElementById("checkbox").checked;
    opener.Storage.setBool("before-play-dialog", showAgain);
    window.opener.playMacro(m, win_id);
    window.close();
}

function cancel() {
    opener.Storage.setBool("before-play-dialog", document.getElementById("checkbox").checked);
    window.close();
}

function edit() {
    var m = {
        source: args.source,
        name: args.name,
        bookmark_id: args.bookmark_id
    };
    setTimeout(function () {window.opener.edit(m);}, 0);
    opener.Storage.setBool("before-play-dialog", document.getElementById("checkbox").checked);
    window.close();
}

window.addEventListener("load", function(evt) {
    if (args) {
        var x = document.getElementById("message").textContent;
        x = x.replace(/{{macroname}}/, args.name);
        document.getElementById("message").textContent = x;
    }
    document.getElementById("play-button").focus();
    document.getElementById("checkbox").checked = opener.Storage.getBool("before-play-dialog");
    
    // add DOM event handlers
    document.getElementById("play-button").addEventListener("click", play);
    // document.getElementById("edit-button").addEventListener("click", edit);
    document.getElementById("cancel-button").addEventListener("click", cancel);

    resizeToContent(window, document.getElementById('container'));
    // prevent right-click
    document.body.oncontextmenu = function(e) {
        e.preventDefault();
        return false;
    };
}, true);



======================================================================
FILE PATH: bg.js
======================================================================
/*
Copyright © 1992-2021 Progress Software Corporation and/or one of its subsidiaries or affiliates. All rights reserved.
*/

"use strict";
// old bookmarklet pattern

// function makeBookmarklet(name, content) {
//     var pattern = "(function() {"+
//         "try{"+
//         "var m64 = \"{{macro}}\", n = \"{{name}}\";"+
//         "if(!/Chrome\\/\\d+\\.\\d+\\.\\d+\\.\\d+/.test(navigator.userAgent)){"+
//         "alert('iMacros: The embedded macros work with iMacros for Chrome. Support for IE/Firefox is planned.');"+
//         "return;"+
//         "}"+
//         "if(!/^(?:chrome|https?|file)/.test(location)){"+
//         "alert('iMacros: To run a macro, you need to open a website first.');"+
//         "return;"+
//         "}"+
//         "var div = document.getElementById(\"imacros-bookmark-div\");"+
//         "if (!div){"+
//         "alert(\"Can not run macro, no iMacros div found\");"+
//         "return;"+
//         "}"+
//         "var ta = document.getElementById(\"imacros-macro-container\");"+
//         "ta.value = decodeURIComponent(atob(m64));"+
//         "div.setAttribute(\"name\", n);"+
//         "var evt = document.createEvent(\"Event\");"+
//         "evt.initEvent(\"iMacrosRunMacro\", true, true);"+
//         "div.dispatchEvent(evt);"+
//         "}catch(e){alert('Bookmarklet error: '+e.toString());}"+
//         "}) ();";

//     var macro_name = name || "Unnamed Macro", source = content;
//     macro_name = imns.escapeLine(macro_name);
//     pattern = pattern.replace("{{name}}", macro_name);
//     source = btoa(encodeURIComponent(source));
//     source = imns.escapeLine(source);
//     pattern = pattern.replace("{{macro}}", source);

//     var url = "javascript:" + pattern;

//     return url;
// }


// create bookmarklet of new type
function makeBookmarklet(name, code) {
    var pattern = "(function() {"+
        "try{"+
        "var e_m64 = \"{{macro}}\", n64 = \"{{name}}\";"+
        "if(!/^(?:chrome|https?|file)/.test(location)){"+
        "alert('iMacros: Open webpage to run a macro.');"+
        "return;"+
        "}"+
        "var macro = {};"+
        "macro.source = decodeURIComponent(atob(e_m64));"+
        "macro.name = decodeURIComponent(atob(n64));"+
        "var evt = document.createEvent(\"CustomEvent\");"+
        "evt.initCustomEvent(\"iMacrosRunMacro\", true, true, macro);"+
        "window.dispatchEvent(evt);"+
        "}catch(e){alert('iMacros Bookmarklet error: '+e.toString());}"+
        "}) ();";

    var macro_name = name || "Unnamed Macro", source = code;
    macro_name = btoa(encodeURIComponent(name));
    macro_name = imns.escapeLine(macro_name);
    pattern = pattern.replace("{{name}}", macro_name);
    source = btoa(encodeURIComponent(source));
    source = imns.escapeLine(source);
    pattern = pattern.replace("{{macro}}", source);

    var url = "javascript:" + pattern;

    return url;
}


function ensureBookmarkFolderCreated(parent_id, name) {
    return new Promise(function(resolve, reject) {
        chrome.bookmarks.getChildren( parent_id, function (result) {
            // find a bookmark with matching name
            for(var r of result) {
                if (r.title == name)
                    return resolve(r);
            }
            // otherwise create one
            chrome.bookmarks.create(
                {parentId: parent_id, title: name}, resolve
            );
        });
    });
}

function createBookmark(folder_id, title, url, bookmark_id, overwrite) {
    return new Promise(function(resolve, reject) {
        if (bookmark_id) {
            chrome.bookmarks.update(
                bookmark_id,
                {url: url, title: title},
                resolve
            );
            return;
        }

        if (overwrite) {
            reject(new Error("bg.save() - trying to overwrite "+title+
                             " while bokmark_id is not set"));
            return;
        }

        // TODO: ask if user wants to overwrite the macro
        // if (confirm())...

        // look for a macro with the same name
        // append (\d) to title if macro with the title already exists
        chrome.bookmarks.getChildren(folder_id, function (children) {
            var found = false, count = 0, name = title;
            for(;;) {
                for(var x of children) {
                    if (x.title == name && x.url) {
                        found = true; count++; break;
                    }
                }
                if (found) {
                    found = false;
                    if (/\.iim$/.test(title)) {
                        name = title.replace(/\.iim$/, "$'("+count+").iim");
                    } else {
                        name = title+"("+count+")";
                    }
                    continue;
                } else {
                    break;
                }
            }
            chrome.bookmarks.create(
                {
                    parentId: folder_id,
                    title: name,
                    url: url
                }, resolve);
        });
    });
}


function save_file(save_data, overwrite, callback) {
    var node = afio.openNode(save_data.file_id);
    var update_tree = true;

    if (!isMacroFile(save_data.name))
        save_data.name += ".iim";

    if (node.leafName != save_data.name) {
        node = node.parent;
        node.append(save_data.name);
    }

    node.exists().then(function(exists) {
        if (exists && !overwrite) {
            var yes = confirm("Are you sure you want to overwrite "+
                              node.path+"?");
            if (!yes)
                return;
        }

        update_tree = !exists;

        return afio.writeTextFile(node, save_data.source).then(function() {
            typeof (callback) == "function" && callback(save_data);
            if (!update_tree)
                return;
            for (var x in context) { // update all panels
                var panel = context[x].panelWindow;
                if (panel && !panel.closed) {
                    var doc = panel.frames["tree-iframe"].contentDocument;
                    doc.defaultView.location.reload();
                }
            }
        });
    }).catch(console.error.bind(console));
}



function save(save_data, overwrite, callback) {
    // TODO: for file version when file_id is not set "saveAs"
    // saves into file or bookmark
    if (save_data.file_id) {
        save_file(save_data, overwrite, callback);
        return;
    }

    chrome.bookmarks.getTree( function (tree) {
        var p_id = tree[0].children[0].id;
        ensureBookmarkFolderCreated(p_id, "iMacros").then(function(node) {
            var url = makeBookmarklet(save_data.name, save_data.source);
            var iMacrosDirId = node.id;
            if (overwrite && !save_data.bookmark_id) {
                // we should check if "name" exists and if it does then
                // find its bookmark_id
                chrome.bookmarks.getChildren(iMacrosDirId, function(ar) {
                    for (var x of ar) {
                        if (x.title == save_data.name) {
                            save_data.bookmark_id = x.id;
                            createBookmark(
                                iMacrosDirId, save_data.name, url,
                                save_data.bookmark_id,
                                overwrite
                            ).then(function() {
                                typeof(callback) == "function" && callback(save_data);
                            });
                            return;
                        }
                    };
                    // no macro was found so create a new one
                    createBookmark(
                        iMacrosDirId, save_data.name, url,
                        save_data.bookmark_id,
                        false
                    ).then(function() {
                        typeof(callback) == "function" &&
                            callback(save_data);
                    });
                });
            } else {
                createBookmark(
                    iMacrosDirId, save_data.name, url,
                    save_data.bookmark_id,
                    overwrite
                ).then(function() {
                    typeof(callback) == "function" &&
                        callback(save_data);
                });
            }
        });
    });
}


function edit(macro, overwrite) {
    var features = "titlebar=no,menubar=no,location=no,"+
        "resizable=yes,scrollbars=yes,status=no,"+
        "width=640,height=480";
    // var win = window.open("editor/simple_editor.html",
    //     null, features);
    // console.info("Edit macro: %O", macro);
    var win = window.open("editor/editor.html",
        null, features);

    win.args = {macro: macro, overwrite: overwrite};
}


function playMacro(macro, win_id) {
    if (context[win_id]) {
        getLimits().then(
            limits => context[win_id].mplayer.play(macro, limits)
        )
    } else {
        console.error("No context for windowId="+win_id);
    }
}

function dockPanel(win_id) {
    var panel = context[win_id].panelWindow;
    if (!panel || panel.closed) {
        clearInterval(context[win_id].dockInterval);
        return;
    }
    if (!Storage.getBool("dock-panel"))
        return;

    chrome.windows.get(win_id, function(w) {
	var new_x = w.left - panel.outerWidth;
	if (new_x < 0)
            new_x = 0;

	var updateInfo = {
            height: w.height,
	         width: Math.round(panel.outerWidth),
            left: new_x,
            top: w.top
	};

	chrome.windows.update(context[win_id].panelId, updateInfo);
    });
}

function openPanel(win_id) {
	// Exit if panel is already open
	var panel = context[win_id].panelWindow;
	if (panel && !panel.closed) {
		return;
	}

    chrome.windows.get(win_id, function(win) {
        var panelBox = Storage.getObject("panel-box");
        if (!panelBox) {
            panelBox = new Object();
            panelBox.width = 210;
            if (Storage.getBool("dock-panel"))
                panelBox.height = win.height;
            else
                panelBox.height = 600;
            panelBox.top = win.top;
            panelBox.left = win.left-panelBox.width;
            if (panelBox.left < 0)
                panelBox.left = 0;
        }

        var createData = {
            url: "panel.html", type: "popup",
            top: panelBox.top, left: panelBox.left,
            width: panelBox.width, height: panelBox.height
        };

        chrome.windows.create(createData, function(w) {
            context[win_id].panelId = w.id;
            context[win_id].dockInterval = setInterval(function() {
                dockPanel(win.id);
            }, 500);
        });
    });
}

// called from panel
// we use it to find and set win_id for that panel
// NOTE: unfortnunately, it seems there is no more straightforward way
// because on Windows chrome.windows.onCreated is fired too early for
// panel's DOM window be fully constructed
function onPanelLoaded(panel) {
    for (var win_id in context) {
        win_id = parseInt(win_id);
        if (!isNaN(win_id)) {
            var v = chrome.extension.getViews(
                {windowId: context[win_id].panelId}
            )[0];
            if (v == panel) {
                context[win_id].panelWindow = panel;
                return win_id;
            }
        }
    }

    console.error("Can not find windowId for panel %O", panel);
    throw new Error("Can not find windowId for panel!");
}


// browser action button onclick handler
chrome.browserAction.onClicked.addListener(function(tab) {
    var win_id = tab.windowId;
    if (Storage.getBool("show-updated-badge")) {
        doAfterUpdateAction();
        return;
    }

    if (!context[win_id]) {
        console.warn("No context for window, rebuilding: "+win_id);
        context.init(win_id);
    }

    var mplayer = context[win_id].mplayer;
    var recorder = context[win_id].recorder;

    if (context[win_id].state == "idle") {
        var panel = context[win_id].panelWindow;
        if (!panel || panel.closed) {
            openPanel(win_id);
        } else {
            panel.close();
            delete context[win_id].panelId;
            delete context[win_id].panelWindow;
        }
    } else if (context[win_id].state == "paused") {
        if (mplayer.paused) {
            mplayer.unpause();
        }
    } else {
        if (mplayer.playing) {
            mplayer.stop();
        } else if (recorder.recording) {
            recorder.stop();
            var recorded_macro = recorder.actions.join("\n");
            var macro = {source: recorded_macro, win_id: win_id,
                         name: "#Current.iim"};

            if (Storage.getChar("tree-type") == "files") {
                afio.isInstalled().then(function(installed) {
                    if (installed) {
                        afio.getDefaultDir("savepath").then(function(node) {
                            node.append("#Current.iim");
                            macro.file_id = node.path;
                            edit(macro, /* overwrite */ true);
                        }).catch(console.error.bind(console));
                    } else {            // no file access
                        edit(macro, true);
                    }
                }).catch(console.error.bind(console));
            } else {
                edit(macro, true);
            }
        }
    }
});


function addSampleBookmarkletMacro(name, parentId, content) {
    return new Promise(function(resolve, reject) {
        chrome.bookmarks.getChildren(parentId, function(a) {
            // we should check if "name" exists
            var id = null;
            for (var x of a) {
                if (x.title == name) {
                    // TODO: maybe we should ask user if he or she
                    // wants to override that sample macro?
                    // Now just overwrite it silently
                    id = x.id;
                    break;
                }
            }
            // no macro was found, create a new one
            createBookmark(
                parentId, name,
                makeBookmarklet(name, content),
                id || null,
                !!id
            ).then(resolve, reject);
        });
    });
}

function xhr(path, mimeType) {
    return new Promise((resolve, reject) => {
        let url = chrome.extension.getURL(path)
        let req = new XMLHttpRequest()
        req.overrideMimeType(mimeType)
        req.onreadystatechange = function() {
            if (req.readyState == 4) {
                resolve(req.response)
            }
        }
        req.onerror = reject
        req.open("GET", url, true)
        req.send(null)
    })
}

function getSample(name) {
    return xhr("samples/"+name, "text/plain;charset=utf-8")
        .then(response => ({
            name: name,
            content: response
        }))
}

function ensureDirectoryExists(node) {
    // a workaround for afio.exe bug on Windows - paths which end with "\"
    // are erroneously reported as non-existsent
    if (__is_windows() && node._path.endsWith("\\"))
        node._path = node._path.slice(0, -1);
    return node.exists().then(function(exists) {
        return exists ? Promise.resolve() :
            node.parent.exists().then(function(parent_exists) {
                return  parent_exists ? afio.makeDirectory(node) :
                    ensureDirectoryExists(node.parent);
            });
    });
}


function installSampleMacroFiles() {
    var names = [
        "ArchivePage.iim",
        "Eval.iim",
        "Extract.iim",
        "ExtractAndFill.iim",
        "ExtractRelative.iim",
        "ExtractTable.iim",
        "ExtractURL.iim",
        "FillForm-Events.iim",
        "FillForm-CssSelectors.iim",
        "FillForm-XPath.iim",
        "FillForm.iim",
        "Frame.iim",
        "Loop-Csv-2-Web.iim",
        "Open6Tabs.iim",
        "SaveAs.iim",
        "SlideShow.iim",
        "Stopwatch.iim",
        "TagPosition.iim",
        "Upload.iim"
    ]

    return afio.isInstalled().then(function(installed) {
        if (!installed) {
            return Promise.reject("afio is not installed!")
        } else {
            return afio.getDefaultDir("savepath")
        }
    }).then(function(node) {
        node.append("Demo-Chrome")
        return ensureDirectoryExists(node).then(function() {
            return names.map(getSample).reduce(function(seq, p) {
                return seq.then(function() {
                    return p
                }).then(m => {
                    let file = node.clone()
                    file.append(m.name)
                    return afio.writeTextFile(file, m.content)
                })
            }, Promise.resolve())
        });
    });
}

function installProfilerXsl() {
    return afio.getDefaultDir("downpath").then(function(node) {
        return getSample("Profiler.xsl").then(function(file) {
            node.append("Profiler.xsl");
            return afio.writeTextFile(node, file.content);
        });
    });
}

function installAddressCsv() {
    return afio.getDefaultDir("datapath").then(function(node) {
        return getSample("Address.csv").then(function(file) {
            node.append("Address.csv");
            return afio.writeTextFile(node, file.content);
        });
    });
}

function installSampleBookmarkletMacros() {
    var names = [
        "ArchivePage.iim",
        "Eval.iim",
        "Extract.iim",
        "ExtractAndFill.iim",
        "ExtractRelative.iim",
        "ExtractTable.iim",
        "ExtractURL.iim",
        "FillForm-XPath.iim",
        "FillForm-Events.iim",
        "FillForm-CssSelectors.iim",
        "FillForm.iim",
        "Frame.iim",
        "Open6Tabs.iim",
        "SaveAs.iim",
        "SlideShow.iim",
        "Stopwatch.iim",
        "TagPosition.iim",
        "Upload.iim"
    ];

    return new Promise(function(resolve, reject) {
        chrome.bookmarks.getTree(function(tree) {
            var panelId = tree[0].children[0].id
            ensureBookmarkFolderCreated(
                panelId, "iMacros"
            ).then(function(im) {
                return ensureBookmarkFolderCreated(im.id, "Demo-Chrome")
            }).then(function(node) {
                return names.map(getSample).reduce(function(seq, p) {
                    return seq.then(function() {
                        return p
                    }).then(macro => addSampleBookmarkletMacro(
                        macro.name, node.id, macro.content
                    ))
                }, Promise.resolve())
            }).then(resolve, reject);
        })
    })
}



// regexp to update bookmarked macros to newer version (e_m64)
var strre = "(?:[^\"\\\\]|\\\\[0btnvfr\"\'\\\\])+";
var bm_update_re = new RegExp('^javascript\\:\\(function\\(\\) '+
                              '\\{try\\{var ((?:e_)?m(?:64)?) = "('+strre+')"'+
                              ', (n(?:64)?) = "('+strre+')";'+
                             '.+;evt\.initEvent');
// recursive function which walks through bookmarks tree
function updateBookmarksTree(tree) {
    if (!tree)
        return;

    tree.forEach(function(x) {
        if (x.url) {
            var match = bm_update_re.exec(x.url);
            if (match) {
                var source, name;
                switch(match[1]) {
                case "m":
                    source = decodeURIComponent(imns.unwrap(match[2]));
                    break;
                case "m64": case "e_m64":
                    source = decodeURIComponent(atob(match[2]));
                    break;
                }
                if (match[3] == "n") {
                    name = decodeURIComponent(match[4]);
                } else if (match[3] == "n64") {
                    name = decodeURIComponent(atob(match[4]));
                }
                chrome.bookmarks.update(
                    x.id, {url: makeBookmarklet(name, source)}
                );
            }
        } else {
            updateBookmarksTree(x.children);
        }
    });
}


function doAfterUpdateAction() {
    Storage.setBool("show-updated-badge", false);
    chrome.windows.getAll({populate: false}, function(ws) {
        ws.forEach(function(win) {
            badge.clearText(win.id);
        });
    });
    // open update page
    link(getRedirFromString("updated"));
    var yes = confirm("Do you want to install the latest versions of the demo macros (Old sample macros will be overwritten)?");
    if (!yes)
        return;
    // update bookmarked macros for newer version if any
    chrome.bookmarks.getTree( function (tree) {
        updateBookmarksTree(tree);
    });
    installSampleBookmarkletMacros().then(function() {
        return afio.isInstalled().then(function(installed) {
            return installed ?
                installSampleMacroFiles()
                .then(installAddressCsv)
                .then(installProfilerXsl)
                : Promise.resolve();
        });
    }).catch(console.error.bind(console));
}

function onUpdate() {
    setDefaults();
    Storage.setBool("show-updated-badge", true);
    chrome.windows.getAll({populate: false}, function(ws) {
        ws.forEach(function(win) {
            badge.setText(win.id, "New");
        });
    });
}

function setDefaults() {
    // set some default parameters
    let default_settings = {
        "record-mode": "conventional",
        "recording-prefer-id": true,
        "recording-prefer-css-selectors": false,
        "before-play-dialog": true,
        "dock-panel": false,
        "default-dirs-set": false,
        "profiler-enabled": false,
        "replaying-delay": 0
    };
    for (let pref in default_settings) {
        if (!Storage.isSet(pref))
            switch(typeof default_settings[pref]) {
            case "string":
                Storage.setChar(pref, default_settings[pref]);
                break;
            case "boolean":
                Storage.setBool(pref, default_settings[pref]);
                break;
            case "number":
                Storage.setNumber(pref, default_settings[pref]);
                break;
            }
    }
}

window.addEventListener("load", function (event) {
    // initialize context
    // chrome.windows.getLastFocused(function (w) {
    chrome.windows.getCurrent(function (w) {
        context.init(w.id);
    });

    // listen to run-macro command from content script
    communicator.registerHandler("run-macro", function (data, tab_id) {
        chrome.tabs.get(tab_id, function(t) {
            var w_id = t.windowId;
            if (!context[w_id]) {
                console.error("No context for window "+w_id);
                return;
            }
            if (Storage.getBool("before-play-dialog")) {
                var features = "titlebar=no,menubar=no,location=no,"+
                    "resizable=yes,scrollbars=yes,status=no,"+
                    "width=400, height=140";
                var win = window.open("beforePlay.html", null, features);
                win.args = data;
                win.args.win_id = w_id;
            } else {
                getLimits().then(
                    limits => asyncRun(function () {
                        context[w_id].mplayer.play(data, limits);
                    })
                )
            }
        });
    });

    // check if it is the first run
    if (!Storage.getBool("already-installed")) {
        Storage.setBool("already-installed", true);
        setDefaults();
        // get version number
        Storage.setChar("version", chrome.runtime.getManifest().version);
        installSampleBookmarkletMacros().catch(console.error.bind(console));
        this.setDefaults();
        // open welcome page
        chrome.tabs.create({
            url: getRedirFromString("welcome")
        }, function() {});
    } else {
        var version = chrome.runtime.getManifest().version;
        // check if macro was updated
        if (version != Storage.getChar("version")) {
            Storage.setChar("version", version);
            onUpdate();
        }
    }

    // set default directories
    if (!Storage.getBool("default-dirs-set")) {
        afio.isInstalled().then(function(installed) {
            if (!installed)
                return;
            var dirs = ["datapath", "savepath", "downpath"];
            return dirs.reduce(function(seq, d) {
                return seq.then(function() {
                    return afio.getDefaultDir(d).then(function(node) {
                        Storage.setChar("def"+d, node.path);
                        return ensureDirectoryExists(node);
                    });
                });
            }, Promise.resolve()).then(installSampleMacroFiles)
                .then(installAddressCsv)
                .then(installProfilerXsl)
                .then(function() {
                    Storage.setBool("default-dirs-set", true);
                });
        }).catch(console.error.bind(console));
    }

    // TODO: check somehow if we need to start SI server
    // if (start_SI_server)
    nm_connector.startServer();

    // Set afio-installed
    afio.isInstalled().then(function(installed) {
        Storage.setBool("afio-installed", installed);
    });

    // listen to restart-server command from content script
    // (fires after t.html?pipe=<pipe> page is loaded)
    chrome.extension.onRequest.addListener(
        function (req, sender, sendResponse) {
            // clean up request
            if (req.command == "restart-server") {
                // TODO: avoid possible double-restart somehow
                sendResponse({status: "OK"});
                if (nm_connector.currentPipe != req.pipe) {
                    nm_connector.stopServer();
                    if (Storage.getBool("debug"))
                        console.info("Restarting server, pipe="+req.pipe);
                    nm_connector.startServer(req.pipe);
                    nm_connector.currentPipe = req.pipe;
                }
            }
        }
    );

}, true);


function addTab(url, win_id) {
    var args = {url: url};
    if (win_id)
        args.windowId = parseInt(win_id);

    chrome.tabs.create(args, function (tab) {});
}


function showInfo(args) {
    var win_id = args.win_id;
    context[win_id].info_args = args;
    var panel = context[win_id].panelWindow;
    if (panel && !panel.closed) {
        panel.showInfo(args);
    } else {
        var opt = {
            type: "basic",
            title: (args.errorCode == 1 ? "iMacros" : "iMacros Error"),
            message: args.message,
            iconUrl: "skin/logo48.png",
            isClickable: true

            // NOTE: buttons looks really weird so they commented out
            // , buttons: [
            //     {title: "Edit", iconUrl: "skin/edit.png"},
            //     {title: "Help", iconUrl: "skin/help.png"}
            // ]
        };
        chrome.notifications.create(win_id.toString(), opt, function(n_id) {
            // not much to do here
        });

        chrome.notifications.onClicked.addListener(function(n_id) {
            var w_id = parseInt(n_id);
            if (isNaN(w_id) || !context[w_id] || !context[w_id].info_args)
                return;
            var info = context[w_id].info_args;
            if (info.errorCode == 1)
                return;    // we have plain Info message; nothing to do

            // for error messages since we have only one 'button'
            // we most probably want look at macro code,
            edit(info.macro, true);
        });
    }
}

//制限解除
function getLimits() {
    let defaultLimits = {
        maxVariables: 99999,
        maxCSVRows: 99999,
        maxCSVCols: 99999,
        maxMacroLen: 99999,
        maxIterations: 99999
    }

    return afio.isInstalled().then(
        installed => {
            if (installed) {
                return afio.queryLimits().catch(() => defaultLimits)
            } else {
                return defaultLimits
            }
        })
}

function isPersonalVersion() {
    return getLimits()
    //制限解除
        .then(limits =>
              Object.values(limits).every(x => x == "unlimited")
        //return Promise.resolve(true);
             )
}


window.addEventListener("unload", function(event) {
    nm_connector.stopServer();
});

// remove panel when its parent window is closed
chrome.windows.onRemoved.addListener(function(win_id) {
    if (!context[win_id])
        return;
    var panel = context[win_id].panelWindow;
    if (panel && !panel.closed) {
        panel.close();
    }
});



======================================================================
FILE PATH: browse.js
======================================================================
/*
Copyright © 1992-2021 Progress Software Corporation and/or one of its subsidiaries or affiliates. All rights reserved.
*/

function cancel() {
    window.close();
}


function choose() {
    var doc = window.frames["tree-iframe"].contentDocument;
    var path = doc.getElementById("path").value;
    if (!path)
        return;
    opener.savePath(args.which, path);
    window.close();
}

window.addEventListener("load", function() {
    document.getElementById("button-ok").addEventListener("click", choose);
    document.getElementById("button-cancel").addEventListener("click", cancel);
    // prevent right-click
    document.body.oncontextmenu = function(e) {
        e.preventDefault();
        return false;
    };
    asyncRun(function() {
        // resizeToContent(window, document.getElementById("container"));
        window.resizeTo(260, window.outerHeight+60);
        window.moveTo(200, 200);
    });
});



======================================================================
FILE PATH: communicator.js
======================================================================
/*
Copyright © 1992-2021 Progress Software Corporation and/or one of its subsidiaries or affiliates. All rights reserved.
*/


// incapsulates all content scripts-extensions communications
function Communicator() {
    this.handlers = new Object();
    this.addListeners();
}

// add listener for extension events
Communicator.prototype.addListeners = function() {
    // listen to requests from content-scripts
    chrome.extension.onRequest.addListener(
        function(msg, sender, callback) {
            if (!sender.tab)
                return;
            communicator.handleMessage(msg, sender.tab.id, callback);
        }
    );
    
    chrome.windows.onRemoved.addListener(function(win_id) {
        // remove all handlers bind to the window
        for (var topic in communicator.handlers) {
            var len = communicator.handlers[topic].length, i;
            var junk = new Array();
            for (i = 0; i < len; i++) {
                if (communicator.handlers[topic][i].win_id == win_id) {
                    junk.push(communicator.handlers[topic][i].handler);
                }
            }
            for (i = 0; i < junk.length; i++) {
                communicator.unregisterHandler(topic, junk[i]);
            }
        }
    });
};



// register handlers for specific content script messages
Communicator.prototype.registerHandler = function(topic, handler, win_id) {
    if (!(topic in this.handlers))
        this.handlers[topic] = new Array();
    this.handlers[topic].push({handler: handler, win_id: win_id});
};

Communicator.prototype.unregisterHandler = function(topic, handler) {
    if (!(topic in this.handlers))
        return;
    for (var i = 0; i < this.handlers[topic].length; i++) {
        if (this.handlers[topic][i].handler == handler) {
            this.handlers[topic].splice(i, 1);
            break;
        }
    }
};

// handle message from script
Communicator.prototype.handleMessage = function(msg, tab_id, callback) {
    if (msg.topic in this.handlers) {
        chrome.tabs.get(tab_id, function(tab) {
            if (!tab)
                return;
            communicator.handlers[msg.topic].forEach( function(x) {
                if (x.win_id && x.win_id == tab.windowId) {
                    // if win_id is set then call callback only if
                    // it is set for the win_id the message came from
                    x.handler(msg.data, tab_id, callback);
                    // assume we have only one handler per window
                    // and callback is called inside the handler
                    return;
                } else {
                    // browser-wide message handler
                    // currently we have only run-macro topic for
                    // ookmarklet macros
                    x.handler(msg.data, tab_id);
                    if (callback)
                        callback();
                    return;
                }
            });
        });
    } else {
        console.warn("Communicator: unknown topic "+msg.topic);
    }
};


// send message to specific tab
Communicator.prototype.postMessage =
    function(topic, data, tab_id, callback, frame)
{
    chrome.tabs.sendRequest(
        tab_id,
        {topic: topic, data: data, _frame: frame},
        callback
    );
};

Communicator.prototype.sendMessage =
    function(topic, data, tab_id, frame)
{
    return new Promise(function(resolve, reject) {
        chrome.tabs.sendMessage(
            tab_id,
            {topic: topic, data: data, _frame: frame},
            resolve
        );
    });
};

// broadcast message
Communicator.prototype.broadcastMessage = function(topic, data, win_id) {
    if (win_id) {
        chrome.tabs.getAllInWindow(win_id, function(tabs) {
            if (!tabs)
                return;
            tabs.forEach( function(tab) {
                chrome.tabs.sendRequest(tab.id, {topic: topic, data: data},
                                        function () {});
            });
        });
    } else {
        chrome.windows.getLastFocused(function (win) {
            win.tabs.forEach( function(tab) {
                chrome.tabs.sendRequest(tab.id, {topic: topic, data: data},
                                        function () {});
            });
        });
    }
};


var communicator = new Communicator();



======================================================================
FILE PATH: context.js
======================================================================
/*
Copyright © 1992-2021 Progress Software Corporation and/or one of its subsidiaries or affiliates. All rights reserved.
*/

// Context to store browser window-specific information

var context = {
    init: function(win_id) {
        this.attachListeners();
        context[win_id] = new Object();
        context[win_id].mplayer = new MacroPlayer(win_id);
        context[win_id].recorder = new Recorder(win_id);
        context[win_id].state = "idle";
    },

    updateState: function(win_id, state) {
                // set browser action icon 
        switch(state) {
        case "playing": case "recording":
            badge.setIcon(win_id, "skin/stop.png");
            break;
        case "paused":
            // TODO: switch to tab where replaying was paused
            // after unpause
            badge.setIcon(win_id, "skin/play.png");
            break;
        case "idle":
            badge.setIcon(win_id, "skin/logo19.png");
            if (Storage.getBool("show-updated-badge")) {
                badge.setText(win_id, "New");
            } else {
                badge.clearText(win_id);
            } 
            break;
        }
        // update panel
        var panel = this[win_id].panelWindow;
        if (panel && !panel.closed)
            panel.updatePanel(state);
        this[win_id].state = state;
    },
    
    onCreated: function (w) {
        if (w.type != "normal")
            return;
        
        context[w.id] = new Object();
        context[w.id].mplayer = new MacroPlayer(w.id);
        context[w.id].recorder = new Recorder(w.id);
        this.updateState(w.id, "idle");
    },

    onRemoved: function (id) {
        if (context[id]) {
            var t;
            if (t = context[id].mplayer) {
                t.terminate();
                delete context[id].mplayer;
            }
            if (t = context[id].recorder) {
                if (t.recording)
                    t.stop();
                delete context[id].recorder;
            }
            if (context[id].dockInterval) {
                clearInterval(context[id].dockInterval);
                context[id].dockInterval = null;
            }
            delete context[id];
        }
    },

    onTabUpdated: function(tab_id, changeInfo, tab) {
        if (!context[tab.windowId])
            return;
        // set icon after tab is updated
        switch (context[tab.windowId].state) {
        case "playing": case "recording":
            badge.setIcon(tab.windowId, "skin/stop.png");
            break;
        case "paused":
            badge.setIcon(tab.windowId, "skin/play.png");
            break;
        case "idle":
            badge.setIcon(tab.windowId, "skin/logo19.png");
            if (Storage.getBool("show-updated-badge")) {
                badge.setText(tab.windowId, "New");
            } else {
                badge.clearText(tab.windowId);
            }
            break;
        }
    },
    
    attachListeners: function() {
        chrome.windows.onCreated.addListener(
            context.onCreated.bind(context)
        );
        chrome.windows.onRemoved.addListener(
            context.onRemoved.bind(context)
        );
        chrome.tabs.onUpdated.addListener(
            context.onTabUpdated.bind(context)
        );
    },

    registerDfHandler: function(win_id) {
        for (var i = 0; i < this.df_handlers.length; i++)
            if (this.df_handlers.indexOf(win_id) != -1)
                return;
        this.df_handlers.push(win_id);
    },

    unregisterDfHandler: function(win_id) {
        var idx = this.df_handlers.indexOf(win_id);
        if (idx != -1)
            this.df_handlers.splice(idx, 1);
    },
    
    on_df: function(dl, suggest) {
        for (var i = 0; i < this.df_handlers.length; i++) {
            var mplayer = context[this.df_handlers[i]].mplayer;
            if (mplayer && mplayer.onDeterminingFilename(dl, suggest))
                return;
        }
    }

};


// This event has a weird condition that an extension can register only
// one listener. So it's done here, at the moment of extension initialization
context.df_handlers = new Array();
chrome.downloads.onDeterminingFilename.addListener(
    context.on_df.bind(context)
);



======================================================================
FILE PATH: errorLogger.js
======================================================================
/*
Copyright © 1992-2021 Progress Software Corporation and/or one of its subsidiaries or affiliates. All rights reserved.
*/

/**
 * Comprehensive Error Logging System for iMacros Chrome Extension
 *
 * This module provides centralized error handling and logging capabilities:
 * - Captures all JavaScript errors with file name, line number, and stack trace
 * - Records errors to localStorage for persistence across sessions
 * - Provides error retrieval and analysis functions
 * - Supports different error severity levels (ERROR, WARNING, INFO)
 * - Includes automatic error reporting to console with detailed context
 */

(function (window) {
    "use strict";

    // Error severity levels
    const ErrorLevel = {
        ERROR: "ERROR",
        WARNING: "WARNING",
        INFO: "INFO",
        CRITICAL: "CRITICAL"
    };

    // Maximum number of errors to store
    const MAX_ERROR_LOG_SIZE = 1000;

    // Storage key for error logs
    const ERROR_LOG_KEY = "imacros_error_log";
    const ERROR_STATS_KEY = "imacros_error_stats";

    // Error codes (documented in ERROR_LOGGING_AND_TROUBLESHOOTING.md)
    const ErrorCodes = {
        UNKNOWN: "IMX-0000",
        UNCAUGHT: "IMX-1001",
        UNHANDLED_PROMISE: "IMX-1002",
        CONSOLE_ERROR: "IMX-1003",
        CHROME_API: "IMX-2001",
        STORAGE_FAILURE: "IMX-3001",
        MANUAL: "IMX-9000"
    };

    class ErrorLogger {
        constructor() {
            this.errors = [];
            this.stats = {
                totalErrors: 0,
                totalWarnings: 0,
                totalInfo: 0,
                totalCritical: 0,
                sessionStart: new Date().toISOString()
            };

            // In MV3 service worker, localStorage polyfill initializes asynchronously
            // Wait for initialization if the promise is available, otherwise load immediately
            if (typeof globalThis !== 'undefined' && globalThis.localStorageInitPromise) {
                // Defer loading from storage until initialization completes
                globalThis.localStorageInitPromise.then(() => {
                    this.loadFromStorage();
                }).catch(err => {
                    console.warn('[iMacros] Failed to wait for localStorage init, loading anyway:', err);
                    this.loadFromStorage();
                });
            } else {
                // Standard context (content script, popup, etc.) - load immediately
                this.loadFromStorage();
            }

            this.setupGlobalHandlers();
        }

        /**
         * Setup global error handlers to catch all uncaught errors
         */
        setupGlobalHandlers() {
            // Catch uncaught errors in the main thread, including resource load failures
            window.addEventListener('error', (event) => {
                // Ignore benign ResizeObserver errors commonly seen in modern web apps
                if (event.message && (
                    event.message.includes('ResizeObserver loop completed with undelivered notifications') ||
                    event.message.includes('ResizeObserver loop limit exceeded')
                )) {
                    return false;
                }

                // Handle resource loading errors where event.error is not populated
                if (event.target && event.target !== window && !event.error) {
                    const target = event.target;
                    const url = target.src || target.href || target.currentSrc || "unknown";
                    const tag = target.tagName || "unknown";

                    // Ignore benign resource load failures for specific tags
                    if (tag === 'INCLUDE-FRAGMENT') {
                        return false;
                    }

                    const filename = this.extractResourceFilename(url);

                    this.logError({
                        level: ErrorLevel.ERROR,
                        message: `Resource load failure (${tag}) ${url}`,
                        code: ErrorCodes.UNCAUGHT,
                        filename: filename || "unknown",
                        lineno: 0,
                        colno: 0,
                        stack: "Resource failed to load",
                        timestamp: new Date().toISOString(),
                        type: "ResourceError",
                        context: { tag, url }
                    });
                    return false;
                }

                this.logError({
                    level: ErrorLevel.ERROR,
                    message: event.message || "Unknown error",
                    code: ErrorCodes.UNCAUGHT,
                    filename: event.filename || "unknown",
                    lineno: event.lineno || 0,
                    colno: event.colno || 0,
                    stack: event.error ? event.error.stack : "No stack trace available",
                    timestamp: new Date().toISOString(),
                    type: "UncaughtError"
                });
                return false; // Allow default error handling
            }, true);

            // Catch unhandled promise rejections
            window.addEventListener('unhandledrejection', (event) => {
                const reason = event.reason;
                const stack = reason && reason.stack ? reason.stack : "No stack trace available";
                const caller = this.extractCallerFromStack(stack, 0);

                // Safely convert reason to string, avoiding JSON.stringify errors
                let message;
                if (reason && reason.message) {
                    message = reason.message;
                } else if (typeof reason === 'string') {
                    message = reason;
                } else {
                    try {
                        message = JSON.stringify(reason);
                    } catch (e) {
                        // Fallback for circular references or non-serializable objects
                        message = String(reason);
                    }
                }

                this.logError({
                    level: ErrorLevel.ERROR,
                    message: "Unhandled Promise Rejection: " + message,
                    code: ErrorCodes.UNHANDLED_PROMISE,
                    filename: caller.filename,
                    lineno: caller.lineno,
                    colno: 0,
                    stack: stack,
                    timestamp: new Date().toISOString(),
                    type: "UnhandledPromiseRejection"
                });
            });

            // Monitor console.error calls
            const originalConsoleError = console.error;
            const self = this;
            console.error = (...args) => {
                // Don't re-log if this is already an ErrorLogger formatted message
                if (typeof args[0] === 'string' && args[0].indexOf('[iMacros ') === 0) {
                    return originalConsoleError.apply(console, args);
                }

                const message = args.map(arg => {
                    if (typeof arg === 'object') {
                        try {
                            return JSON.stringify(arg);
                        } catch (e) {
                            return String(arg);
                        }
                    }
                    return String(arg);
                }).join(' ');

                const stack = new Error().stack;
                const caller = self.extractCallerFromStack(stack, 1);

                self.logError({
                    level: ErrorLevel.WARNING,
                    message: "Console Error: " + message,
                    code: ErrorCodes.CONSOLE_ERROR,
                    filename: caller.filename,
                    lineno: caller.lineno,
                    colno: 0,
                    stack: stack,
                    timestamp: new Date().toISOString(),
                    type: "ConsoleError"
                });

                // Call original console.error
                originalConsoleError.apply(console, args);
            };

            // Store reference for use in outputToConsole
            this.originalConsoleError = originalConsoleError;
        }

        /**
         * Extract filename from stack trace
         * Handles multiple browser formats:
         * - Chrome: "at functionName (http://url/file.js:10:5)"
         * - Firefox: "functionName@http://url/file.js:10:5"
         * - Edge: Similar to Chrome
         */
        extractFilenameFromStack(stack) {
            if (!stack) return "unknown";

            // Try Chrome/Edge format first: at ... (url:line:col) or at url:line:col
            let matches = stack.match(/(?:at\s+)?(?:.*?\s+)?\(?(.+?):(\d+):(\d+)\)?/);

            // Try Firefox format: func@url:line:col
            if (!matches) {
                matches = stack.match(/(.+?)@(.+?):(\d+):(\d+)/);
                if (matches && matches[2]) {
                    const fullPath = matches[2];
                    return fullPath.split('/').pop().split('\\').pop();
                }
            }

            if (matches && matches[1]) {
                const fullPath = matches[1];
                // Extract just the filename from URL or file path
                return fullPath.split('/').pop().split('\\').pop();
            }

            return "unknown";
        }

        /**
         * Extract line number from stack trace
         * Handles multiple browser formats
         */
        extractLineNumberFromStack(stack) {
            if (!stack) return 0;

            // Try Chrome/Edge format first
            let matches = stack.match(/(?:at\s+)?(?:.*?\s+)?\(?(.+?):(\d+):(\d+)\)?/);

            // Try Firefox format: func@url:line:col
            if (!matches) {
                matches = stack.match(/(.+?)@(.+?):(\d+):(\d+)/);
                if (matches && matches[3]) {
                    return parseInt(matches[3], 10);
                }
            }

            if (matches && matches[2]) {
                return parseInt(matches[2], 10);
            }

            return 0;
        }

        /**
         * Extract caller information from stack trace
         * Skips the first frame (which is the current function) and returns the caller
         * @param {number} skipFrames - Number of frames to skip (default: 1)
         */
        extractCallerFromStack(stack, skipFrames = 1) {
            if (!stack) return { filename: "unknown", lineno: 0 };

            const lines = stack.split('\n');
            // Skip the Error line and the requested number of frames
            const targetLine = lines[skipFrames + 1];

            if (!targetLine) {
                return { filename: "unknown", lineno: 0 };
            }

            // Try Chrome/Edge format
            let matches = targetLine.match(/(?:at\s+)?(?:.*?\s+)?\(?(.+?):(\d+):(\d+)\)?/);

            // Try Firefox format
            if (!matches) {
                matches = targetLine.match(/(.+?)@(.+?):(\d+):(\d+)/);
                if (matches && matches[2] && matches[3]) {
                    const fullPath = matches[2];
                    const filename = fullPath.split('/').pop().split('\\').pop();
                    return { filename: filename, lineno: parseInt(matches[3], 10) };
                }
            }

            if (matches && matches[1] && matches[2]) {
                const fullPath = matches[1];
                const filename = fullPath.split('/').pop().split('\\').pop();
                return { filename: filename, lineno: parseInt(matches[2], 10) };
            }

            return { filename: "unknown", lineno: 0 };
        }

        /**
         * Log an error with full context
         * @param {Object} errorInfo - Error information object
         */
        logError(errorInfo) {
            const enrichedError = {
                id: Date.now() + "_" + Math.random().toString(36).substr(2, 9),
                level: errorInfo.level || ErrorLevel.ERROR,
                message: errorInfo.message,
                code: errorInfo.code || ErrorCodes.UNKNOWN,
                filename: errorInfo.filename || "unknown",
                lineno: errorInfo.lineno || 0,
                colno: errorInfo.colno || 0,
                stack: errorInfo.stack || this.captureStackTrace(),
                timestamp: errorInfo.timestamp || new Date().toISOString(),
                type: errorInfo.type || "ManualLog",
                context: errorInfo.context || {},
                userAgent: navigator.userAgent,
                url: window.location ? window.location.href : "unknown"
            };

            // Add to in-memory log
            this.errors.push(enrichedError);

            // Update statistics
            this.updateStats(enrichedError.level);

            // Trim log if too large
            if (this.errors.length > MAX_ERROR_LOG_SIZE) {
                this.errors = this.errors.slice(-MAX_ERROR_LOG_SIZE);
            }

            // Save to localStorage
            this.saveToStorage();

            // Output to console with formatting
            this.outputToConsole(enrichedError);

            return enrichedError;
        }

        /**
         * Capture current stack trace
         */
        captureStackTrace() {
            try {
                throw new Error();
            } catch (e) {
                return e.stack || "No stack trace available";
            }
        }

        /**
         * Update error statistics
         */
        updateStats(level) {
            switch (level) {
                case ErrorLevel.ERROR:
                    this.stats.totalErrors++;
                    break;
                case ErrorLevel.WARNING:
                    this.stats.totalWarnings++;
                    break;
                case ErrorLevel.INFO:
                    this.stats.totalInfo++;
                    break;
                case ErrorLevel.CRITICAL:
                    this.stats.totalCritical++;
                    break;
            }
        }

        /**
         * Output error to console with formatting
         * Uses original console methods to avoid recursive logging
         */
        outputToConsole(errorInfo) {
            const prefix = `[iMacros ${errorInfo.level}]`;
            const codeLabel = errorInfo.code ? ` ${errorInfo.code}` : "";
            const location = `${errorInfo.filename}:${errorInfo.lineno}:${errorInfo.colno}`;
            const fullMessage = `${prefix}${codeLabel} ${errorInfo.message}\n   at ${location}\n   ${errorInfo.timestamp}`;

            // Use original console methods to avoid triggering the wrapped console.error
            // which would cause recursive logging
            switch (errorInfo.level) {
                case ErrorLevel.CRITICAL:
                case ErrorLevel.ERROR:
                    this.originalConsoleError.call(console, fullMessage);
                    if (errorInfo.stack) {
                        this.originalConsoleError.call(console, "Stack trace:", errorInfo.stack);
                    }
                    break;
                case ErrorLevel.WARNING:
                    console.warn(fullMessage);
                    break;
                case ErrorLevel.INFO:
                    console.info(fullMessage);
                    break;
            }

            if (errorInfo.context && Object.keys(errorInfo.context).length > 0) {
                console.log("Context:", errorInfo.context);
            }
        }

        /**
         * Wrap a function with error handling
         * @param {Function} fn - Function to wrap
         * @param {String} fnName - Function name for logging
         * @param {String} filename - Source filename
         * @returns {Function} - Wrapped function
         */
        wrapFunction(fn, fnName, filename) {
            const self = this;
            return function (...args) {
                try {
                    return fn.apply(this, args);
                } catch (error) {
                    self.logError({
                        level: ErrorLevel.ERROR,
                        message: `Error in ${fnName}: ${error.message}`,
                        filename: filename || "unknown",
                        lineno: 0,
                        colno: 0,
                        stack: error.stack,
                        type: "CaughtError",
                        context: {
                            functionName: fnName,
                            arguments: args
                        }
                    });
                    throw error; // Re-throw to maintain original behavior
                }
            };
        }

        /**
         * Wrap an async function with error handling
         * @param {Function} fn - Async function to wrap
         * @param {String} fnName - Function name for logging
         * @param {String} filename - Source filename
         * @returns {Function} - Wrapped async function
         */
        wrapAsyncFunction(fn, fnName, filename) {
            const self = this;
            return async function (...args) {
                try {
                    return await fn.apply(this, args);
                } catch (error) {
                    self.logError({
                        level: ErrorLevel.ERROR,
                        message: `Error in async ${fnName}: ${error.message}`,
                        filename: filename || "unknown",
                        lineno: 0,
                        colno: 0,
                        stack: error.stack,
                        type: "AsyncCaughtError",
                        context: {
                            functionName: fnName,
                            arguments: args
                        }
                    });
                    throw error; // Re-throw to maintain original behavior
                }
            };
        }

        /**
         * Save error log to localStorage
         */
        saveToStorage() {
            try {
                // Store only the most recent errors
                const recentErrors = this.errors.slice(-MAX_ERROR_LOG_SIZE);
                localStorage.setItem(ERROR_LOG_KEY, JSON.stringify(recentErrors));
                localStorage.setItem(ERROR_STATS_KEY, JSON.stringify(this.stats));
            } catch (e) {
                // If localStorage is full or unavailable, emit an explicit warning with a code
                console.warn(`[iMacros WARNING] ${ErrorCodes.STORAGE_FAILURE} Failed to save error log to localStorage:`, e);
            }
        }

        /**
         * Extract a concise filename/identifier from a resource URL.
         * - Strips query/hash for network URLs
         * - Handles data: URIs by returning the mime type or "data"
         * - Safely returns "unknown" for unparsable values
         */
        extractResourceFilename(url) {
            if (!url || url === "unknown") return "unknown";

            // Handle data URIs separately to avoid logging long payloads
            if (url.startsWith("data:")) {
                const meta = url.slice(5, url.indexOf(',') === -1 ? undefined : url.indexOf(','));
                const mime = meta.split(';')[0];
                return mime || "data";
            }

            try {
                const parsed = new URL(url, window.location && window.location.href ? window.location.href : undefined);
                const pathname = parsed.pathname || "";
                const cleanPath = pathname.split('?')[0].split('#')[0];
                const filename = cleanPath.split('/').pop().split('\\').pop();
                if (filename) {
                    return filename;
                }
            } catch (e) {
                // fall through to manual parsing
            }

            // Fallback: manually strip query/hash and extract last segment
            const withoutFragments = url.split('#')[0].split('?')[0];
            const filename = withoutFragments.split('/').pop().split('\\').pop();
            return filename || "unknown";
        }

        /**
         * Load error log from localStorage
         * Merges stored errors with any errors captured before initialization
         */
        loadFromStorage() {
            try {
                const storedErrors = localStorage.getItem(ERROR_LOG_KEY);
                const storedStats = localStorage.getItem(ERROR_STATS_KEY);

                // Preserve errors that were logged before storage initialization completed
                // This is critical in MV3 service workers where startup errors may be captured
                // before the localStorage polyfill cache is populated from chrome.storage.local
                const existingErrors = [...this.errors];

                if (storedErrors) {
                    const loadedErrors = JSON.parse(storedErrors);
                    // Merge: stored errors first, then any new errors captured during initialization
                    this.errors = [...loadedErrors, ...existingErrors];

                    // Trim if the combined log exceeds size limit
                    if (this.errors.length > MAX_ERROR_LOG_SIZE) {
                        this.errors = this.errors.slice(-MAX_ERROR_LOG_SIZE);
                    }
                } else if (existingErrors.length > 0) {
                    // No stored errors, but we have startup errors - keep them
                    this.errors = existingErrors;
                }

                if (storedStats) {
                    const loadedStats = JSON.parse(storedStats);
                    // Merge stats: add counts from errors captured during initialization
                    this.stats = {
                        totalErrors: loadedStats.totalErrors + (this.stats.totalErrors || 0),
                        totalWarnings: loadedStats.totalWarnings + (this.stats.totalWarnings || 0),
                        totalInfo: loadedStats.totalInfo + (this.stats.totalInfo || 0),
                        totalCritical: loadedStats.totalCritical + (this.stats.totalCritical || 0),
                        sessionStart: loadedStats.sessionStart || new Date().toISOString()
                    };
                } else {
                    // Initialize stats if not found (keep any counts from startup errors)
                    this.stats.sessionStart = this.stats.sessionStart || new Date().toISOString();
                }

                if (existingErrors.length > 0) {
                    console.log(`[iMacros] Preserved ${existingErrors.length} startup error(s) during storage load`);
                }
            } catch (e) {
                console.warn(`[iMacros WARNING] ${ErrorCodes.STORAGE_FAILURE} Failed to load error log from localStorage:`, e);
                // On parse failure, keep any existing errors rather than resetting
                // Only reset stats if we can't parse them
                if (!this.stats.sessionStart) {
                    this.stats = {
                        totalErrors: this.stats.totalErrors || 0,
                        totalWarnings: this.stats.totalWarnings || 0,
                        totalInfo: this.stats.totalInfo || 0,
                        totalCritical: this.stats.totalCritical || 0,
                        sessionStart: new Date().toISOString()
                    };
                }
            }
        }

        /**
         * Get all errors
         * @returns {Array} Array of error objects
         */
        getAllErrors() {
            return [...this.errors];
        }

        /**
         * Get errors by level
         * @param {String} level - Error level to filter by
         * @returns {Array} Filtered array of error objects
         */
        getErrorsByLevel(level) {
            return this.errors.filter(e => e.level === level);
        }

        /**
         * Get errors by filename
         * @param {String} filename - Filename to filter by
         * @returns {Array} Filtered array of error objects
         */
        getErrorsByFilename(filename) {
            return this.errors.filter(e => e.filename.includes(filename));
        }

        /**
         * Get errors within a time range
         * @param {Date} startTime - Start time
         * @param {Date} endTime - End time
         * @returns {Array} Filtered array of error objects
         */
        getErrorsByTimeRange(startTime, endTime) {
            return this.errors.filter(e => {
                const errorTime = new Date(e.timestamp);
                return errorTime >= startTime && errorTime <= endTime;
            });
        }

        /**
         * Get error statistics
         * @returns {Object} Error statistics
         */
        getStats() {
            return {
                ...this.stats,
                currentErrorCount: this.errors.length
            };
        }

        /**
         * Clear all error logs
         */
        clearLogs() {
            this.errors = [];
            this.stats = {
                totalErrors: 0,
                totalWarnings: 0,
                totalInfo: 0,
                totalCritical: 0,
                sessionStart: new Date().toISOString()
            };
            this.saveToStorage();
        }

        /**
         * Export error log as JSON with full data
         * @private
         * @returns {String} JSON string of complete error log
         */
        _fullExport() {
            return JSON.stringify({
                errors: this.errors,
                stats: this.stats,
                exportDate: new Date().toISOString()
            }, null, 2);
        }

        /**
         * Export minimal error log when full export fails
         * @private
         * @param {Error} error - The serialization error that occurred
         * @returns {String} JSON string of minimal error log
         */
        _minimalExport(error) {
            try {
                return JSON.stringify({
                    errors: [],
                    stats: this.stats,
                    exportDate: new Date().toISOString(),
                    serializationError: true,
                    errorMessage: error.message,
                    totalErrorCount: this.errors.length
                }, null, 2);
            } catch (fallbackError) {
                // Ultimate fallback with safe stats extraction
                return JSON.stringify({
                    errors: [],
                    stats: {
                        totalErrors: this.stats.totalErrors || 0,
                        totalWarnings: this.stats.totalWarnings || 0,
                        totalInfo: this.stats.totalInfo || 0,
                        totalCritical: this.stats.totalCritical || 0
                    },
                    exportDate: new Date().toISOString(),
                    serializationError: true,
                    errorMessage: "Complete serialization failure"
                }, null, 2);
            }
        }

        /**
         * Export error log as JSON
         * Uses 3-level fallback: full export -> minimal export -> ultimate fallback
         * @returns {String} JSON string of error log
         */
        exportAsJSON() {
            try {
                return this._fullExport();
            } catch (e) {
                console.warn("Failed to serialize full error log for export:", e);
                return this._minimalExport(e);
            }
        }

        /**
         * Backwards-compatible alias for exporting logs
         * @returns {String}
         */
        exportLog() {
            return this.exportAsJSON();
        }

        /**
         * Generate error report
         * @returns {String} Formatted error report
         */
        generateReport() {
            const lines = [];
            lines.push("=== iMacros Error Report ===");
            lines.push(`Generated: ${new Date().toISOString()}`);
            lines.push(`Session Started: ${this.stats.sessionStart}`);
            lines.push("");
            lines.push("=== Statistics ===");
            lines.push(`Total Errors: ${this.stats.totalErrors}`);
            lines.push(`Total Warnings: ${this.stats.totalWarnings}`);
            lines.push(`Total Info: ${this.stats.totalInfo}`);
            lines.push(`Total Critical: ${this.stats.totalCritical}`);
            lines.push(`Current Log Size: ${this.errors.length}`);
            lines.push("");

            // Group errors by filename
            const errorsByFile = {};
            this.errors.forEach(error => {
                if (!errorsByFile[error.filename]) {
                    errorsByFile[error.filename] = [];
                }
                errorsByFile[error.filename].push(error);
            });

            lines.push("=== Errors by File ===");
            Object.keys(errorsByFile).sort().forEach(filename => {
                const fileErrors = errorsByFile[filename];
                lines.push(`\n${filename}: ${fileErrors.length} error(s)`);

                // Show up to 5 most recent errors for this file
                const recentErrors = fileErrors.slice(-5);
                recentErrors.forEach(error => {
                    const codeFragment = error.code ? ` (${error.code})` : "";
                    lines.push(`  [${error.level}] Line ${error.lineno}: ${error.message}${codeFragment}`);
                    lines.push(`    at ${error.timestamp}`);
                });
            });

            return lines.join('\n');
        }
    }

    // Create singleton instance
    const errorLogger = new ErrorLogger();

    // Export to window for global access
    window.ErrorLogger = errorLogger;
    window.ErrorLevel = ErrorLevel;
    window.ErrorCodes = ErrorCodes;

    const createCallerContext = () => {
        const stack = new Error().stack;
        const caller = errorLogger.extractCallerFromStack(stack, 1);
        return { stack, caller };
    };

    const createLegacyLogger = (level) => {
        return function (message, context, code, providedStack, providedCaller) {
            const stack = providedStack || new Error().stack;
            const caller = providedCaller || errorLogger.extractCallerFromStack(stack, 1);
            return errorLogger.logError({
                level: level,
                message: message,
                code: code || ErrorCodes.UNKNOWN,
                filename: caller.filename,
                lineno: caller.lineno,
                context: context,
                stack: stack
            });
        };
    };

    const legacyLoggers = {
        error: createLegacyLogger(ErrorLevel.ERROR),
        warning: createLegacyLogger(ErrorLevel.WARNING),
        info: createLegacyLogger(ErrorLevel.INFO),
        critical: createLegacyLogger(ErrorLevel.CRITICAL)
    };

    const hasGlobalErrorLogger = typeof GlobalErrorLogger !== 'undefined' &&
        typeof GlobalErrorLogger.logError === 'function' &&
        typeof GlobalErrorLogger.logWarning === 'function' &&
        typeof GlobalErrorLogger.logInfo === 'function';

    if (hasGlobalErrorLogger) {
        console.info("[iMacros] GlobalErrorLogger detected - delegating legacy functions to it");

        const delegateToGlobal = (methodName, legacyKey, extraDetails = {}) => {
            const globalMethod = GlobalErrorLogger[methodName] || GlobalErrorLogger.logError;
            return function (message, context, code) {
                const { stack, caller } = createCallerContext();
                const details = {
                    code: code || ErrorCodes.UNKNOWN,
                    legacyCall: true,
                    stack: stack,
                    caller: caller,
                    ...extraDetails
                };
                try {
                    return globalMethod.call(GlobalErrorLogger, context || 'Legacy', message, details);
                } catch (err) {
                    return legacyLoggers[legacyKey](message, context, code, stack, caller);
                }
            };
        };

        window.logError = delegateToGlobal('logError', 'error');
        window.logWarning = delegateToGlobal('logWarning', 'warning');
        window.logInfo = delegateToGlobal('logInfo', 'info');
        window.logCritical = delegateToGlobal('logError', 'critical', { severity: 'CRITICAL' });
    } else {
        /**
         * Global helper functions for convenient logging
         *
         * These functions use extractCallerFromStack(stack, 1) to correctly identify
         * the actual caller's location instead of the helper function's own location.
         */
        window.logError = legacyLoggers.error;
        window.logWarning = legacyLoggers.warning;
        window.logInfo = legacyLoggers.info;
        window.logCritical = legacyLoggers.critical;
    }

    /**
     * Check and log chrome.runtime.lastError
     * @param {String} operationName - Name of the operation being performed
     * @param {Object} additionalContext - Additional context to log
     * @returns {Boolean} - True if there was an error, false otherwise
     */
    function checkChromeError(operationName, additionalContext) {
        if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.lastError) {
            const stack = new Error().stack;
            const caller = errorLogger.extractCallerFromStack(stack, 1);
            errorLogger.logError({
                level: ErrorLevel.ERROR,
                message: `Chrome API Error in ${operationName}: ${chrome.runtime.lastError.message}`,
                code: ErrorCodes.CHROME_API,
                filename: caller.filename,
                lineno: caller.lineno,
                context: {
                    operation: operationName,
                    chromeError: chrome.runtime.lastError.message,
                    ...additionalContext
                },
                stack: stack,
                type: "ChromeAPIError"
            });
            return true;
        }
        return false;
    }

    window.checkChromeError = checkChromeError;

    /**
     * Wrap a Chrome API callback to automatically check for lastError
     * @param {Function} callback - Original callback function
     * @param {String} operationName - Name of the operation for error logging
     * @returns {Function} - Wrapped callback
     *
     * Note: This wrapper logs errors but maintains the original Chrome API callback signature.
     * The callback is still invoked with the original arguments even if an error occurred.
     */
    window.wrapChromeCallback = function (callback, operationName) {
        return function (...args) {
            // Log error if present, but don't change the callback signature
            checkChromeError(operationName);

            // Always call the original callback with original arguments
            if (callback) {
                return callback(...args);
            }
        };
    };

    /**
     * Wrap a Promise-returning function with error logging
     * @param {Function} fn - Function that returns a Promise
     * @param {String} operationName - Name of the operation for error logging
     * @returns {Function} - Wrapped function
     */
    window.wrapPromise = function (fn, operationName) {
        return function (...args) {
            return fn.apply(this, args)
                .catch(error => {
                    const stack = (error && error.stack) ? error.stack : new Error().stack;
                    const caller = errorLogger.extractCallerFromStack(stack, 1);
                    const message = (error && error.message) ? error.message : String(error);
                    const errorType = (error && error.constructor && error.constructor.name) || typeof error;
                    errorLogger.logError({
                        level: ErrorLevel.ERROR,
                        message: `Promise rejection in ${operationName}: ${message}`,
                        code: ErrorCodes.UNHANDLED_PROMISE,
                        filename: caller.filename,
                        lineno: caller.lineno,
                        context: {
                            operation: operationName,
                            errorType: errorType
                        },
                        stack: stack,
                        type: "PromiseRejection"
                    });
                    throw error; // Re-throw to maintain Promise chain
                });
        };
    };

    /**
     * Create a safe version of chrome.storage API with automatic error logging
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
        window.safeStorage = {
            local: {
                get: function (keys) {
                    return new Promise((resolve, reject) => {
                        chrome.storage.local.get(keys, (result) => {
                            if (checkChromeError('chrome.storage.local.get', { keys })) {
                                reject(chrome.runtime.lastError);
                            } else {
                                resolve(result);
                            }
                        });
                    });
                },
                set: function (items) {
                    return new Promise((resolve, reject) => {
                        chrome.storage.local.set(items, () => {
                            if (checkChromeError('chrome.storage.local.set', { keys: Object.keys(items) })) {
                                reject(chrome.runtime.lastError);
                            } else {
                                resolve();
                            }
                        });
                    });
                },
                remove: function (keys) {
                    return new Promise((resolve, reject) => {
                        chrome.storage.local.remove(keys, () => {
                            if (checkChromeError('chrome.storage.local.remove', { keys })) {
                                reject(chrome.runtime.lastError);
                            } else {
                                resolve();
                            }
                        });
                    });
                }
            },
            sync: {
                get: function (keys) {
                    return new Promise((resolve, reject) => {
                        chrome.storage.sync.get(keys, (result) => {
                            if (checkChromeError('chrome.storage.sync.get', { keys })) {
                                reject(chrome.runtime.lastError);
                            } else {
                                resolve(result);
                            }
                        });
                    });
                },
                set: function (items) {
                    return new Promise((resolve, reject) => {
                        chrome.storage.sync.set(items, () => {
                            if (checkChromeError('chrome.storage.sync.set', { keys: Object.keys(items) })) {
                                reject(chrome.runtime.lastError);
                            } else {
                                resolve();
                            }
                        });
                    });
                },
                remove: function (keys) {
                    return new Promise((resolve, reject) => {
                        chrome.storage.sync.remove(keys, () => {
                            if (checkChromeError('chrome.storage.sync.remove', { keys })) {
                                reject(chrome.runtime.lastError);
                            } else {
                                resolve();
                            }
                        });
                    });
                }
            }
        };
    }

    console.info("[iMacros] Error Logger initialized successfully");
    console.info("[iMacros] Use ErrorLogger to access error logs");
    console.info("[iMacros] Use logError(), logWarning(), logInfo(), logCritical() for logging");
    console.info("[iMacros] Use checkChromeError(), wrapChromeCallback(), wrapPromise() for Chrome API error handling");

    // ========================================================================
    // Legacy Compatibility Layer - Delegates to GlobalErrorLogger
    // ========================================================================
    // If GlobalErrorLogger is available (loaded before this file), override the legacy
    // functions to use it as the backend for better stack trace parsing
    if (typeof GlobalErrorLogger !== 'undefined') {
        console.info("[iMacros] GlobalErrorLogger detected - delegating legacy functions to it");

        // Override the legacy functions that were just defined above
        // These will now use GlobalErrorLogger instead of ErrorLogger
        window.logError = function (message, context, code) {
            try {
                // Convert legacy signature (message, context, code) to new (context, error, details)
                return GlobalErrorLogger.logError(
                    context || 'Legacy',
                    message,
                    { code: code, legacyCall: true }
                );
            } catch (err) {
                // Fallback to console if GlobalErrorLogger fails
                console.error('[errorLogger] GlobalErrorLogger.logError failed:', err);
                console.error('[Legacy logError]', message, context, code);
            }
        };

        window.logWarning = function (message, context, code) {
            try {
                return GlobalErrorLogger.logWarning(
                    context || 'Legacy',
                    message,
                    { code: code, legacyCall: true }
                );
            } catch (err) {
                console.warn('[errorLogger] GlobalErrorLogger.logWarning failed:', err);
                console.warn('[Legacy logWarning]', message, context, code);
            }
        };

        window.logInfo = function (message, context, code) {
            try {
                return GlobalErrorLogger.logInfo(
                    context || 'Legacy',
                    message,
                    { code: code, legacyCall: true }
                );
            } catch (err) {
                console.info('[errorLogger] GlobalErrorLogger.logInfo failed:', err);
                console.info('[Legacy logInfo]', message, context, code);
            }
        };

        window.logCritical = function (message, context, code) {
            try {
                return GlobalErrorLogger.logError(
                    context || 'Legacy',
                    message,
                    { code: code, severity: 'CRITICAL', legacyCall: true }
                );
            } catch (err) {
                console.error('[errorLogger] GlobalErrorLogger.logError (critical) failed:', err);
                console.error('[Legacy logCritical]', message, context, code);
            }
        };

        console.info("[iMacros] Legacy compatibility layer active - all log functions now use GlobalErrorLogger");
    }

})(typeof window !== 'undefined' ? window : global);



======================================================================
FILE PATH: extractDialog.js
======================================================================
/*
Copyright © 1992-2021 Progress Software Corporation and/or one of its subsidiaries or affiliates. All rights reserved.
*/

function ok() {
    window.close();
}

window.addEventListener("beforeunload", function() {
    args.mplayer.waitingForExtract = false;
    args.mplayer.next("extractDialog");
    return null;
});

window.addEventListener("load", function(evt) {
    var field = document.getElementById("data-field");
    field.focus();
    if (args) {
        field.value = args.data;
        //field.select();
    }

    //document.getElementById("ok-button").addEventListener("click", ok);
    let okButton = document.getElementById("ok-button");
    okButton.addEventListener("click", ok);
    okButton.focus();
    okButton.addEventListener("keydown", function(e) {
        var type = e.type;
        if (type === "keydown"){
            if((e.keyCode === 13) || (e.keyCode === 32)){
                ok();
                e.preventDefault();
            }
        }
    });
    resizeToContent(window, document.getElementById('container'));
});



======================================================================
FILE PATH: FileSyncBridge.js
======================================================================
/*
Copyright © 1992-2021 Progress Software Corporation and/or one of its subsidiaries or affiliates. All rights reserved.
*/

(function(global) {
    'use strict';

    const CHANGE_TOPIC = 'vfs-change';
    const EXPORT_KEY = 'vfs_export_bundle';
    const LAST_EVENT_KEY = 'vfs_last_event';
    const DEFAULT_EXPORT_INTERVAL = 5 * 60 * 1000; // 5 minutes

    class FileSyncBridge {
        constructor(options = {}) {
            this.mode = options.mode || 'background';
            this.vfs = options.vfs || null;
            this.communicator = options.communicator || null;
            this.exportInterval = options.exportInterval || DEFAULT_EXPORT_INTERVAL;
            this.listeners = new Set();
            this.onChangeCallback = typeof options.onChange === 'function' ? options.onChange : null;
            this.timer = null;
            this.started = false;
            this._runtimeListener = null;
            this._vfsSubscription = null;
        }

        start() {
            if (this.started) {
                return;
            }
            this.started = true;

            if (this.mode === 'background' && this.vfs && typeof this.vfs.on === 'function') {
                this._vfsSubscription = this.vfs.on('change', (event) => {
                    this._handleVfsChange(event).catch((err) => {
                        console.error('FileSyncBridge VFS change handling failed', err);
                    });
                });
                this._scheduleExport();
            }

            this._runtimeListener = (message, sender, sendResponse) => {
                if (!message || !message.topic) {
                    return;
                }
                if (message.topic === CHANGE_TOPIC && this.mode === 'ui') {
                    this._notifyListeners(message.data);
                }
                if (message.topic === 'vfs-request-export' && this.mode === 'background') {
                    this._handleExportRequest(sendResponse);
                    return true;
                }
                return false;
            };
            if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
                chrome.runtime.onMessage.addListener(this._runtimeListener);
            }
        }

        stop() {
            if (!this.started) {
                return;
            }
            this.started = false;
            if (this._vfsSubscription) {
                this._vfsSubscription();
                this._vfsSubscription = null;
            }
            if (this.timer) {
                clearInterval(this.timer);
                this.timer = null;
            }
            if (this._runtimeListener && typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
                chrome.runtime.onMessage.removeListener(this._runtimeListener);
            }
        }

        onChange(handler) {
            if (typeof handler === 'function') {
                this.listeners.add(handler);
                return () => this.listeners.delete(handler);
            }
            return function noop() {};
        }

        async exportSnapshot() {
            if (!this.vfs || typeof this.vfs.exportTree !== 'function') {
                return null;
            }
            const bundle = await this.vfs.exportTree();
            await this._persistExport(bundle);
            return bundle;
        }

        async requestExportFromBackground() {
            return new Promise((resolve, reject) => {
                if (typeof chrome === 'undefined' || !chrome.runtime || !chrome.runtime.sendMessage) {
                    return reject(new Error('Runtime messaging not available'));
                }
                chrome.runtime.sendMessage({ topic: 'vfs-request-export' }, (response) => {
                    if (chrome.runtime.lastError) {
                        reject(chrome.runtime.lastError);
                    } else {
                        resolve(response);
                    }
                });
            });
        }

        _scheduleExport() {
            if (!this.vfs) return;
            if (this.timer) {
                clearInterval(this.timer);
            }
            this.timer = setInterval(() => {
                this.exportSnapshot().catch((err) => {
                    console.warn('FileSyncBridge export failed', err);
                });
            }, this.exportInterval);
        }

        async _handleExportRequest(sendResponse) {
            try {
                const bundle = await this.exportSnapshot();
                if (sendResponse) {
                    sendResponse({ success: true, bundle });
                }
            } catch (err) {
                if (sendResponse) {
                    sendResponse({ success: false, error: err.message });
                }
            }
        }

        async _handleVfsChange(event) {
            const payload = Object.assign({ timestamp: Date.now() }, event || {});
            try {
                await this._persistEvent(payload);
            } catch (err) {
                console.warn('FileSyncBridge persistence failed', err);
            }
            this._notifyListeners(payload);
            const message = { topic: CHANGE_TOPIC, data: payload };
            if (this.communicator && typeof this.communicator.broadcastMessage === 'function') {
                // Pass undefined as win_id parameter to avoid payload being misinterpreted
                this.communicator.broadcastMessage(CHANGE_TOPIC, payload, undefined);
            }
            if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.sendMessage) {
                // Properly handle chrome.runtime.lastError in callback
                chrome.runtime.sendMessage(message, (response) => {
                    if (chrome.runtime.lastError) {
                        console.warn('FileSyncBridge runtime message failed', chrome.runtime.lastError);
                    }
                });
            }
        }

        _notifyListeners(event) {
            if (this.onChangeCallback) {
                try {
                    this.onChangeCallback(event);
                } catch (err) {
                    console.error('FileSyncBridge onChange callback failed', err);
                }
            }
            this.listeners.forEach((handler) => {
                try {
                    handler(event);
                } catch (err) {
                    console.error('FileSyncBridge listener failed', err);
                }
            });
        }

        async _persistExport(bundle) {
            if (!bundle) return;
            await this._storageSet({ [EXPORT_KEY]: bundle });
        }

        async _persistEvent(event) {
            if (!event) return;
            await this._storageSet({ [LAST_EVENT_KEY]: event });
        }

        _storageSet(items) {
            return new Promise((resolve) => {
                if (typeof chrome !== 'undefined' && chrome.storage && chrome.storage.local) {
                    chrome.storage.local.set(items, () => {
                        if (chrome.runtime && chrome.runtime.lastError) {
                            console.warn('FileSyncBridge storage write failed', chrome.runtime.lastError);
                        }
                        resolve();
                    });
                } else {
                    Object.keys(items).forEach((key) => {
                        try {
                            localStorage.setItem(key, JSON.stringify(items[key]));
                        } catch (err) {
                            console.warn('FileSyncBridge storage write failed', err);
                        }
                    });
                    resolve();
                }
            });
        }
    }

    FileSyncBridge.CHANGE_TOPIC = CHANGE_TOPIC;
    FileSyncBridge.EXPORT_KEY = EXPORT_KEY;
    FileSyncBridge.LAST_EVENT_KEY = LAST_EVENT_KEY;

    global.FileSyncBridge = FileSyncBridge;
})(this);



======================================================================
FILE PATH: FileSystemAccessService.js
======================================================================
/**
 * FileSystemAccessService.js
 *
 * File System Access API を使用してローカルファイルシステムへのアクセスを提供
 * ネイティブモジュールなしで実際のローカルファイルシステムにアクセス可能
 *
 * 要件: Chrome 86+ (Chromiumベース)
 */

// グローバルエラーロガーのヘルパー関数
// errorLogger.js のグローバル関数とインスタンスを使用
/* global ErrorLogger, ErrorLevel, ErrorCodes, logWarning, logInfo */

// Error code constant to prevent ReferenceError in test environments
const FS_ACCESS_DEFAULT_ERROR_CODE =
    typeof ErrorCodes !== 'undefined' && ErrorCodes.MANUAL
        ? ErrorCodes.MANUAL
        : "IMX-9000";

function fsAccessLogError(context, error, details = {}) {
    if (typeof ErrorLogger !== 'undefined' && typeof ErrorLevel !== 'undefined') {
        // Use ErrorLogger instance directly to preserve original error stack
        const errorMessage = error?.message || String(error);
        const stack = error?.stack || new Error().stack;

        // Extract caller info from the original error stack
        const caller = ErrorLogger.extractCallerFromStack(stack, 0);

        return ErrorLogger.logError({
            level: ErrorLevel.ERROR,
            message: `[FileSystemAccess][${context}]: ${errorMessage}`,
            code: FS_ACCESS_DEFAULT_ERROR_CODE,
            filename: caller.filename,
            lineno: caller.lineno,
            colno: 0,
            stack: stack,
            context: {
                ...details,
                originalError: error,
                fsContext: context
            }
        });
    } else {
        console.error(`[FileSystemAccess][${context}]`, error, details);
    }
}

function fsAccessLogWarning(context, message, details = {}) {
    if (typeof logWarning !== 'undefined') {
        const fullMessage = `[FileSystemAccess][${context}]: ${message}`;
        return logWarning(fullMessage, { ...details, fsContext: context }, FS_ACCESS_DEFAULT_ERROR_CODE);
    } else {
        console.warn(`[FileSystemAccess][${context}]`, message, details);
    }
}

function fsAccessLogInfo(context, message, details = {}) {
    if (typeof logInfo !== 'undefined') {
        const fullMessage = `[FileSystemAccess][${context}]: ${message}`;
        return logInfo(fullMessage, { ...details, fsContext: context }, FS_ACCESS_DEFAULT_ERROR_CODE);
    } else {
        console.info(`[FileSystemAccess][${context}]`, message, details);
    }
}

// IndexedDB でディレクトリハンドルを永続化するためのキー
const IDB_NAME = 'iMacrosFileSystemAccess';
const IDB_VERSION = 1;
const IDB_STORE_NAME = 'directoryHandles';

/**
 * Glob パターンを正規表現に変換
 */
function globToRegex(pattern) {
    const escaped = pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    return new RegExp(escaped.replace(/\\\*/g, '.*'));
}

class FileSystemAccessService {
    constructor(options = {}) {
        this.ready = false;
        this.rootHandle = null;
        this.rootPath = null;
        this.eventHandlers = {};
        this.db = null;
        this.pathMappingService = null; // WindowsPathMappingService インスタンス

        // デフォルトオプション
        this.options = {
            autoPrompt: options.autoPrompt !== false, // 初期化時に自動的にディレクトリ選択を促すか
            persistPermissions: options.persistPermissions !== false,
            enableWindowsPathMapping: options.enableWindowsPathMapping !== false, // Windowsパスマッピングを有効化
            ...options
        };
    }

    /**
     * ブラウザがFile System Access APIをサポートしているかチェック
     */
    static isSupported() {
        return typeof window !== 'undefined' &&
            'showDirectoryPicker' in window &&
            'showOpenFilePicker' in window &&
            'showSaveFilePicker' in window;
    }

    /**
     * IndexedDBを初期化
     */
    async _initDB() {
        if (this.db) return this.db;

        try {
            return await new Promise((resolve, reject) => {
                const request = indexedDB.open(IDB_NAME, IDB_VERSION);

                request.onerror = () => {
                    fsAccessLogError('FileSystemAccessService._initDB', request.error || new Error('IndexedDB open failed'), {
                        database: IDB_NAME,
                        version: IDB_VERSION
                    });
                    reject(request.error);
                };

                request.onsuccess = () => {
                    try {
                        this.db = request.result;
                        fsAccessLogInfo('FileSystemAccessService._initDB', 'IndexedDB initialized successfully', {
                            database: IDB_NAME
                        });
                        resolve(this.db);
                    } catch (err) {
                        fsAccessLogError('FileSystemAccessService._initDB.onsuccess', err, {
                            database: IDB_NAME
                        });
                        reject(err);
                    }
                };

                request.onupgradeneeded = (event) => {
                    try {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains(IDB_STORE_NAME)) {
                            db.createObjectStore(IDB_STORE_NAME);
                            fsAccessLogInfo('FileSystemAccessService._initDB', 'Created object store', {
                                store: IDB_STORE_NAME
                            });
                        }
                    } catch (err) {
                        fsAccessLogError('FileSystemAccessService._initDB.onupgradeneeded', err, {
                            database: IDB_NAME
                        });
                        reject(err);
                    }
                };
            });
        } catch (err) {
            fsAccessLogError('FileSystemAccessService._initDB', err, {
                database: IDB_NAME,
                version: IDB_VERSION
            });
            throw err;
        }
    }

    /**
     * ディレクトリハンドルをIndexedDBに保存
     */
    async _saveDirectoryHandle(key, handle) {
        if (!this.options.persistPermissions) return;

        const db = await this._initDB();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([IDB_STORE_NAME], 'readwrite');
            const store = transaction.objectStore(IDB_STORE_NAME);
            const request = store.put(handle, key);

            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
        });
    }

    /**
     * IndexedDBからディレクトリハンドルを読み込み
     */
    async _loadDirectoryHandle(key) {
        if (!this.options.persistPermissions) return null;

        try {
            const db = await this._initDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([IDB_STORE_NAME], 'readonly');
                const store = transaction.objectStore(IDB_STORE_NAME);
                const request = store.get(key);

                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        } catch (err) {
            fsAccessLogWarning(
                'FileSystemAccessService._loadDirectoryHandle',
                'Failed to load directory handle from IndexedDB',
                { key: key, error: err.message }
            );
            return null;
        }
    }

    /**
     * 保存されたディレクトリハンドルの許可を確認・要求
     */
    async _verifyPermission(handle, mode = 'read', options = {}) {
        const permOptions = {};
        if (mode === 'readwrite') {
            permOptions.mode = 'readwrite';
        }

        // 既に許可があるかチェック
        const permissionState = await handle.queryPermission(permOptions);
        if (permissionState === 'granted') {
            return true;
        }

        // skipRequest が true の場合は要求しない（バックグラウンドコンテキスト）
        if (options.skipRequest === true) {
            return false;
        }

        // ユーザーに許可を要求（ユーザー操作が必要）
        // 注: permissionState が 'denied' でも、ユーザーが明示的にボタンをクリックした場合は
        // requestPermission を試みる。ブラウザが許可ダイアログを表示するかは
        // ブラウザのポリシー次第だが、少なくとも試行する機会を与える。
        try {
            const result = await handle.requestPermission(permOptions);
            if (result === 'granted') {
                return true;
            } else {
                // ユーザーが拒否した、またはブラウザが許可しなかった
                fsAccessLogWarning(
                    'FileSystemAccessService._verifyPermission',
                    `Permission request returned: ${result}`,
                    { mode: mode, previousState: permissionState }
                );
                return false;
            }
        } catch (err) {
            // requestPermission が失敗した場合（例：ユーザー操作がないコンテキスト）
            fsAccessLogWarning(
                'FileSystemAccessService._verifyPermission',
                'requestPermission failed - may require user interaction',
                { error: err.message, mode: mode }
            );
            return false;
        }
    }

    /**
     * サービスを初期化
     */
    async init() {
        try {
            const canPickDirectories = FileSystemAccessService.isSupported();

            if (!canPickDirectories) {
                // In contexts where showDirectoryPicker is not available (e.g., chrome-extension://),
                // we can still use saved handles from IndexedDB
                fsAccessLogInfo('FileSystemAccessService.init', 'Directory picker not available in this context, will try to use saved handle');
            }

            // Initialize IndexedDB first
            await this._initDB();
            fsAccessLogInfo('FileSystemAccessService.init', 'IndexedDB initialized successfully', {
                database: IDB_NAME
            });

            fsAccessLogInfo('FileSystemAccessService.init', 'Initializing FileSystemAccessService', {
                autoPrompt: this.options.autoPrompt,
                enableWindowsPathMapping: this.options.enableWindowsPathMapping
            });

            // WindowsPathMappingServiceを初期化
            if (this.options.enableWindowsPathMapping && typeof WindowsPathMappingService !== 'undefined') {
                try {
                    this.pathMappingService = new WindowsPathMappingService({
                        autoPrompt: this.options.autoPrompt
                    });
                    await this.pathMappingService.init();
                    fsAccessLogInfo('FileSystemAccessService.init', 'WindowsPathMappingService initialized');
                } catch (err) {
                    fsAccessLogError('FileSystemAccessService.init', err, {
                        context: 'WindowsPathMappingService initialization',
                        severity: 'HIGH'
                    });
                    // Continue without Windows path mapping
                    this.pathMappingService = null;
                }
            }

            // 保存されたルートディレクトリハンドルを読み込み
            const savedHandle = await this._loadDirectoryHandle('rootDirectory');

            if (savedHandle) {
                try {
                    // 許可を確認（バックグラウンドコンテキストでは requestPermission をスキップ）
                    // queryPermission のみで確認し、'granted' の場合のみ使用
                    const hasPermission = await this._verifyPermission(
                        savedHandle,
                        'readwrite',
                        { skipRequest: !this.options.autoPrompt }
                    );

                    if (hasPermission) {
                        this.rootHandle = savedHandle;
                        this.rootName = savedHandle.name;
                        this.rootPath = '/';
                        this.ready = true;
                        this._emit('ready', { rootHandle: this.rootHandle });
                        fsAccessLogInfo('FileSystemAccessService.init', 'Service initialized with saved handle', {
                            directoryName: savedHandle.name
                        });
                        return true;
                    } else {
                        // 権限がない場合でも、ハンドルは保持しておく
                        // ユーザーが後でアクセスを許可できるように
                        this.rootHandle = savedHandle;
                        this.rootName = savedHandle.name;
                        this.rootPath = '/';
                        this.ready = false; // ready は false のまま
                        fsAccessLogWarning(
                            'FileSystemAccessService.init',
                            'Directory handle found but permission expired - user must re-grant access via options page',
                            {
                                directoryName: savedHandle.name,
                                permissionState: 'expired', // Custom app state, not a standard File System Access API value
                                action: 'User should click Browse button in options to re-select directory'
                            }
                        );
                        // autoPrompt が true の場合は、ユーザーにプロンプトを表示
                        if (this.options.autoPrompt) {
                            return await this.promptForDirectory();
                        }
                        return false;
                    }
                } catch (err) {
                    fsAccessLogError('FileSystemAccessService.init', err, {
                        context: 'Permission verification for saved handle'
                    });
                    // Even if permission check fails, preserve the handle for later restoration
                    this.rootHandle = savedHandle;
                    this.rootName = savedHandle.name;
                    this.rootPath = '/';
                    this.ready = false;
                    fsAccessLogWarning(
                        'FileSystemAccessService.init',
                        'Saved handle found but permission verification failed - handle preserved for later restoration'
                    );
                    return false;
                }
            }

            // 保存されたハンドルがないか許可がない場合
            if (this.options.autoPrompt) {
                fsAccessLogInfo('FileSystemAccessService.init', 'Prompting user for directory');
                return await this.promptForDirectory();
            }

            fsAccessLogInfo('FileSystemAccessService.init', 'Service initialized without root handle (autoPrompt=false)');
            return false;

        } catch (err) {
            fsAccessLogError('FileSystemAccessService.init', err, {
                options: this.options,
                severity: 'CRITICAL'
            });
            throw err;
        }
    }

    /**
     * ユーザーにディレクトリ選択ダイアログを表示
     */
    async promptForDirectory() {
        try {
            const handle = await window.showDirectoryPicker({
                mode: 'readwrite',
                startIn: 'documents'
            });

            this.rootHandle = handle;
            this.rootName = handle.name;
            this.rootPath = '/';
            this.ready = true;

            // ディレクトリハンドルを保存
            await this._saveDirectoryHandle('rootDirectory', handle);

            this._emit('ready', { rootHandle: this.rootHandle });
            this._emit('change', { type: 'rootChanged', path: '/' });

            return true;
        } catch (err) {
            if (err.name === 'AbortError') {
                console.log('User cancelled directory selection');
            } else {
                console.error('Failed to select directory:', err);
            }
            return false;
        }
    }

    /**
     * 保存されたディレクトリハンドルの権限を再要求
     * ユーザー操作が必要（例：ボタンクリック後に呼び出す）
     */
    async requestPermission() {
        if (!this.rootHandle) {
            fsAccessLogWarning(
                'FileSystemAccessService.requestPermission',
                'No saved handle to request permission for'
            );
            return false;
        }

        try {
            const hasPermission = await this._verifyPermission(
                this.rootHandle,
                'readwrite',
                { skipRequest: false } // 明示的に requestPermission を呼び出す
            );

            if (hasPermission) {
                this.ready = true;
                this._emit('ready', { rootHandle: this.rootHandle });
                fsAccessLogInfo('FileSystemAccessService.requestPermission', 'Permission granted');
                return true;
            } else {
                fsAccessLogWarning('FileSystemAccessService.requestPermission', 'Permission denied by user');
                return false;
            }
        } catch (err) {
            fsAccessLogError('FileSystemAccessService.requestPermission', err, {
                severity: 'HIGH'
            });
            return false;
        }
    }

    /**
     * Windowsの絶対パスかどうかを判定
     */
    _isWindowsAbsolutePath(path) {
        if (!path) return false;
        return /^[a-z]:[/\\]/i.test(path);
    }

    /**
     * パスを解決して、適切なルートハンドルと相対パスを返す
     * Windowsパスの場合は WindowsPathMappingService を使用
     * 仮想パスの場合は rootHandle を使用
     */
    async _resolvePathAndHandle(path) {
        // Windowsの絶対パスの場合
        if (this._isWindowsAbsolutePath(path)) {
            if (!this.pathMappingService) {
                const err = new Error(
                    `Windows absolute path detected: ${path}\n` +
                    `Windows path mapping is not enabled. ` +
                    `Please enable it by setting enableWindowsPathMapping: true in options, ` +
                    `or use Native File Access.`
                );
                fsAccessLogError('FileSystemAccessService._resolvePathAndHandle', err, {
                    path: path,
                    severity: 'HIGH',
                    category: 'PATH_MAPPING'
                });
                throw err;
            }

            try {
                const resolved = await this.pathMappingService.resolveWindowsPath(path);
                return {
                    rootHandle: resolved.handle,
                    relativePath: resolved.relativePath,
                    isWindowsPath: true,
                    mappedPath: resolved.mappedPath
                };
            } catch (err) {
                const wrappedErr = new Error(
                    `Failed to resolve Windows path: ${path}\n` +
                    `${err.message}`
                );
                fsAccessLogError('FileSystemAccessService._resolvePathAndHandle', wrappedErr, {
                    path: path,
                    originalError: err.message,
                    severity: 'HIGH',
                    category: 'PATH_RESOLUTION'
                });
                throw wrappedErr;
            }
        }

        // 仮想パス（/で始まる）の場合
        if (!this.ready || !this.rootHandle) {
            const err = new Error('FileSystemAccessService is not initialized');
            fsAccessLogError('FileSystemAccessService._resolvePathAndHandle', err, {
                path: path,
                ready: this.ready,
                hasRootHandle: !!this.rootHandle,
                severity: 'CRITICAL',
                category: 'INITIALIZATION'
            });
            throw err;
        }

        let relativePath = path.startsWith('/') ? path.substring(1) : path;

        // ルートディレクトリ名で始まるパスの処理
        // 例: rootName="Macros", path="Macros/Demo.iim" -> relativePath="Demo.iim"
        if (this.rootName) {
            // パスセパレータを統一
            const normalizedPath = relativePath.replace(/\\/g, '/');
            const parts = normalizedPath.split('/');

            if (parts.length > 0 && parts[0] === this.rootName) {
                // 最初のパス要素がルート名と一致する場合、それを削除
                parts.shift();
                relativePath = parts.join('/');
            }
        }

        return {
            rootHandle: this.rootHandle,
            relativePath: relativePath,
            isWindowsPath: false,
            mappedPath: null
        };
    }

    /**
     * パスを配列に分割
     */
    _splitPath(path) {
        if (!path || path === '/') return [];

        // Windowsパスの場合、バックスラッシュをスラッシュに変換
        path = path.replace(/\\/g, '/');

        // 先頭のスラッシュを削除し、連続したスラッシュを1つに
        const normalized = path.replace(/^\/+/, '').replace(/\/+/g, '/');
        return normalized.split('/').filter(p => p.length > 0);
    }

    /**
     * パスを結合（Windows/Unix両対応）
     */
    _joinPath(basePath, ...parts) {
        // basePathが空の場合、最初のパーツがWindowsパスかチェック
        if (!basePath) {
            const firstPart = parts.find(p => p && p.trim());
            const isWindowsPath = firstPart ? this._isWindowsAbsolutePath(firstPart) : false;
            const separator = isWindowsPath ? '\\' : '/';
            return parts.filter(p => p && p.trim()).join(separator);
        }

        // Windowsパスの場合、適切なセパレータを使用
        const isWindowsPath = this._isWindowsAbsolutePath(basePath);
        const separator = isWindowsPath ? '\\' : '/';

        // ベースパスを正規化（内部のセパレータも統一）
        let result = basePath.replace(/[/\\]+/g, separator).replace(/[/\\]+$/, '');

        // 各パーツを追加
        for (const part of parts) {
            if (part) {
                // パーツ内部のセパレータを統一し、先頭と末尾のスラッシュを削除
                const normalizedPart = part.replace(/[/\\]+/g, separator);
                const cleanPart = normalizedPart.replace(/^[/\\]+/, '').replace(/[/\\]+$/, '');
                if (cleanPart) {
                    result += separator + cleanPart;
                }
            }
        }

        return result;
    }

    /**
     * パスからディレクトリハンドルを取得
     */
    async _getDirectoryHandle(path, create = false) {
        // パスを解決してルートハンドルと相対パスを取得
        const resolved = await this._resolvePathAndHandle(path);
        const parts = this._splitPath(resolved.relativePath);
        let currentHandle = resolved.rootHandle;

        for (const part of parts) {
            try {
                currentHandle = await currentHandle.getDirectoryHandle(part, { create });
            } catch (err) {
                if (err.name === 'NotFoundError') {
                    fsAccessLogWarning('FileSystemAccessService._getDirectoryHandle',
                        `Directory not found: ${path}`, {
                        path: path,
                        missingPart: part,
                        create: create
                    });
                    return null;
                }
                fsAccessLogError('FileSystemAccessService._getDirectoryHandle', err, {
                    path: path,
                    currentPart: part,
                    severity: 'HIGH',
                    category: 'FILE_SYSTEM'
                });
                throw err;
            }
        }

        return currentHandle;
    }

    /**
     * パスからファイルハンドルを取得
     */
    async _getFileHandle(path, create = false) {
        // パスを解決してルートハンドルと相対パスを取得
        const resolved = await this._resolvePathAndHandle(path);
        const parts = this._splitPath(resolved.relativePath);

        if (parts.length === 0) {
            const err = new Error('Invalid file path');
            fsAccessLogError('FileSystemAccessService._getFileHandle', err, {
                path: path,
                severity: 'MEDIUM',
                category: 'VALIDATION'
            });
            throw err;
        }

        const fileName = parts.pop();

        // ディレクトリハンドルを取得（相対パスでディレクトリを再構築）
        let currentHandle = resolved.rootHandle;
        for (const part of parts) {
            try {
                currentHandle = await currentHandle.getDirectoryHandle(part, { create });
            } catch (err) {
                if (err.name === 'NotFoundError') {
                    fsAccessLogWarning('FileSystemAccessService._getFileHandle',
                        `Directory not found in path: ${path}`, {
                        path: path,
                        missingPart: part,
                        create: create
                    });
                    return null;
                }
                fsAccessLogError('FileSystemAccessService._getFileHandle', err, {
                    path: path,
                    currentPart: part,
                    severity: 'HIGH',
                    category: 'FILE_SYSTEM'
                });
                throw err;
            }
        }

        try {
            return await currentHandle.getFileHandle(fileName, { create });
        } catch (err) {
            if (err.name === 'NotFoundError') {
                fsAccessLogWarning('FileSystemAccessService._getFileHandle',
                    `File not found: ${path}`, {
                    path: path,
                    fileName: fileName,
                    create: create
                });
                return null;
            }
            fsAccessLogError('FileSystemAccessService._getFileHandle', err, {
                path: path,
                fileName: fileName,
                severity: 'HIGH',
                category: 'FILE_SYSTEM'
            });
            throw err;
        }
    }

    /**
     * ノード(ファイルまたはディレクトリ)が存在するかチェック
     */
    async node_exists(path) {
        try {
            // パスを解決してルートハンドルと相対パスを取得
            const resolved = await this._resolvePathAndHandle(path);
            const parts = this._splitPath(resolved.relativePath);

            if (parts.length === 0) {
                return true; // ルートディレクトリ
            }

            const fileName = parts.pop();

            // 親ディレクトリハンドルを取得
            let currentHandle = resolved.rootHandle;
            for (const part of parts) {
                try {
                    currentHandle = await currentHandle.getDirectoryHandle(part);
                } catch (err) {
                    if (err.name === 'NotFoundError') {
                        return false;
                    }
                    throw err;
                }
            }

            // ファイルまたはディレクトリとして存在するかチェック
            try {
                await currentHandle.getFileHandle(fileName);
                return true;
            } catch (err) {
                if (err.name === 'TypeMismatchError' || err.name === 'NotFoundError') {
                    // ディレクトリとして試す
                    try {
                        await currentHandle.getDirectoryHandle(fileName);
                        return true;
                    } catch (err2) {
                        if (err2.name === 'NotFoundError') {
                            return false;
                        }
                        throw err2;
                    }
                }
                throw err;
            }
        } catch (err) {
            console.error('node_exists error:', err);
            return false;
        }
    }

    /**
     * ノードがディレクトリかどうかチェック
     */
    async node_isDir(path) {
        try {
            const parts = this._splitPath(path);
            if (parts.length === 0) {
                return true; // ルートディレクトリ
            }

            const dirHandle = await this._getDirectoryHandle(path);
            return dirHandle !== null;
        } catch (err) {
            return false;
        }
    }

    /**
     * ディレクトリを作成
     */
    async makeDirectory(path) {
        const handle = await this._getDirectoryHandle(path, true);
        this._emit('change', { type: 'directoryCreated', path });
        return handle;
    }

    /**
     * テキストファイルを読み込み
     */
    async readTextFile(path) {
        try {
            const fileHandle = await this._getFileHandle(path);
            if (!fileHandle) {
                const error = new Error(`File not found: ${path}`);
                error.name = 'NotFoundError';
                fsAccessLogError('FileSystemAccessService.readTextFile', error, {
                    path: path,
                    severity: 'MEDIUM',
                    category: 'NOT_FOUND'
                });
                throw error;
            }

            const file = await fileHandle.getFile();
            const text = await file.text();
            fsAccessLogInfo('FileSystemAccessService.readTextFile', `Successfully read file: ${path}`, {
                path: path,
                size: text.length
            });
            return text;
        } catch (err) {
            // Only log if not already logged
            if (err.name !== 'NotFoundError') {
                fsAccessLogError('FileSystemAccessService.readTextFile', err, {
                    path: path,
                    severity: 'HIGH',
                    category: 'FILE_SYSTEM'
                });
            }
            throw err;
        }
    }

    /**
     * テキストファイルに書き込み
     */
    async writeTextFile(path, data) {
        try {
            const fileHandle = await this._getFileHandle(path, true);
            const writable = await fileHandle.createWritable();
            await writable.write(data);
            await writable.close();

            this._emit('change', { type: 'fileWritten', path });
            fsAccessLogInfo('FileSystemAccessService.writeTextFile', `Successfully wrote file: ${path}`, {
                path: path,
                size: data ? data.length : 0
            });
            return true;
        } catch (err) {
            fsAccessLogError('FileSystemAccessService.writeTextFile', err, {
                path: path,
                dataSize: data ? data.length : 0,
                severity: 'HIGH',
                category: 'FILE_SYSTEM'
            });
            throw err;
        }
    }

    /**
     * テキストファイルに追記
     */
    async appendTextFile(path, data) {
        try {
            // 既存の内容を読み込み
            const existingContent = await this.readTextFile(path);
            // 追記して書き込み
            await this.writeTextFile(path, existingContent + data);
        } catch (err) {
            if (err && err.name === 'NotFoundError') {
                // ファイルが存在しない場合は新規作成
                await this.writeTextFile(path, data);
            } else {
                throw err;
            }
        }

        return true;
    }

    /**
     * 画像ファイルを書き込み
     */
    async writeImageToFile(path, imageData) {
        // imageData は data URL または Blob
        let blob;

        if (typeof imageData === 'string' && imageData.startsWith('data:')) {
            // data URL から Blob に変換
            const response = await fetch(imageData);
            blob = await response.blob();
        } else if (imageData instanceof Blob) {
            blob = imageData;
        } else {
            throw new Error('Invalid image data format');
        }

        const fileHandle = await this._getFileHandle(path, true);
        const writable = await fileHandle.createWritable();
        await writable.write(blob);
        await writable.close();

        this._emit('change', { type: 'fileWritten', path });
        return true;
    }

    /**
     * ディレクトリ内のノード一覧を取得
     */
    async getNodesInDir(path, filter = {}) {
        const dirHandle = await this._getDirectoryHandle(path);
        if (!dirHandle) {
            throw new Error(`Directory not found: ${path}`);
        }

        // フィルタの正規化: 文字列の場合は { pattern: filter } に変換
        // 特殊フィルタ ":is_dir" はディレクトリのみを返す
        let filterObj;
        if (typeof filter === 'string' && filter.length > 0) {
            if (filter === ':is_dir') {
                filterObj = { dirs_only: true };
            } else {
                filterObj = { pattern: filter };
            }
        } else {
            filterObj = filter || {};
        }

        const filesOnly = !!filterObj.files_only;
        const dirsOnly = !!filterObj.dirs_only;
        const regex = filterObj.pattern instanceof RegExp
            ? filterObj.pattern
            : (filterObj.pattern ? globToRegex(filterObj.pattern) : null);

        const nodes = [];

        for await (const [name, handle] of dirHandle.entries()) {
            const isDirectory = handle.kind === 'directory';

            // フィルタ適用
            if (filesOnly && isDirectory) continue;
            if (dirsOnly && !isDirectory) continue;
            if (regex && !regex.test(name)) continue;

            const nodePath = path === '/' ? `/${name}` : `${path}/${name}`;

            nodes.push({
                name,
                path: nodePath,
                isDirectory,
                kind: handle.kind,
                handle
            });
        }

        return nodes;
    }

    /**
     * ファイルまたはディレクトリを削除
     */
    async remove(path) {
        // パスを解決してルートハンドルと相対パスを取得
        const resolved = await this._resolvePathAndHandle(path);
        const parts = this._splitPath(resolved.relativePath);

        if (parts.length === 0) {
            throw new Error('Cannot remove root directory');
        }

        const name = parts.pop();

        // 親ディレクトリハンドルを取得
        let parentHandle = resolved.rootHandle;
        try {
            for (const part of parts) {
                parentHandle = await parentHandle.getDirectoryHandle(part);
            }
        } catch (err) {
            if (err.name === 'NotFoundError') {
                throw new Error(`Parent directory not found: ${path}`);
            }
            throw err;
        }

        await parentHandle.removeEntry(name, { recursive: true });
        this._emit('change', { type: 'nodeRemoved', path });
        return true;
    }

    /**
     * ファイルまたはディレクトリを移動/リネーム
     */
    async moveTo(sourcePath, destPath) {
        // File System Access API には直接的な移動/リネーム機能がないため、
        // コピー → 削除 で実装

        const isDir = await this.node_isDir(sourcePath);

        if (isDir) {
            // ディレクトリの移動
            await this._moveDirectory(sourcePath, destPath);
        } else {
            // ファイルの移動
            await this._moveFile(sourcePath, destPath);
        }

        this._emit('change', { type: 'nodeMoved', from: sourcePath, to: destPath });
        return true;
    }

    async _copyFile(sourcePath, destPath) {
        // バイナリ/テキスト問わず安全にコピー
        const srcHandle = await this._getFileHandle(sourcePath);
        if (!srcHandle) {
            throw new Error(`File not found: ${sourcePath}`);
        }
        const file = await srcHandle.getFile();

        const dstHandle = await this._getFileHandle(destPath, true);
        const writable = await dstHandle.createWritable();
        await writable.write(file);
        await writable.close();
    }

    async _moveFile(sourcePath, destPath) {
        // ファイルをコピーして元を削除
        await this._copyFile(sourcePath, destPath);
        await this.remove(sourcePath);
    }

    async _moveDirectory(sourcePath, destPath) {
        // 再帰的にディレクトリをコピー
        await this.makeDirectory(destPath);

        const nodes = await this.getNodesInDir(sourcePath);

        for (const node of nodes) {
            // パスを適切に結合（Windows/Unix両対応）
            const newPath = this._joinPath(destPath, node.name);

            if (node.isDirectory) {
                await this._moveDirectory(node.path, newPath);
            } else {
                await this._moveFile(node.path, newPath);
            }
        }

        // 元のディレクトリを削除
        await this.remove(sourcePath);
    }

    /**
     * ファイル情報を取得
     */
    async getFileInfo(path) {
        const fileHandle = await this._getFileHandle(path);
        if (!fileHandle) {
            throw new Error(`File not found: ${path}`);
        }

        const file = await fileHandle.getFile();

        return {
            name: file.name,
            size: file.size,
            type: file.type,
            lastModified: file.lastModified,
            lastModifiedDate: new Date(file.lastModified)
        };
    }

    /**
     * イベントハンドラを登録
     */
    on(event, handler) {
        if (!this.eventHandlers[event]) {
            this.eventHandlers[event] = [];
        }
        this.eventHandlers[event].push(handler);

        return () => {
            const index = this.eventHandlers[event].indexOf(handler);
            if (index > -1) {
                this.eventHandlers[event].splice(index, 1);
            }
        };
    }

    /**
     * イベントを発火
     */
    _emit(event, data) {
        if (this.eventHandlers[event]) {
            this.eventHandlers[event].forEach(handler => {
                try {
                    handler(data);
                } catch (err) {
                    console.error(`Error in ${event} handler:`, err);
                }
            });
        }
    }

    /**
     * ルートディレクトリをリセット
     */
    async resetRootDirectory() {
        this.rootHandle = null;
        this.rootPath = null;
        this.ready = false;

        // IndexedDBから削除
        if (this.db) {
            const transaction = this.db.transaction([IDB_STORE_NAME], 'readwrite');
            const store = transaction.objectStore(IDB_STORE_NAME);
            await new Promise((resolve, reject) => {
                const request = store.delete('rootDirectory');
                request.onsuccess = resolve;
                request.onerror = () => reject(request.error);
            });
        }

        this._emit('change', { type: 'rootReset' });
    }

    /**
     * Windowsパスのマッピングを追加
     * ユーザーにディレクトリ選択ダイアログを表示
     */
    async addWindowsPathMapping(windowsPath) {
        if (!this.pathMappingService) {
            throw new Error('Windows path mapping is not enabled');
        }

        return await this.pathMappingService.promptForPath(windowsPath);
    }

    /**
     * Windowsパスのマッピングを削除
     */
    async removeWindowsPathMapping(windowsPath) {
        if (!this.pathMappingService) {
            throw new Error('Windows path mapping is not enabled');
        }

        return await this.pathMappingService.removeMapping(windowsPath);
    }

    /**
     * すべてのWindowsパスマッピングを取得
     */
    getAllWindowsPathMappings() {
        if (!this.pathMappingService) {
            return [];
        }

        return this.pathMappingService.getAllMappings();
    }

    /**
     * すべてのWindowsパスマッピングをクリア
     */
    async clearAllWindowsPathMappings() {
        if (!this.pathMappingService) {
            return;
        }

        return await this.pathMappingService.clearAllMappings();
    }
}

// グローバルインスタンスを作成(シングルトン)
if (typeof window !== 'undefined') {
    window.FileSystemAccessService = FileSystemAccessService;
}

if (typeof module !== 'undefined' && module.exports) {
    module.exports = FileSystemAccessService;
}



======================================================================
FILE PATH: fileView.js
======================================================================
/*
  Copyright © 1992-2021 Progress Software Corporation and/or one of its subsidiaries or affiliates. All rights reserved.
*/

window.addEventListener("DOMContentLoaded", function (event) {
    let bg = chrome.extension.getBackgroundPage();

    document.getElementById('comparison').addEventListener("click", function() {
        bg.link(getRedirFromString("compare-versions"));
    });

    document.getElementById('customer').addEventListener("click", function() {
        bg.link(getRedirFromString("already-customer"));
    });
    
    afio.isInstalled().then(function(installed) {
        if (!installed) {
            document.getElementById('no-file-io-message').removeAttribute("hidden");
            return;
        }
        var msg = document.getElementById('loading_message');
        msg.removeAttribute('hidden');
        TreeView.build();
        msg.setAttribute('hidden', true);
        window.top.onSelectionChanged(TreeView.selectedItem != null);
    }).catch(console.error.bind(console));
    document.body.oncontextmenu = function(e) {
        e.preventDefault()
    }
}, true);


var TreeView = {
    
    // predicate for sorting nodes
    sortPredicate: function(a, b) {
        // string compare function to sort nodes
        var node_compare = function (a, b) {

            //directories go first
            if (a.is_dir && !b.is_dir) {
                return -1;
            } else if (b.is_dir && !a.is_dir) {
                return 1;
            }

            var la = a.leafName.toLowerCase(),
                lb = b.leafName.toLowerCase();
            var bound = Math.min(la.length, lb.length);
            for (var i = 0; i < bound; i++) {
                var l = la.charAt(i), r = lb.charAt(i), x;
                if (l == r)
                    continue;
                // '#'-symbol preceeds others
                if (l == "#")
                    return -1;
                else if (r == "#")
                    return 1;
                else if (x = l.localeCompare(r))
                    return x;
            }
            return la.length - lb.length; // longer string is greater
        };
        if (a.is_dir && !b.is_dir) {
	    return -1; 		// a dir always preceeds a file
        } else if (!a.is_dir && b.is_dir) {
	    return 1;
        } else {
	    return node_compare(a, b);
        }
    },

    // build tree from iMacros Macros folder
    build: function () {

        function selectMacroForPlayButton(id, name) {
            var div = document.getElementById("imacros-bookmark-div");
            if (div.hasAttribute("bookmark_id"))
                div.removeAttribute("bookmark_id");
            div.setAttribute("file_id", id);
            div.setAttribute("name", name);
        }

        let onEdit = function () { window.top.edit(); }
        let onConvert =  function () { window.top.convert(); }
        let onNewFolder = function () {
	    var item = TreeView.selectedItem;
	    var node = afio.openNode(item.id);
	    
	    if (item.type != "folder")
		node = node.parent;
	    
            var _makedir_checkname = function(count, node, name) {
                var dir = node.clone();
                dir.append(name+" ("+count+")");
                dir.exists().then(function(exists) {
                    if (exists) {
                        return _makedir_checkname(++count, node, name);
                    } else {
                        return afio.makeDirectory(dir).then(function() {
                            return jQuery('#jstree').jstree(true).refresh();
                        });
                    }
                }).catch(console.error.bind(console));
            };

            var new_name = prompt("Enter new folder name", "New folder");

            var dir = node.clone();
	    dir.append(new_name);
	    return dir.exists().then(function(exists) {
		if (exists) {
		    return _makedir_checkname(1, node, new_name);
		} else {
		    return afio.makeDirectory(dir).then(function(err) {
			return jQuery('#jstree').jstree(true).refresh();
		    });
		}
	    });
        }

        let onRename = function () {
            var item = TreeView.selectedItem;

            if (!item) {
                alert("Error: no item selected"); // should never happen
                return;
            }

            var old_name = item.text;
            var new_name = prompt("Enter new name", old_name);
            if (!new_name)
                return;
            if (item.type != "folder" && !isMacroFile(new_name))
                new_name += ".iim";
            var node = afio.openNode(item.id);
            var new_node = node.parent;
            new_node.append(new_name);
	    
            node.moveTo(new_node).then(function() {
                
                jQuery('#jstree').jstree(true).refresh();
		
                if (item.type == "macro") {
                    TreeView.selectedItem.id = new_node.path;
                    TreeView.selectedItem.text = new_name;
                    selectMacroForPlayButton(new_node.path, new_name);
                }
            }).catch(console.error.bind(console));
        }

        let onRemove = function () {
            var item = TreeView.selectedItem;
            if (!item) {
                alert("Error: no item selected");
                return;
            }
            if (!item.id) {
                alert("Can not delete " + item.type + " " + item.text);
                return;
            }
            var yes = confirm("Are you sure you want to remove " + item.type + " "+
                              item.text + "?");
            if (!yes)
                return;

            var node = afio.openNode(item.id);
            node.remove().then(function() {
                jQuery('#jstree').jstree(true).refresh();
                TreeView.selectedItem = null;
                selectMacroForPlayButton('', '');
            }).catch(console.error.bind(console));
        }
        let onRefreshTree = function () {
            jQuery('#jstree').jstree(true).refresh();
        }

        function customMenu(node) {
            TreeView.selectedItem = node.original;

            var items = {
                'Edit': {
                    'label': 'Edit',
                    'action': onEdit
                },
                'Convert': {
                    'label': 'Convert',
                    'action': onConvert
                },
                'New Folder': {
                    'label': 'New Folder',
                    'action': onNewFolder
                },
                'Rename': {
                    'label': 'Rename',
                    'action': onRename
                },
                'Remove': {
                    'label': 'Remove',
                    'action': onRemove
                },
                'Refresh Tree': {
                    'label': 'Refresh Tree',
                    'action': onRefreshTree
                }
            }

            if (node.type === 'folder') {
                delete items.Edit;
                delete items.Convert;
            }

            return items;
        };

        jQuery('#jstree').jstree({
            'core': {
                "check_callback": function (operation, node, parent, position, more) {
                    if (more.dnd && operation === "move_node") {
                        if(parent.id === "#") {
                            return false; // prevent moving a child above or below the root
                        }
                    }

                    return true; // allow everything else
                },

                'data': function(node, cb) { getNodes(node, cb); }
            },
            'types': {
                'folder': {
                    
                },
                "macro": {
                    'icon': 'X'//'/skin/imglog.png'
                }
            },
            'contextmenu': {
                'items': customMenu
            },
            'plugins': ['state', 'dnd', 'types', 'contextmenu', 'wholerow']
        });

        jQuery(document).on('dnd_stop.vakata', function (e, data) {
            var src = afio.openNode(data.element.parentElement.id);
            var dst = afio.openNode(data.event.target.parentElement.id);

            dst.isDir().then(function(is_dir) {
                dst = is_dir ? dst : dst.parent;
		dst.path = dst._path = dst._path + __psep() + src.leafName;
                return src.moveTo(dst);
            }).then(function() {
                return jQuery('#jstree').jstree(true).refresh();
            }).catch(function(e) {
                console.error.bind(console);

                if (e && e.message) {
                    alert(e.message);
                }
                
                return jQuery('#jstree').jstree(true).refresh();
            });

            return false;
        });

        jQuery('#jstree').on('select_node.jstree', function (e, data) {
            TreeView.selectedItem = data.node;
            if (data.node.type == 'macro') {
                TreeView.selectedItem.type = "macro";
                selectMacroForPlayButton(data.node.id, data.node.text);
                window.top.onSelectionChanged(true);
                e.preventDefault();
                e.stopPropagation();
            }
            //folder
            else {
                TreeView.selectedItem.type = "folder";
                window.top.onSelectionChanged(false);
            }
        });

        jQuery('#jstree').on('dblclick.jstree', function (e, data) {
            
            var target_node = jQuery('#jstree').jstree(true).get_node(e.target.parentElement.id);
            
            if (target_node.type == 'macro') {
                setTimeout(function () { window.top.play(); }, 200);
            }
        });

        jQuery('#jstree').on("loaded.jstree", function (event, data) {
            openFirstNode();
        })
	
	jQuery('#jstree').on("show_contextmenu.jstree", function (event, data) {
	    
	    var currentOffsetTop = $('.jstree-contextmenu').position().top - $(window).scrollTop();
	    var menuHeight = $('.jstree-contextmenu').height() + 10;
	    var tooLowBy = $(window.frameElement.parentElement).height() - (currentOffsetTop + menuHeight);
	    
	    if(tooLowBy < 0) {
		
		var newPosition = currentOffsetTop + tooLowBy + $(window).scrollTop();
		$('.jstree-contextmenu').offset( { top: newPosition })
	    }
        })

        jQuery('#jstree').on('refresh.jstree', function (e, data) {
            openFirstNode();
        });

        function openFirstNode() {
            jQuery('#jstree').jstree("open_node", "ul > li:first");
        }

        function getNodes(node, cb) {
	    
            var data_obj;
	    
            if(node.id === "#") {
		
                afio.getDefaultDir("savepath").then(function(savepath) {
                    var root_node = savepath;

                    data_obj = createNode(root_node.leafName, root_node.path, 'folder', true);
                    data_obj.children = getChildren(root_node, data_obj, cb);
                }).catch(console.error.bind(console));
            }
            else {
                getChildren(afio.openNode(node.id), data_obj, cb);
            }
        }

        function getChildren(root_node, data_obj, cb) {

            afio.getNodesInDir(root_node)
                .then(function(nodes) {
                    // We need to sort array
                    nodes.sort(TreeView.sortPredicate);

                    var children = new Array();
		    
                    for (var x of nodes) {
                        if (isMacroFile(x.path)) {
                            children.push(createNode(x.leafName, x.path, 'macro', false));
                        } else if (x.is_dir){
                            children.push(createNode(x.leafName, x.path, 'folder', true));
                        }
                    }
		    
                    if(data_obj && children.length) {
                        data_obj.children = children;
                        cb(data_obj);
                    } else if(children.length) {
                        cb(children);
                    } else if(data_obj) {
                        cb([data_obj]);
                    } else {
                        cb([]);
                    }
                }).catch(console.error.bind(console));
        }

        function createNode(text, id, type, hasChildren) {
            return {'text': text, 'id': id, 'type': type, 'children': hasChildren };
        }
    }
};



======================================================================
FILE PATH: folderView.js
======================================================================
/*
Copyright © 1992-2021 Progress Software Corporation and/or one of its subsidiaries or affiliates. All rights reserved.
*/

window.addEventListener("load", function (event) {
    afio.isInstalled().then(function(installed) {
        if (!installed) {
            document.body.innerHTML = "<p style='color:red'>"+
                "Install file access support first"+
                "</p>";
        } else {
            TreeView.build(window.top.args ? window.top.args.path : null);
        }
    });
}, true);

var TreeView = {
    
    // predicate for sorting nodes
    sortPredicate: function(a, b) {
        // string compare function to sort nodes
        var node_compare = function (a, b) {
            var la = a.leafName.toLowerCase(),
                lb = b.leafName.toLowerCase();
            var bound = Math.min(la.length, lb.length);

            for (var i = 0; i < bound; i++) {
                var l = la.charAt(i), r = lb.charAt(i), x;
                if (l == r)
                    continue;
                if (x = l.localeCompare(r))
                    return x;
            }

            return la.length - lb.length; // longer string is greater
        };

        return node_compare(a, b);
    },

    // build tree from iMacros bookmarks folder
    build: function (root) {
        jQuery('#jstree').jstree({
            'core': {
                'data': function(node, cb) { getNodes(node, cb); }
            },
            'plugins': ['wholerow']
        });

        jQuery('#jstree').on("changed.jstree", function (e, data) {

            document.getElementById("path").value = data.selected;
        });
        
        jQuery('#jstree').on("loaded.jstree", function (event, data) {
            selectFirstNode();
        })

        jQuery('#jstree').on('dblclick.jstree', function (e, data) {
                
            var target_node = jQuery('#jstree').jstree(true).get_node(e.target.id);
                
            if (target_node.text == '..') {
                root = target_node.id;
                jQuery('#jstree').jstree(true).refresh();
            }
        });

        jQuery('#jstree').on('refresh.jstree', function (e, data) {
            selectFirstNode();
        });

        function selectFirstNode() {
            jQuery('#jstree').jstree("select_node", "ul > li:first");
            jQuery('#jstree').jstree("open_node", "ul > li:first");
        }

        function getNodes(node, cb) {
	
            var data_obj;
	
            if(node.id === "#") {
		
                if (root == "My Computer") {

                    data_obj = createNode('My Computer', '', 'computer');

                    afio.getLogicalDrives().then(function(drives) {
                        data_obj.children = new Array();
				
                        for (var i = 0; i < drives.length; i++) {

                            var drive_caption = drives[i].path+
                                                (drives[i].path[drives[i].path.length-1] == __psep() ?
                                                 "": __psep());
					
                            data_obj.children[i] = createNode(drive_caption, drives[i].path, 'drive');
                        }

                        cb([data_obj]);
                    }).catch(console.error.bind(console));
                } else {
                    afio.getDefaultDir("savepath").then(function(savepath) {
                        var root_node = root ? afio.openNode(root) : savepath;

                        // make "Up" element first
                        var parent_path = /^[A-Z]:\\?$/.test(root) ?
                            '' : root_node.parent.path; //using empty string for 'My Computer' so that its not seen as a selection by browse.js

                        data_obj = createNode('..', parent_path, 'folder');
                        data_obj.children = getSubDirs(root_node, data_obj, cb);
                    }).catch(console.error.bind(console));
                }
            }
            else {
                getSubDirs(afio.openNode(node.id), data_obj, cb);
            }
        }

        function getSubDirs(root_node, data_obj, cb) {

            afio.getNodesInDir(root_node, ":is_dir")
            .then(function(nodes) {
                // We need to sort array
                nodes.sort(TreeView.sortPredicate);

                var subDirs = new Array();
		
                for (var x of nodes) {
                    subDirs.push(createNode(x.leafName, x.path, 'folder'));
            }
		
                if(data_obj && subDirs.length) {
                    data_obj.children = subDirs;
                    cb(data_obj);
                } else if(subDirs.length) {
                    cb(subDirs);
                } else if(data_obj) {
                    cb([data_obj]);
                } else {
                    cb([]);
                }
            }).catch(console.error.bind(console));
        }

        function createNode(text, id, type) {
            return {'text': text, 'id': id, 'type': type, 'children': true };
        }
    }
};



======================================================================
FILE PATH: GlobalErrorLogger.js
======================================================================
/**
 * GlobalErrorLogger.js
 *
 * 全てのJSファイルで使用できる統一されたエラーロギングシステム
 * すべてのエラーを収集し、ファイル、行番号、スタックトレースを記録
 *
 * 使用方法:
 * 1. 各JSファイルの先頭でこのファイルを読み込む
 * 2. try-catchブロックでGlobalErrorLogger.logError()を呼び出す
 * 3. GlobalErrorLogger.getReport()でレポートを取得
 */

(function (global) {
    'use strict';

    // Normalize the global reference for reuse throughout this module
    const globalScope = global;

    // エラーカテゴリ定数
    const ERROR_CATEGORIES = {
        FILE_SYSTEM: 'FILE_SYSTEM',
        PERMISSION: 'PERMISSION',
        INDEXEDDB: 'INDEXEDDB',
        PATH_MAPPING: 'PATH_MAPPING',
        PATH_RESOLUTION: 'PATH_RESOLUTION',
        NATIVE_MESSAGING: 'NATIVE_MESSAGING',
        INITIALIZATION: 'INITIALIZATION',
        NOT_FOUND: 'NOT_FOUND',
        QUOTA: 'QUOTA',
        VALIDATION: 'VALIDATION',
        ASYNC_OPERATION: 'ASYNC_OPERATION',
        NETWORK: 'NETWORK',
        BROWSER_API: 'BROWSER_API',
        UNKNOWN: 'UNKNOWN'
    };

    // エラー重要度レベル
    const SEVERITY_LEVELS = {
        CRITICAL: 'CRITICAL',  // システムが動作しない
        HIGH: 'HIGH',          // 主要機能が動作しない
        MEDIUM: 'MEDIUM',      // 一部機能に影響
        LOW: 'LOW',            // 軽微な問題
        INFO: 'INFO'           // 情報のみ
    };

    // ファイル操作エラーコード
    const FILE_ERROR_CODES = {
        FILE_BACKEND_ERROR: 'FILE_BACKEND_ERROR',
        FILE_TIMEOUT_ERROR: 'FILE_TIMEOUT_ERROR',
        FILE_PATH_INVALID: 'FILE_PATH_INVALID',
        FILE_READ_ERROR: 'FILE_READ_ERROR',
        FILE_WRITE_ERROR: 'FILE_WRITE_ERROR'
    };

    // ファイル操作エラーのデフォルト重要度
    const FILE_ERROR_SEVERITY = {
        [FILE_ERROR_CODES.FILE_BACKEND_ERROR]: SEVERITY_LEVELS.HIGH,
        [FILE_ERROR_CODES.FILE_TIMEOUT_ERROR]: SEVERITY_LEVELS.MEDIUM,
        [FILE_ERROR_CODES.FILE_PATH_INVALID]: SEVERITY_LEVELS.MEDIUM,
        [FILE_ERROR_CODES.FILE_READ_ERROR]: SEVERITY_LEVELS.HIGH,
        [FILE_ERROR_CODES.FILE_WRITE_ERROR]: SEVERITY_LEVELS.HIGH
    };

    // ループ処理エラーコード（後方互換のために保持）
    const LOOP_ERROR_CODES = {
        LOOP_INFINITE: 'LOOP_INFINITE',
        LOOP_MAX_ITERATIONS: 'LOOP_MAX_ITERATIONS',
        LOOP_BREAK: 'LOOP_BREAK'
    };

    const LOOP_ERROR_SEVERITY = {
        [LOOP_ERROR_CODES.LOOP_INFINITE]: SEVERITY_LEVELS.HIGH,
        [LOOP_ERROR_CODES.LOOP_MAX_ITERATIONS]: SEVERITY_LEVELS.MEDIUM,
        [LOOP_ERROR_CODES.LOOP_BREAK]: SEVERITY_LEVELS.LOW
    };

    // クリップボード操作エラーコード（後方互換のために保持）
    const CLIPBOARD_ERROR_CODES = {
        CLIPBOARD_READ_ERROR: 'CLIPBOARD_READ_ERROR',
        CLIPBOARD_WRITE_ERROR: 'CLIPBOARD_WRITE_ERROR',
        CLIPBOARD_PERMISSION_DENIED: 'CLIPBOARD_PERMISSION_DENIED'
    };

    const CLIPBOARD_ERROR_SEVERITY = {
        [CLIPBOARD_ERROR_CODES.CLIPBOARD_READ_ERROR]: SEVERITY_LEVELS.MEDIUM,
        [CLIPBOARD_ERROR_CODES.CLIPBOARD_WRITE_ERROR]: SEVERITY_LEVELS.MEDIUM,
        [CLIPBOARD_ERROR_CODES.CLIPBOARD_PERMISSION_DENIED]: SEVERITY_LEVELS.HIGH
    };

    class GlobalErrorLogger {
        constructor(options = {}) {
            this.errors = [];
            this.warnings = [];
            this.infos = [];
            this.enabled = true;
            this.maxErrors = 1000; // メモリ管理のため上限を設定
            this.startTime = Date.now();
            this.sessionId = this._generateSessionId();

            // クリティカルエラー保存のためのキュー（競合状態を防ぐ）
            this.criticalErrorQueue = Promise.resolve();

            // グローバルエラーハンドラを設定（オプショナル）
            // errorLogger.js との重複を避けるため、デフォルトは無効
            // テストなどで有効化したい場合は { setupGlobalHandlers: true } を渡す
            this.setupGlobalHandlers = options.setupGlobalHandlers === true;
            if (this.setupGlobalHandlers) {
                this._setupGlobalHandlers();
            }
        }

        /**
         * セッションIDを生成
         */
        _generateSessionId() {
            return `session_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;
        }

        /**
         * グローバルエラーハンドラを設定
         */
        _setupGlobalHandlers() {
            // 未処理のエラーをキャッチ
            if (typeof window !== 'undefined') {
                window.addEventListener('error', (event) => {
                    this.logError(
                        'UNCAUGHT_ERROR',
                        event.error || new Error(event.message),
                        {
                            filename: event.filename,
                            lineno: event.lineno,
                            colno: event.colno,
                            severity: SEVERITY_LEVELS.HIGH
                        }
                    );
                });

                // 未処理のPromise rejectionsをキャッチ
                window.addEventListener('unhandledrejection', (event) => {
                    this.logError(
                        'UNHANDLED_REJECTION',
                        event.reason instanceof Error ? event.reason : new Error(String(event.reason)),
                        {
                            promise: 'Promise rejection',
                            severity: SEVERITY_LEVELS.HIGH
                        }
                    );
                });
            }
        }

        /**
         * エラーを記録
         *
         * @param {string} context - エラーが発生したコンテキスト（関数名、モジュール名など）
         * @param {Error|string} error - エラーオブジェクトまたはメッセージ
         * @param {Object} details - 追加詳細情報
         */
        logError(context, error, details = {}) {
            if (!this.enabled) return;

            const isError = error instanceof Error;
            const errorObj = isError ? error : new Error(String(error));

            // For Error instances, use skipFrames=1 to get the actual throw site
            // For string messages, use skipFrames=2 to skip both Error() and logError()
            // If called via static wrapper, skip one more frame
            let location;
            const extraSkip = details._skipExtraFrame ? 1 : 0;

            if (isError && errorObj.stack) {
                // If it's an error object, the stack is already fixed at creation time.
                // We don't need to skip wrapper frames.
                location = this._parseStackLocation(errorObj.stack, 1);
            } else {
                const syntheticError = new Error();
                location = this._parseStackLocation(syntheticError.stack, 2 + extraSkip);
            }

            // Clean up internal flag
            if (details._skipExtraFrame) {
                delete details._skipExtraFrame;
            }

            const category = this._categorizeError(errorObj.message, details);
            const severity = details.severity || this._determineSeverity(errorObj.message, details);

            const errorEntry = {
                timestamp: new Date().toISOString(),
                timestampMs: Date.now(),
                sessionId: this.sessionId,
                context: context,
                message: errorObj.message || String(error),
                stack: errorObj.stack || new Error().stack,
                file: location.file,
                line: location.line,
                column: location.column,
                category: category,
                severity: severity,
                details: details,
                type: 'ERROR',
                userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : 'unknown',
                url: typeof window !== 'undefined' ? window.location.href : 'unknown'
            };

            this.errors.push(errorEntry);
            this._maintainErrorLimit();

            // コンソールに出力
            console.error(`[GlobalErrorLogger] ${severity} - ${context}:`, errorObj);
            if (Object.keys(details).length > 0) {
                console.error('Details:', details);
            }
            console.error('Location:', `${location.file}:${location.line}:${location.column}`);

            // クリティカルエラーの場合は特別な処理
            if (severity === SEVERITY_LEVELS.CRITICAL) {
                this._handleCriticalError(errorEntry);
            }

            return errorEntry;
        }

        /**
         * クリティカルエラーを記録
         */
        logCritical(context, error, details = {}) {
            const severity = details.severity || SEVERITY_LEVELS.CRITICAL;
            return this.logError(context, error, { ...details, severity });
        }

        /**
         * 警告を記録
         */
        logWarning(context, message, details = {}) {
            if (!this.enabled) return;

            const stack = new Error().stack;
            const extraSkip = details._skipExtraFrame ? 1 : 0;
            // Skip 2 frames: "Error" line and "at GlobalErrorLogger.logWarning" line
            const location = this._parseStackLocation(stack, 2 + extraSkip);

            // Clean up internal flag
            if (details._skipExtraFrame) {
                delete details._skipExtraFrame;
            }

            const warningEntry = {
                timestamp: new Date().toISOString(),
                timestampMs: Date.now(),
                sessionId: this.sessionId,
                context: context,
                message: message,
                file: location.file,
                line: location.line,
                column: location.column,
                details: details,
                type: 'WARNING'
            };

            this.warnings.push(warningEntry);
            this._maintainWarningLimit();

            console.warn(`[GlobalErrorLogger] WARNING - ${context}:`, message);
            if (Object.keys(details).length > 0) {
                console.warn('Details:', details);
            }

            return warningEntry;
        }

        /**
         * 情報を記録
         */
        logInfo(context, message, details = {}) {
            if (!this.enabled) return;

            const stack = new Error().stack;
            const extraSkip = details._skipExtraFrame ? 1 : 0;
            // Skip 2 frames: "Error" line and "at GlobalErrorLogger.logInfo" line
            const location = this._parseStackLocation(stack, 2 + extraSkip);

            // Clean up internal flag
            if (details._skipExtraFrame) {
                delete details._skipExtraFrame;
            }

            const infoEntry = {
                timestamp: new Date().toISOString(),
                timestampMs: Date.now(),
                sessionId: this.sessionId,
                context: context,
                message: message,
                file: location.file,
                line: location.line,
                column: location.column,
                details: details,
                type: 'INFO'
            };

            this.infos.push(infoEntry);
            this._maintainInfoLimit();

            console.info(`[GlobalErrorLogger] INFO - ${context}:`, message);

            return infoEntry;
        }

        /**
         * ファイル操作のエラーを記録（後方互換ラッパー）
         */
        logFileError(context, error, details = {}) {
            const errorCode = details.errorCode || FILE_ERROR_CODES.FILE_BACKEND_ERROR;
            const severity = details.severity || FILE_ERROR_SEVERITY[errorCode] || SEVERITY_LEVELS.MEDIUM;
            const mergedDetails = {
                ...details,
                errorCode,
                severity,
                category: details.category || ERROR_CATEGORIES.FILE_SYSTEM,
                _skipExtraFrame: details._skipExtraFrame ?? true
            };
            return this.logError(context, error, mergedDetails);
        }

        /**
         * ループ処理のエラーを記録（後方互換ラッパー）
         */
        logLoopError(context, error, details = {}) {
            const errorCode = details.errorCode || LOOP_ERROR_CODES.LOOP_INFINITE;
            const severity = details.severity || LOOP_ERROR_SEVERITY[errorCode] || SEVERITY_LEVELS.MEDIUM;
            const mergedDetails = {
                ...details,
                errorCode,
                severity,
                category: details.category || ERROR_CATEGORIES.ASYNC_OPERATION,
                _skipExtraFrame: details._skipExtraFrame ?? true
            };
            return this.logError(context, error, mergedDetails);
        }

        /**
         * クリップボード操作のエラーを記録（後方互換ラッパー）
         */
        logClipboardError(context, error, details = {}) {
            const errorCode = details.errorCode || CLIPBOARD_ERROR_CODES.CLIPBOARD_READ_ERROR;
            const severity = details.severity || CLIPBOARD_ERROR_SEVERITY[errorCode] || SEVERITY_LEVELS.MEDIUM;
            const mergedDetails = {
                ...details,
                errorCode,
                severity,
                category: details.category || ERROR_CATEGORIES.BROWSER_API,
                _skipExtraFrame: details._skipExtraFrame ?? true
            };
            return this.logError(context, error, mergedDetails);
        }

        /**
         * スタックトレースから位置情報を解析
         * @param {string} stack - スタックトレース文字列
         * @param {number} skipFrames - スキップするフレーム数（デフォルト1）
         */
        _parseStackLocation(stack, skipFrames = 1) {
            const fallback = { file: 'unknown', line: 0, column: 0 };

            if (!stack) return fallback;

            const lines = stack.toString().split(/\r?\n/);

            // 指定されたフレーム数をスキップして実際の呼び出し元を取得
            for (let i = skipFrames; i < lines.length; i++) {
                const line = lines[i];

                // Chrome/Edge形式: "at functionName (file:line:column)" または "at file:line:column"
                // greedy マッチングで `:` を含む URL も正しくパース
                let match = line.match(/at\s+(?:.*?\s+\()?(.+):(\d+):(\d+)/);

                // Firefox形式: "functionName@file:line:column"
                if (!match) {
                    match = line.match(/([^@\s]+)@(.+):(\d+):(\d+)/);
                    if (match) {
                        match = [null, match[2], match[3], match[4]];
                    }
                }

                if (match && match[1]) {
                    // ファイルパスをクリーンアップ
                    let filePath = match[1];

                    // URLからファイル名のみを抽出
                    const fileNameMatch = filePath.match(/([^/\\]+)$/);
                    if (fileNameMatch) {
                        filePath = fileNameMatch[1];
                    }

                    return {
                        file: filePath,
                        line: parseInt(match[2], 10) || 0,
                        column: parseInt(match[3], 10) || 0
                    };
                }
            }

            return fallback;
        }

        /**
         * エラーメッセージからカテゴリを判定
         */
        _categorizeError(message, details = {}) {
            const msgLower = (message || '').toLowerCase();

            if (details.category) return details.category;

            if (msgLower.includes('file system access') || msgLower.includes('filesystem')) {
                return ERROR_CATEGORIES.FILE_SYSTEM;
            }
            if (msgLower.includes('permission') || msgLower.includes('denied')) {
                return ERROR_CATEGORIES.PERMISSION;
            }
            if (msgLower.includes('indexeddb') || msgLower.includes('idb')) {
                return ERROR_CATEGORIES.INDEXEDDB;
            }
            if (msgLower.includes('path mapping') || msgLower.includes('windows path')) {
                return ERROR_CATEGORIES.PATH_MAPPING;
            }
            if (msgLower.includes('resolve') || msgLower.includes('path')) {
                return ERROR_CATEGORIES.PATH_RESOLUTION;
            }
            if (msgLower.includes('native') || msgLower.includes('messaging')) {
                return ERROR_CATEGORIES.NATIVE_MESSAGING;
            }
            if (msgLower.includes('init') || msgLower.includes('initialization')) {
                return ERROR_CATEGORIES.INITIALIZATION;
            }
            if (msgLower.includes('not found') || msgLower.includes('does not exist')) {
                return ERROR_CATEGORIES.NOT_FOUND;
            }
            if (msgLower.includes('quota') || msgLower.includes('storage')) {
                return ERROR_CATEGORIES.QUOTA;
            }
            if (msgLower.includes('invalid') || msgLower.includes('validation')) {
                return ERROR_CATEGORIES.VALIDATION;
            }
            if (msgLower.includes('timeout') || msgLower.includes('async')) {
                return ERROR_CATEGORIES.ASYNC_OPERATION;
            }
            if (msgLower.includes('network') || msgLower.includes('fetch')) {
                return ERROR_CATEGORIES.NETWORK;
            }
            if (msgLower.includes('browser') || msgLower.includes('api')) {
                return ERROR_CATEGORIES.BROWSER_API;
            }

            return ERROR_CATEGORIES.UNKNOWN;
        }

        /**
         * エラーの重要度を判定
         */
        _determineSeverity(message, details = {}) {
            const msgLower = (message || '').toLowerCase();

            // クリティカル: システムが初期化できない、主要機能が完全に動作しない
            if (msgLower.includes('critical') ||
                msgLower.includes('fatal') ||
                msgLower.includes('cannot initialize') ||
                (msgLower.includes('not supported') && msgLower.includes('browser'))) {
                return SEVERITY_LEVELS.CRITICAL;
            }

            // 高: 主要機能に影響
            if (msgLower.includes('permission denied') ||
                msgLower.includes('access denied') ||
                msgLower.includes('initialization failed') ||
                msgLower.includes('quota exceeded')) {
                return SEVERITY_LEVELS.HIGH;
            }

            // 中: 一部機能に影響
            if (msgLower.includes('not found') ||
                msgLower.includes('timeout') ||
                msgLower.includes('invalid')) {
                return SEVERITY_LEVELS.MEDIUM;
            }

            // 低: 軽微な問題
            if (msgLower.includes('warning') ||
                msgLower.includes('deprecated')) {
                return SEVERITY_LEVELS.LOW;
            }

            return SEVERITY_LEVELS.MEDIUM; // デフォルト
        }

        /**
         * クリティカルエラーの特別処理
         */
        async _handleCriticalError(errorEntry) {
            // クリティカルエラーの保存をキューに追加（競合状態を防ぐ）
            // 以前の保存が失敗しても次の保存を継続する
            this.criticalErrorQueue = this.criticalErrorQueue
                .catch(() => { }) // 以前のエラーを無視
                .then(() => this._saveCriticalError(errorEntry));

            // ユーザーに即座に通知（保存を待たない）
            console.error('*'.repeat(80));
            console.error('CRITICAL ERROR DETECTED:');
            console.error(`Context: ${errorEntry.context}`);
            console.error(`Message: ${errorEntry.message}`);
            console.error(`Location: ${errorEntry.file}:${errorEntry.line}`);
            console.error('*'.repeat(80));
        }

        /**
         * クリティカルエラーを保存（キューで直列化）
         */
        async _saveCriticalError(errorEntry) {
            try {
                let criticalErrors = [];

                // 既存のクリティカルエラーを取得
                if (typeof chrome !== 'undefined' && chrome.storage && chrome.storage.local) {
                    const result = await new Promise(resolve => {
                        chrome.storage.local.get(['critical_errors'], resolve);
                    });
                    if (result.critical_errors && Array.isArray(result.critical_errors)) {
                        criticalErrors = result.critical_errors;
                    }
                } else if (typeof localStorage !== 'undefined') {
                    try {
                        const stored = localStorage.getItem('critical_errors');
                        if (stored) {
                            criticalErrors = JSON.parse(stored);
                        }
                    } catch (e) {
                        // パース失敗時は空配列から開始
                    }
                }

                // 新しいエラーを追加（最新100件のみ保持）
                criticalErrors.push(errorEntry);
                if (criticalErrors.length > 100) {
                    criticalErrors = criticalErrors.slice(-100);
                }

                // 保存
                await this._persistToStorage('critical_errors', criticalErrors);
            } catch (err) {
                console.error('Failed to persist critical error:', err);
            }
        }

        /**
         * エラー数の上限を維持
         */
        _maintainErrorLimit() {
            if (this.errors.length > this.maxErrors) {
                this.errors = this.errors.slice(-this.maxErrors);
            }
        }

        _maintainWarningLimit() {
            if (this.warnings.length > this.maxErrors) {
                this.warnings = this.warnings.slice(-this.maxErrors);
            }
        }

        _maintainInfoLimit() {
            if (this.infos.length > this.maxErrors) {
                this.infos = this.infos.slice(-this.maxErrors);
            }
        }

        /**
         * 包括的なレポートを取得
         */
        getReport() {
            return {
                sessionId: this.sessionId,
                sessionDuration: Date.now() - this.startTime,
                totalErrors: this.errors.length,
                totalWarnings: this.warnings.length,
                totalInfos: this.infos.length,
                errors: this.errors,
                warnings: this.warnings,
                infos: this.infos,
                summary: this._getSummary(),
                environment: this._getEnvironment()
            };
        }

        /**
         * サマリーを生成
         */
        _getSummary() {
            const summary = {
                errorsByContext: {},
                errorsByCategory: {},
                errorsBySeverity: {},
                errorsByFile: {},
                recentErrors: this.errors.slice(-10),
                criticalErrors: this.errors.filter(e => e.severity === SEVERITY_LEVELS.CRITICAL),
                highSeverityErrors: this.errors.filter(e => e.severity === SEVERITY_LEVELS.HIGH)
            };

            this.errors.forEach(err => {
                // コンテキスト別
                summary.errorsByContext[err.context] =
                    (summary.errorsByContext[err.context] || 0) + 1;

                // カテゴリ別
                summary.errorsByCategory[err.category] =
                    (summary.errorsByCategory[err.category] || 0) + 1;

                // 重要度別
                summary.errorsBySeverity[err.severity] =
                    (summary.errorsBySeverity[err.severity] || 0) + 1;

                // ファイル別
                summary.errorsByFile[err.file] =
                    (summary.errorsByFile[err.file] || 0) + 1;
            });

            return summary;
        }

        /**
         * 環境情報を取得
         */
        _getEnvironment() {
            const env = {
                timestamp: new Date().toISOString(),
                platform: typeof navigator !== 'undefined' ? navigator.platform : 'unknown',
                userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : 'unknown',
                language: typeof navigator !== 'undefined' ? navigator.language : 'unknown',
                url: typeof window !== 'undefined' ? window.location.href : 'unknown',
                screen: typeof window !== 'undefined' ? {
                    width: window.screen.width,
                    height: window.screen.height
                } : null
            };

            // File System Access API サポート
            if (typeof window !== 'undefined') {
                env.fileSystemAccessSupported = 'showDirectoryPicker' in window;
            }

            // Chrome情報
            if (typeof chrome !== 'undefined' && chrome.runtime) {
                env.extensionId = chrome.runtime.id;
                env.extensionVersion = chrome.runtime.getManifest ? chrome.runtime.getManifest().version : 'unknown';
            }

            return env;
        }

        /**
         * レポートをJSON形式でエクスポート
         */
        exportReport() {
            const report = this.getReport();

            // Check if DOM is available (won't work in background scripts/Service Workers)
            if (typeof document === 'undefined') {
                console.warn('exportReport: DOM not available. Use getReport() to retrieve data manually.');
                console.log('Error Report JSON:', JSON.stringify(report, null, 2));
                return report;
            }

            try {
                const blob = new Blob([JSON.stringify(report, null, 2)], {
                    type: 'application/json'
                });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `error_report_${this.sessionId}_${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                return report;
            } catch (err) {
                console.error('Failed to export report:', err);
                console.log('Error Report JSON:', JSON.stringify(report, null, 2));
                return report;
            }
        }

        /**
         * レポートをコンソールに出力
         */
        printReport() {
            const report = this.getReport();

            console.log('\n' + '='.repeat(80));
            console.log('GLOBAL ERROR LOGGER REPORT');
            console.log('='.repeat(80));
            console.log(`Session ID: ${report.sessionId}`);
            console.log(`Session Duration: ${(report.sessionDuration / 1000).toFixed(2)}s`);
            console.log(`Total Errors: ${report.totalErrors}`);
            console.log(`Total Warnings: ${report.totalWarnings}`);
            console.log(`Total Infos: ${report.totalInfos}`);
            console.log('='.repeat(80));

            if (report.summary.criticalErrors.length > 0) {
                console.log('\nCRITICAL ERRORS:');
                report.summary.criticalErrors.forEach((err, i) => {
                    console.log(`${i + 1}. ${err.context}: ${err.message}`);
                    console.log(`   Location: ${err.file}:${err.line}`);
                });
            }

            console.log('\nErrors by Category:');
            console.log(JSON.stringify(report.summary.errorsByCategory, null, 2));

            console.log('\nErrors by Severity:');
            console.log(JSON.stringify(report.summary.errorsBySeverity, null, 2));

            console.log('\nErrors by File:');
            console.log(JSON.stringify(report.summary.errorsByFile, null, 2));

            console.log('='.repeat(80) + '\n');
        }

        /**
         * ストレージにデータを永続化
         */
        async _persistToStorage(key, data) {
            try {
                if (typeof chrome !== 'undefined' && chrome.storage && chrome.storage.local) {
                    await new Promise((resolve, reject) => {
                        chrome.storage.local.set({ [key]: data }, () => {
                            if (chrome.runtime.lastError) {
                                reject(chrome.runtime.lastError);
                            } else {
                                resolve();
                            }
                        });
                    });
                } else if (typeof localStorage !== 'undefined') {
                    localStorage.setItem(key, JSON.stringify(data));
                }
            } catch (err) {
                console.error('Failed to persist error data:', err);
                throw err; // Re-throw to allow caller to handle
            }
        }

        /**
         * エラーログをクリア
         */
        clear() {
            this.errors = [];
            this.warnings = [];
            this.infos = [];
        }

        /**
         * ロギングを有効/無効化
         */
        enable() {
            this.enabled = true;
        }

        disable() {
            this.enabled = false;
        }
    }



    // 共有の定数を付与
    const attachConstants = (target) => {
        target.ERROR_CATEGORIES = ERROR_CATEGORIES;
        target.SEVERITY_LEVELS = SEVERITY_LEVELS;
        target.FILE_ERROR_CODES = FILE_ERROR_CODES;
        target.FILE_ERROR_SEVERITY = FILE_ERROR_SEVERITY;
        target.LOOP_ERROR_CODES = LOOP_ERROR_CODES;
        target.LOOP_ERROR_SEVERITY = LOOP_ERROR_SEVERITY;
        target.CLIPBOARD_ERROR_CODES = CLIPBOARD_ERROR_CODES;
        target.CLIPBOARD_ERROR_SEVERITY = CLIPBOARD_ERROR_SEVERITY;
        return target;
    };

    // シングルトンインスタンスを初期化（既存のインスタンスがあれば再利用）
    // Check if the global class already has an instance (for module reloads)
    let exportedInstance;
    if (typeof globalScope.GlobalErrorLogger === 'function' &&
        globalScope.GlobalErrorLogger._instance instanceof GlobalErrorLogger) {
        // Reuse existing instance from previous load
        exportedInstance = globalScope.GlobalErrorLogger._instance;
    } else if (globalScope.GlobalErrorLogger instanceof GlobalErrorLogger) {
        // Legacy: global was an instance (shouldn't happen with new code, but kept for safety)
        exportedInstance = globalScope.GlobalErrorLogger;
    } else {
        // Create new instance
        // HEAD 側の意図を取り込んで、グローバルハンドラを無効化しておく
        exportedInstance = new GlobalErrorLogger({ setupGlobalHandlers: false });
        console.log('[GlobalErrorLogger] Singleton instance created (no global handlers)');
        console.debug('[GlobalErrorLogger] Singleton instance created (no global handlers)');
    }

    // クラスとインスタンスの両方に定数を付与
    attachConstants(GlobalErrorLogger);
    attachConstants(exportedInstance);

    // クラスへの参照をインスタンスに保持（必要に応じて新規インスタンスを作成可能）
    exportedInstance.Class = GlobalErrorLogger;

    // インスタンスへの参照をクラスに保持
    GlobalErrorLogger._instance = exportedInstance;

    // 既存コードとの後方互換用にグローバルへ公開（初回ロード時も参照可能にする）
    globalScope.GlobalErrorLogger = exportedInstance;

    /**
     * インスタンスを取得（存在しなければ作成）するヘルパー
     */
    const getOrCreateInstance = () => {
        let target = GlobalErrorLogger._instance || exportedInstance;
        if (!target) {
            target = new GlobalErrorLogger({ setupGlobalHandlers: false });
            attachConstants(target);
            target.Class = GlobalErrorLogger;
            GlobalErrorLogger._instance = target;
            exportedInstance = target;
            if (typeof globalScope !== 'undefined') {
                globalScope.GlobalErrorLogger = target;
            }
            console.warn('[GlobalErrorLogger] No instance found; created a fallback instance');
        }
        return target;
    };

    /**
     * インスタンスメソッドを static から呼び出すためのラッパー
     * - prototype を this にしない
     * - インスタンスが無ければオンデマンドで生成
     * - addSkipExtraFrame=true のときは details._skipExtraFrame を自動付与
     */
    const wrapInstanceMethod = (methodName, { addSkipExtraFrame = false } = {}) => {
        return (...args) => {
            const target = getOrCreateInstance();

            if (typeof target[methodName] !== 'function') {
                console.error(`[GlobalErrorLogger] Instance method ${methodName} not available`);
                return undefined;
            }

            if (addSkipExtraFrame) {
                // logError / logWarning / logInfo 用:
                // シグネチャは (context, errorOrMessage, details?)
                const [context, errorOrMessage, details = {}] = args;
                const newDetails = { ...details, _skipExtraFrame: true };
                return target[methodName](context, errorOrMessage, newDetails);
            }

            return target[methodName](...args);
        };
    };

    // レガシー互換性: クラスプロパティ経由でも最新のログ配列へアクセスできるようにする
    // これにより GlobalErrorLogger.errors.length のような既存コードが動作する
    const mirrorProperty = (prop) => Object.defineProperty(GlobalErrorLogger, prop, {
        get() { return getOrCreateInstance()[prop]; },
        set(value) { getOrCreateInstance()[prop] = value; },
        configurable: true
    });

    mirrorProperty('errors');
    mirrorProperty('warnings');
    mirrorProperty('infos');

    // ---- static ラッパー定義 ----

    const staticWrappers = {
        // 1. スタックトレース補正が必要なログ系（クラスメソッドとしても呼べる）
        logError: wrapInstanceMethod('logError', { addSkipExtraFrame: true }),
        logWarning: wrapInstanceMethod('logWarning', { addSkipExtraFrame: true }),
        logInfo: wrapInstanceMethod('logInfo', { addSkipExtraFrame: true }),

        // 2. 特化ログ（File / Loop / Clipboard）
        logFileError: wrapInstanceMethod('logFileError', { addSkipExtraFrame: true }),
        logLoopError: wrapInstanceMethod('logLoopError', { addSkipExtraFrame: true }),
        logClipboardError: wrapInstanceMethod('logClipboardError', { addSkipExtraFrame: true }),

        // 3. ユーティリティ / コントロールメソッド
        getReport: wrapInstanceMethod('getReport'),
        exportReport: wrapInstanceMethod('exportReport'),
        printReport: wrapInstanceMethod('printReport'),
        clear: wrapInstanceMethod('clear'),
        enable: wrapInstanceMethod('enable'),
        disable: wrapInstanceMethod('disable')
    };

    Object.assign(GlobalErrorLogger, staticWrappers);

    // Re-attach specialized file helpers and constants defensively to avoid
    // regressions when legacy call sites (e.g., AsyncFileIO) invoke static
    // APIs before the singleton instance is fully initialized.
    const ensureLegacyFileApi = (target) => {
        if (typeof target.logFileError !== 'function') {
            target.logFileError = staticWrappers.logFileError;
        }
        if (!target.FILE_ERROR_CODES) {
            target.FILE_ERROR_CODES = FILE_ERROR_CODES;
        }
        if (!target.FILE_ERROR_SEVERITY) {
            target.FILE_ERROR_SEVERITY = FILE_ERROR_SEVERITY;
        }
    };

    ensureLegacyFileApi(GlobalErrorLogger);

    // Legacy: only add wrappers to the exported instance when the method is missing
    // to avoid replacing prototype methods with wrappers and causing recursion
    Object.keys(staticWrappers).forEach((name) => {
        if (typeof exportedInstance[name] !== 'function') {
            exportedInstance[name] = staticWrappers[name];
        }
    });

    ensureLegacyFileApi(exportedInstance);

    // Export the CLASS separately for opt-in instantiation scenarios
    // This allows: const logger = new GlobalErrorLogger();
    // while keeping globalScope.GlobalErrorLogger as the shared singleton instance
    globalScope.GlobalErrorLoggerClass = GlobalErrorLogger;

    // console.log('[GlobalErrorLogger] Initialized successfully');

})(typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis : typeof self !== 'undefined' ? self : this);



======================================================================
FILE PATH: loginDialog.js
======================================================================
/*
Copyright © 1992-2021 Progress Software Corporation and/or one of its subsidiaries or affiliates. All rights reserved.
*/

function ok() {
    var bg = chrome.extension.getBackgroundPage();

    var user = document.getElementById("username").value;
    var pwd = document.getElementById("password").value;

    var response = {
        authCredentials: {
            username: document.getElementById("username").value,
            password: document.getElementById("password").value
        }
    };
    if (args.cypherData.encrypt) {
        pwd = bg.Rijndael.encryptString(pwd, args.cypherData.key);
    }

    var rec = "ONLOGIN USER="+user+" PASSWORD="+pwd;
    // remove previously recorded ONLOGIN command
    var l = args.recorder.actions.length;
    var match_part = "ONLOGIN USER=";
    if (l && args.recorder.actions[l-1].indexOf(match_part) == 0) {
        args.recorder.actions.pop();
        var panel = bg.context[args.recorder.win_id].panelWindow; 
        if (panel && !panel.closed) {
            panel.removeLastLine();
        }
    }
    args.recorder.recordAction(rec);
    args.callback(response);
    window.close();
}


function cancel() {
    args.callback({cancel: true})
    window.close();
}

window.addEventListener("load", function(evt) {
    var message = args.details.challenger.host+":"+
        args.details.challenger.port+" requires authentication.";
    if (args.details.realm)
        message += " Server message: "+args.details.realm;
    document.getElementById("message").innerText = message;
    // window.moveTo(window.opener.screenX+window.opener.outerWidth/2-170,
    //               window.opener.screenY+window.opener.outerHeight/2-100);
    document.getElementById("username").addEventListener("keypress", function(e) {
        if (e.which == 13) ok();
    });
    document.getElementById("password").addEventListener("keypress", function(e) {
        if (e.which == 13) ok();
    });
    document.getElementById("ok-button").addEventListener("click", ok);
    document.getElementById("cancel-button").addEventListener("click", cancel);
    resizeToContent(window, document.getElementById('container'));
});



======================================================================
FILE PATH: macroView.js
======================================================================
/*
Copyright © 1992-2021 Progress Software Corporation and/or one of its subsidiaries or affiliates. All rights reserved.
*/

var mv = {
    lineCounter: 0,

    showLines: function(code) {
        var lines = code.split(/\r?\n/);
        this.clearAllLines();   // just to make sure it's empty
        lines.forEach(function(line) {
            mv.addLine(line, true)
        });
    },


    addLine: function(txt, no_scroll) {
        this.lineCounter++;
        var tr = document.createElement("tr");

        // line number
        var num = document.createElement("td");
        num.setAttribute("class", "line-number");
        num.textContent = this.lineCounter;

        // text
        var line = document.createElement("td");
        line.setAttribute("class", "macro-line");
        if (/^\s*'/.test(txt))
            line.setAttribute("commented", "true");
        line.textContent = txt;
        
        // put that all together
        tr.appendChild(num);
        tr.appendChild(line);
        document.getElementById("lines").appendChild(tr);

        if (!no_scroll) {
            this.ensureNodeIsVisible(tr);
        }
    },


    removeLastLine: function() {
        var lines = document.getElementById("lines");
        lines.removeChild(lines.lastChild);
    },


    highlightLine: function(linum) {
        // evaluate XPath to find all elements
        // with attribute selected="true"
        var xpath = "id('lines')/tr[@selected='true']";
        try {
            var result = document.evaluate(xpath, document, null,
                            XPathResult.ORDERED_NODE_ITERATOR_TYPE,
                            null);
            var node = null, nodes = new Array();
            while (node = result.iterateNext()) {
                nodes.push(node);
            }
            // remove selection
            nodes.forEach( function(x) {
                x.removeAttribute("selected");
            })
        } catch(e) {
            console.error(e);
        }
        // select the proper one
        xpath = "id('lines')//tr[position()="+parseInt(linum)+"]";
        try {
            result = document.evaluate(xpath, document, null,
                                       XPathResult.FIRST_ORDERED_NODE_TYPE,
                                       null);
            if (node = result.singleNodeValue) {
                this.ensureNodeIsVisible(node);F
                node.setAttribute("selected", "true");
            }
        } catch(e) {
            console.error(e);
        }
    },


    clearAllLines: function() {
        document.getElementById("lines").innerHTML = "";
        this.lineCounter = 0;
    },


    setStatLine: function(txt, type) {
        document.getElementById("status-div").setAttribute("type", type);
        document.getElementById("status").textContent = txt;
    },

    ensureNodeIsVisible: function(node) {
        var box = node.getBoundingClientRect();
        // console.log("ensureNodeIsVisible: box.top="+box.top+
        //             ", box.bottom="+box.bottom+
        //             ", window.pageYOffset="+window.pageYOffset+
        //             ", document.body.clientHeight="+document.body.clientHeight);
        if (box.bottom > document.body.clientHeight) {
            window.scrollTo(0, box.bottom+window.pageYOffset-
                            document.body.clientHeight+5);
        } else if (box.bottom < 0) {
            window.scrollTo(0, box.top+window.pageYOffset-5);
        }
    }
};



======================================================================
FILE PATH: manifest.json
======================================================================
{
"update_url": "https://clients2.google.com/service/update2/crx",

    "manifest_version": 2,

    "content_scripts": [
        {
            "js": [
                "content_scripts/bookmarks_handler.js",
                "content_scripts/si_listener.js"
            ],
            "matches": ["http://*/*", "https://*/*", "file://*"],
            "run_at": "document_start",
            "all_frames": false
        },
        {
            "js": [
                "utils.js",
                "content_scripts/connector.js",
                "content_scripts/recorder.js",
                "content_scripts/player.js"
            ],
            "matches": ["http://*/*", "https://*/*", "file://*"],
            "run_at": "document_idle",
            "all_frames": true
        }
    ],

    "description": "Automate your web browser. Record and replay repetitious work",
    "name": "iMacros for Chrome",
    "version": "10.1.1",
    "minimum_chrome_version": "51",
    "homepage_url": "https://imacros.net",

    "browser_action": {
        "default_title": "iMacros for Chrome",
        "default_icon": {"19": "skin/logo19.png", "38": "skin/logo38.png"}
    },

    "background": {"page": "bg.html"},

    "options_page": "options.html",

    "permissions": [
        "tabs",
        "bookmarks",
        "proxy",
        "cookies",
        "pageCapture",
        "webNavigation",
        "notifications",
        "webRequest",
        "webRequestBlocking",
        "nativeMessaging",
        "downloads",
        "contextMenus",
        "debugger",
        "<all_urls>"
    ],

    "icons": { "16": "skin/logo16.png",
               "48": "skin/logo48.png",
               "128": "skin/logo128.png" },

    "web_accessible_resources": [
        "skin/logo24.png"
    ],

    "sandbox": {
        "pages": ["sandbox.html"]
    },
    
    "commands": {
        "_execute_browser_action": {
          "suggested_key": {
            "default": "Ctrl+8",
            "mac": "Command+8"
            }
        }
    }
}



======================================================================
FILE PATH: mplayer.js
======================================================================

/*
Copyright © 1992-2021 Progress Software Corporation and/or one of its subsidiaries or affiliates. All rights reserved.
*/


// An object to encapsulate all operations for parsing
// and playing macro commands

function MacroPlayer(win_id) {
    this.win_id = win_id;
    this.vars = new Array();
    this.userVars = new Map();
    this.ports = new Object();
    this._ActionTable = new Object();
    this.compileExpressions();

    this._onScriptError = this.onErrorOccurred.bind(this);
    // this._onBeforeNavigate = this.onBeforeNavigate.bind(this);
    // this._onCompleted = this.onNavigationCompleted.bind(this);
    this._onErrorOccured = this.onNavigationErrorOccured.bind(this);
    // this._onCommitted = this.onNavigationCommitted.bind(this);
    // this._onCreatedNavTarget = this.onCreatedNavigationTarget.bind(this);
    // this._onDOMLoaded = this.onDOMContentLoaded.bind(this);
    // this._onRefFragUpdated = this.onReferenceFragmentUpdated.bind(this);
    this._onTabUpdated = this.onTabUpdated.bind(this);
    this._onActivated = this.onTabActivated.bind(this);

    // bindings to monitor network activity
    this.onAuth = this.onAuthRequired.bind(this);
    // this.onRequest = this.onBeforeRequest.bind(this);
    // this.onRedirect = this.onBeforeRedirect.bind(this);
    this._onBeforeSendHeaders = this.onBeforeSendHeaders.bind(this);
    // this.onCompleted = this.onReqCompleted.bind(this);
    // this.onReqError = this.onErrorOccurred.bind(this);
    // this.onHeaders = this.onHeadersReceived.bind(this);
    // this.onResponse = this.onResponseStarted.bind(this);
    // this._onSendHeaders = this.onSendHeaders.bind(this);

    // handle sandbox messages
    window.addEventListener("message", this.onSandboxMessage.bind(this));

    // listeners for download events
    this._onDownloadCreated = this.onDownloadCreated.bind(this);
    this._onDownloadChanged = this.onDownloadChanged.bind(this);
}


// A table to hold the code for processing a command
MacroPlayer.prototype.ActionTable = new Object();
MacroPlayer.prototype.RegExpTable = new Object();



// compile actions regexps
MacroPlayer.prototype.compileExpressions = function () {
    if (!this.RegExpTable.compiled) {
        for (var x in this.RegExpTable) {
            try {
                this.RegExpTable[x] = new RegExp(this.RegExpTable[x], "i");
            } catch (e) {
                console.error(e);
                throw e;
            }
        }
        this.RegExpTable.compiled = true;
    }
    for (var x in MacroPlayer.prototype.ActionTable) {
        this._ActionTable[x] = MacroPlayer.prototype.ActionTable[x].bind(this);
    }
};



// add listener for various events
MacroPlayer.prototype.addListeners = function() {
    communicator.registerHandler("error-occurred",
                                 this._onScriptError, this.win_id);
    chrome.tabs.onUpdated.addListener(this._onTabUpdated);
    chrome.tabs.onActivated.addListener(this._onActivated);

    // use WebNavigation interface to trace download events

    // chrome.webNavigation.onBeforeNavigate.addListener(this._onBeforeNavigate);
    // chrome.webNavigation.onCompleted.addListener(this._onCompleted);
    chrome.webNavigation.onErrorOccurred.addListener(this._onErrorOccured);

    // chrome.webNavigation.onCommitted.addListener(this._onCommitted);
    // chrome.webNavigation.onCreatedNavigationTarget.addListener(
    //     this._onCreatedNavTarget
    // );
    // chrome.webNavigation.onDOMContentLoaded.addListener(
    //     this._onDOMLoaded
    // );
    // chrome.webNavigation.onReferenceFragmentUpdated.addListener(
    //     this._onRefFragUpdated
    // );

    // network events
    // chrome.webRequest.onBeforeRequest.addListener(
    //     this.onRequest,
    //     {
    //         windowId: this.win_id,
    //         urls: ["<all_urls>"]// ,
    //         // types: ["main_frame", "sub_frame"]
    //     }
    // );
    // chrome.webRequest.onBeforeRedirect.addListener(
    //     this.onRedirect,
    //     {windowId: this.win_id, urls: ["<all_urls>"]},
    //     ["responseHeaders"]
    // );
    // chrome.webRequest.onBeforeSendHeaders.addListener(
    //     this._onBeforeSendHeaders,
    //     {windowId: this.win_id, urls: ["<all_urls>"]},
    //     ["blocking", "requestHeaders"]
    // );
    // chrome.webRequest.onCompleted.addListener(
    //     this.onCompleted,
    //     {
    //         windowId: this.win_id,
    //         urls: ["<all_urls>"]
    //     }
    // );
    // chrome.webRequest.onErrorOccurred.addListener(
    //     this.onReqError,
    //     {
    //         windowId: this.win_id,
    //         urls: ["<all_urls>"]
    //     }
    // );
    // chrome.webRequest.onHeadersReceived.addListener(
    //     this.onHeaders,
    //     {windowId: this.win_id, urls: ["<all_urls>"]},
    //     ["responseHeaders"]
    // );
    // chrome.webRequest.onResponseStarted.addListener(
    //     this.onResponse,
    //     {windowId: this.win_id, urls: ["<all_urls>"]},
    //     ["responseHeaders"]
    // );
    // chrome.webRequest.onSendHeaders.addListener(
    //     this._onSendHeaders,
    //     {windowId: this.win_id, urls: ["<all_urls>"]},
    //     ["requestHeaders"]
    // );
};

MacroPlayer.prototype.removeListeners = function() {
    communicator.unregisterHandler("error-occurred", this._onScriptError);
    chrome.tabs.onUpdated.removeListener(this._onTabUpdated);
    chrome.tabs.onActivated.removeListener(this._onActivated);
    // chrome.webNavigation.onBeforeNavigate.removeListener(this._onBeforeNavigate);
    // chrome.webNavigation.onCompleted.removeListener(this._onCompleted);
    chrome.webNavigation.onErrorOccurred.removeListener(this._onErrorOccured);

    // chrome.webNavigation.onCommitted.removeListener(this._onCommitted);
    // chrome.webNavigation.onCreatedNavigationTarget.removeListener(
    //     this._onCreatedNavTarget
    // );
    // chrome.webNavigation.onDOMContentLoaded.removeListener(
    //     this._onDOMLoaded
    // );
    // chrome.webNavigation.onReferenceFragmentUpdated.removeListener(
    //     this._onRefFragUpdated
    // );

    // network events
    // chrome.webRequest.onBeforeRequest.removeListener(this.onRequest);
    // chrome.webRequest.onBeforeRedirect.removeListener(this.onRedirect);
    if (this.userAgent) {
        chrome.webRequest.onBeforeSendHeaders.removeListener(
            this._onBeforeSendHeaders
        );
    }
    // chrome.webRequest.onCompleted.removeListener(this.onCompleted);
    // chrome.webRequest.onErrorOccurred.removeListener(this.onReqError);
    // chrome.webRequest.onHeadersReceived.removeListener(this.onHeaders);
    // chrome.webRequest.onResponseStarted.removeListener(this.onResponse);
    // chrome.webRequest.onSendHeaders.removeListener(this._onSendHeaders);
};


// MacroPlayer.prototype.onBeforeNavigate = function(details) {
//     if (details.tabId != this.tab_id)
//         return;
//     console.log("onBeforeNavigate: %O", details);
// };


// MacroPlayer.prototype.reviseActiveNavigations = function() {
//     var count = this.activeNavigations.size;
//     if (count == 0) {
//         if (this.afterCompleteTimeout) {
//             // we're waiting for navigation completion after
//             // onTabUpdated with 'complete' fired
//             clearTimeout(this.afterCompleteTimeout);
//             this.afterCompleteTimeout = null;
//         }
//         this.activeNavigations.clear();
//         this.waitingForPageLoad = false;
//         this.stopTimer("loading");
//         if (!this.waitForDownloadCompleted && !this.waitForDownloadCreated)
//             this.next("Page load complete2, url="+this.currentURL);
//     }

//     return count;
// };

// MacroPlayer.prototype.onNavigationCompleted = function(details) {
//     if (details.tabId != this.tab_id)
//         return;
//     console.log("onNavigationCompleted: %O", details);

//     if (this.playing && /^(?:https?|file)/.test(details.url)) {
//         this.activeNavigations.delete(details.frameId+":"+details.processId);
//         this.reviseActiveNavigations();
//     }
// };


MacroPlayer.prototype.onNavigationErrorOccured = function(details) {
    if (details.tabId != this.tab_id)
        return;

    // console.error("onNavigationErrorOccured: %O", details);
    if (this.playing) {
        // workaround for #223, see crbug.com/117043
        if (/net::ERR_ABORTED/.test(details.error)) {
            // var navigation = details.frameId+":"+details.processId;
            // this.activeNavigations.delete(navigation);
            // this.reviseActiveNavigations();
            return;
        }

        this.handleError(new RuntimeError(
            "Navigation error occured while loading url "+
                details.url+", details: "+details.error, 733));
        this.stopTimer("loading");
        this.waitingForPageLoad = false;
        // this.activeNavigations.clear();
        return;
    }
};



// MacroPlayer.prototype.onNavigationCommitted = function(details) {
//     if (details.tabId != this.tab_id)
//         return;

//     console.log("onNavigationCommitted: %O", details);

//     if (this.playing && /^(?:https?|file)/.test(details.url)) {
//         this.waitingForPageLoad = true;
//         this.activeNavigations.add(details.frameId+":"+details.processId);
//         if (!this.timers.has("loading")) {
//             var mplayer = this;
//             this.startTimer("loading", this.timeout, "Loading ", function() {
//                 mplayer.waitingForPageLoad = false;
//                 mplayer.handleError(
//                     new RuntimeError("Page loading timeout"+
//                                      ", URL: "+mplayer.currentURL, 602));
//             });
//         }
//     }
// };


// MacroPlayer.prototype.onCreatedNavigationTarget = function(details) {
//     console.log("onCreatedNavigationTarget: %O", details);
// };


// MacroPlayer.prototype.onDOMContentLoaded = function(details) {
//     console.log("onDOMContentLoaded: %O", details);
// };

// MacroPlayer.prototype.onReferenceFragmentUpdated = function(details) {
//     console.log("onReferenceFragmentUpdated: %O", details);
// };




// network events
MacroPlayer.prototype.onAuthRequired = function(details, callback) {
    // console.log("onAuthRequired: %O", details);
    if (this.tab_id != details.tabId)
        return;
    if (this.lastAuthRequestId == details.requestId) {
        asyncRun(this.handleError.bind(this)(new RuntimeError(
            "Wrong credentials for HTTP authorization"
        ), 734));
        return {cancel: true};
    }
    this.lastAuthRequestId = details.requestId;
    if (!this.loginData || !this.waitForAuthDialog) {
        asyncRun(this.handleError.bind(this)(new RuntimeError(
            "No credentials supplied for HTTP authorization"
        ), 734));
        return {cancel: true};
    }
    var rv = {
        authCredentials: {
            username: this.loginData.username,
            password: this.loginData.password
        }
    };
    delete this.loginData;

    return rv;
};


// MacroPlayer.prototype.onBeforeRequest = function(details) {
//     console.log("onBeforeRequest: %O", details);
// };

// MacroPlayer.prototype.onBeforeRedirect = function(details) {
//     console.log("onBeforeRedirect: %O", details);
// };


MacroPlayer.prototype.onBeforeSendHeaders = function(details) {
    // console.log("onBeforeSendHeaders: %O", details);
    for (var i = 0; i < details.requestHeaders.length; i++)
        if (details.requestHeaders[i].name == 'User-Agent') {
            details.requestHeaders[i].value = this.userAgent;
            break;
        }
    return {requestHeaders: details.requestHeaders};
};

// MacroPlayer.prototype.onReqCompleted = function(details) {
//     console.log("onReqCompleted: %O", details);
// };


// MacroPlayer.prototype.onErrorOccurred = function(details) {
//     console.log("onErrorOccured: %O", details);
// };

// MacroPlayer.prototype.onHeadersReceived = function(details) {
//     console.log("onHeadersReceived: %O", details);
// };

// MacroPlayer.prototype.onResponseStarted = function(details) {
//     console.log("onResponseStarted: %O", details);
// };

// MacroPlayer.prototype.onSendHeaders = function(details) {
//     console.log("onSendHeaders: %O", details);
// };


MacroPlayer.prototype.onTabActivated = function(activeInfo) {
    if (activeInfo.windowId == this.win_id) {
        // console.log("onTabActivated, tabId="+activeInfo.tabId);
        (this.eventMode? attach_debugger(activeInfo.tabId) : Promise.resolve())
            .then(() => (this.tab_id = activeInfo.tabId))
    }
};


// listen to page load events
MacroPlayer.prototype.onTabUpdated = function(tab_id, obj, tab) {
    if (this.tab_id != tab_id)
        return;
    // console.log("onTabUpdated, changeInfo=%O, tab=%O", obj, tab);
    if (tab.url == "about:blank") // ignore about:blank urls
        return;
    this.currentURL = tab.url;
    if (obj.status == "loading" && !this.timers.has("loading")) {
        this.waitingForPageLoad = true;
        this.startTimer("loading", this.timeout, "Loading ", function() {
            mplayer.waitingForPageLoad = false;
            mplayer.handleError(
                new RuntimeError("Page loading timeout"+
                                 ", URL: "+mplayer.currentURL, 602));
        });
        // We need to catch "loading" event as early as possible
        // onTabUpdated may be fired too late in some cases.
        // For example, Amazon search box triggers page load event
        // where onTabUpdated reports 'complete' prematurely and
        // the next TAG commad may be executed before search results
        // appeared on the page
    } else if (obj.status == "complete") {
        if (this.waitForAuthDialog && this.lastAuthRequestId) {
            delete this.lastAuthRequestId;
            this.waitForAuthDialog = false;
            chrome.webRequest.onAuthRequired.removeListener(this.onAuth);
        }
        if (this.waitingForPageLoad) {
            this.waitingForPageLoad = false;
            this.stopTimer("loading");
            this.next("onTabUpdated, status = complete");
        }
        return;

        // if (this.waitingForPageLoad && this.activeNavigations.size != 0) {
        //     // there are some loadings in queue, start timeout
        //     // to let them finish (in 5s)
        //     var mplayer = this;
        //     this.afterCompleteTimeout = setTimeout(function() {
        //         mplayer.waitingForPageLoad = false;
        //         mplayer.stopTimer("loading");
        //         if (!mplayer.waitForDownloadCompleted &&
        //             !mplayer.waitForDownloadCreated)
        //             mplayer.next("Page load complete1, url="+
        //                          mplayer.currentURL);
        //     }, 5000);
        // }
    }
};


MacroPlayer.prototype.startTimer = function(type, timeout, msg, callback) {
    // only one timer of the type at a time is allowed
    console.assert(!this.timers.has(type));

    var mplayer = this;

    var timer = new Object();
    timer.start = performance.now();

    timer.timeout = setTimeout(function() {
        mplayer.stopTimer(type);
        typeof(callback) == "function" && callback();
    } , timeout*1000);

    timer.interval = setInterval(function() {
        var now = performance.now();
        var elapsedTime = (now - timer.start)/1000;
        if (elapsedTime > timeout) {
            mplayer.stopTimer(type);
            typeof(callback) == "function" && callback();
        }
        // change panel/badge text
        var panel = context[mplayer.win_id].panelWindow;
        if (panel && !panel.closed) {
            panel.setStatLine(msg+elapsedTime.toFixed(1)+
                              "("+Math.round(timeout)+")s",
                              "warning");
        }

        badge.set(mplayer.win_id, {
            status: "loading",
            text: Math.round(elapsedTime) // make sure it is integer
        });

    }, 200);

    this.timers.set(type, timer);
};

MacroPlayer.prototype.stopTimer = function(type) {
    if (!this.timers.has(type))
        return;
    var timer = this.timers.get(type);
    clearTimeout(timer.timeout);
    clearInterval(timer.interval);
    this.timers.delete(type);
    timer = null;
};


MacroPlayer.prototype.clearRetryInterval = function() {
    if (this.retryInterval) {
        clearInterval(this.retryInterval);
        delete this.retryInterval;
    }
}

MacroPlayer.prototype.retry = function(onerror, msg, caller_id, timeout) {
    if (!this.playing)
    return;

    if (timeout === undefined) {
        timeout = this.timeout/10;
    }
    var _timeout = timeout*1000; // ms
    if (!this.retryInterval) {
        var start_time = performance.now();
        this.retryInterval = setInterval(() => {
            if (!this.playing) {
                this.clearRetryInterval()
                return
            }
            var remains = start_time +
                _timeout - performance.now();
            if (remains <= 0) {
                this.clearRetryInterval();
                try {
                    typeof(onerror) == "function" && onerror();
                } catch(e) {
                    if (this.ignoreErrors) {
                        this.action_stack.pop();
                        this.next("skipped retry() - error ignored");
                    } else {
                        this.handleError(e);
                    }
        }
            } else {
                // set badge text
                let text = Math.round(remains/1000);
                while(text.length < 2)
                    text = "0"+text;
                text += "s";
                badge.set(this.win_id, {
                    status: "tag_wait",
                    text: text
                });

                // set panel text
                let panel = context[this.win_id].panelWindow;
                if (panel && !panel.closed) {
                    panel.setStatLine(msg+(remains/1000).toFixed(1)+
                                      "("+Math.round(_timeout/1000)+")s",
                                      "warning");
                }
            }
        }, 500);
    }
    this.action_stack.push(this.currentAction);
    setTimeout(() => {
        this.playNextAction("retry "+caller_id);
    }, 500);
};


// handle messages from content-scripts
MacroPlayer.prototype.onTagComplete = function(data) {
    if (!data.found) {
        this.retry(() => {
            if (data.extract) {
                this.showAndAddExtractData("#EANF#");
                this.action_stack.pop();
        this.next("onTagComplete");
            } else {
        throw data.error;
            }
        }, "Tag waiting... ", "onTagComplete", this.timeout_tag);

        return;
    }

    this.clearRetryInterval();

    if (data.error) {
        this.handleError(data.error);
    } else if (data.selector) {
        this.handleInputFileTag(data.selector, data.files)
            .then(() => this.next("onTagComplete"))
            .catch(e => this.handleError(e))
    } else if (data.decryptPassword) {
        this.shouldDecryptPassword = true
        this.action_stack.push(this.currentAction)
        this.next("Decrypt content string")
    } else {
        if (data.extract) {
            this.showAndAddExtractData(data.extract);
        } else if (data.targetURI) {
            this.saveTarget(data.targetURI);
        }
        // .next() will be called in onDownloadCreated otherwise
        if (!this.waitForDownloadCreated && !this.waitForAuthDialog)
            this.next("onTagComplete");
    }
};


// MacroPlayer.prototype.onContentChange = function(data, tab_id, callback) {
//     typeof (callback) == "function" &&   // release resources
//         callback();

//     if (this.tab_id != tab_id)
//         return;
//     var mplayer = this;
//     chrome.tabs.get(tab_id, function(tab) {
//         if (!tab) return;
//         if (Storage.getBool("debug"))
//             console.debug("content-change, url "+tab.url);

//         // This is for TAG commands acting on <a> elements
//         // because tab.onUpdated() is fired too late
//         if (mplayer.playing) {
//             mplayer.waitingForPageLoad = true;
//         }
//     });
// };


MacroPlayer.prototype.terminate = function() {
    if (Storage.getBool("debug"))
        console.info("terminating player for window "+this.win_id);
    // ensure that player is stopped
    if (this.playing)
        this.stop();
};


// a pattern to match a double quoted string or eval() command
// or a non-whitespace char sequence
var im_strre = "(?:\"(?:[^\"\\\\]|\\\\[0btnvfr\"\'\\\\])*\"|"+
    "eval\\s*\\(\"(?:[^\"\\\\]|\\\\[\\w\"\'\\\\])*\"\\)|"+
    "\\S*)";

// const im_strre = "(?:\"(?:[^\"\\\\]|\\\\[0btnvfr\"\'\\\\])*\"|\\S*)";


MacroPlayer.prototype.noContentPage = function(cmd_name) {
    if (!/^https?|file/i.test(this.currentURL))
        this.handleError(
            new RuntimeError(
                cmd_name+" command can not be executed because"+
                    " it requires a Web page loaded in active tab."+
                    " Current page is "+this.currentURL, 612
            )
        );
};


// ADD command http://wiki.imacros.net/ADD
// regexp for parsing ADD command
MacroPlayer.prototype.RegExpTable["add"] =
    "^(\\S+)\\s+("+im_strre+")\\s*$";

MacroPlayer.prototype.ActionTable["add"] = function (cmd) {
    var param = imns.unwrap(this.expandVariables(cmd[2], "add2"));
    var m = null;

    if ( m = cmd[1].match(this.limits.varsRe) ) {
        var num = imns.s2i(m[1]);
        var n1 = imns.s2i(this.getVar(num)), n2 = imns.s2i(param);
        if ( !isNaN(n1) && !isNaN(n2) ) {
            this.vars[num] = (n1 + n2).toString();
        } else {
            this.vars[num] = this.getVar(num) + param;
        }
    } else if ( arr = cmd[1].match(/^!extract$/i) ) {
        this.addExtractData(param);
    } else if (/^!\S+$/.test(cmd[1])) {
        throw new BadParameter("Unsupported variable "+cmd[1]+
                               " for ADD command");
    } else {
        var n1 = imns.s2i(this.getUserVar(cmd[1])), n2 = imns.s2i(param);
        if ( !isNaN(n1) && !isNaN(n2) ) {
            this.setUserVar(cmd[1], (n1 + n2).toString());
        } else {
            this.setUserVar(cmd[1], this.getUserVar(cmd[1])+param);
        }
    }

    this.next("ADD");
};


MacroPlayer.prototype.RegExpTable["back"] = "^\\s*$";

MacroPlayer.prototype.ActionTable["back"] = function (cmd) {
    if (this.noContentPage("BACK"))
        return;

    chrome.tabs.get(this.tab_id, function(tab) {
        if (/^(?:https?|file)/.test(tab.url))
            communicator.postMessage("back-command", {}, tab.id,
                                     function() {},
                                     {number: 0});
    });
    // mplayer.next() will be called on load-complete event
};


// CLEAR command http://wiki.imacros.net/CLEAR
// I added new optional parameter to the command which restricts
// cookies removal to specified domain/url
MacroPlayer.prototype.RegExpTable["clear"] = "^\\s*("+im_strre+")?\\s*$";

MacroPlayer.prototype.ActionTable["clear"] = function (cmd) {
    var specifier = cmd[1] ?
        imns.unwrap(this.expandVariables(cmd[1], "clear1")) : null;
    var details = {};
    if (specifier) {
        if (/^http/.test(specifier)) {
            details.url = specifier;
        } else if (/^[\w\.]+$/.test(specifier)) {
            details.domain = specifier;
        } else {
            throw new BadParameter("domain name or URL", 1);
        }
    }

    var mplayer = this;
    chrome.cookies.getAll(details, function(cookies) {
        cookies.forEach(function(cookie) {
            // TODO: check if we should omit storeId here.
            // As for now I think that only current execution context
            // store's cookies should be removed
            var url = (cookie.secure? "https" : "http")+"://"+
                cookie.domain+cookie.path;
            chrome.cookies.remove({url: url, name: cookie.name});
        });
        mplayer.next("CLEAR");
    });
};


// EVENT command
MacroPlayer.prototype.RegExpTable["event"] =
    "type\\s*=\\s*("+im_strre+")"+
    "(?:\\s+(selector|xpath)\\s*=\\s*("+im_strre+"))?"+
    "(?:\\s+(button|key|char|point)\\s*=\\s*("+im_strre+"))?"+
    "(?:\\s+modifiers\\s*=\\s*("+im_strre+"))?";

MacroPlayer.prototype.attachDebugger = function(version) {
    return this.debuggerAttached ?
        Promise.resolve() : attach_debugger(this.tab_id, version).then(() => {
            this.debuggerAttached = true
        })
}

MacroPlayer.prototype.detachDebugger = function() {
    return this.debuggerAttached ?
        detach_debugger(this.tab_id).then(() => {
            this.debuggerAttached = false
        }) : Promise.resolve()
}

function attach_debugger(tab_id, version = "1.2") {
    return new Promise(function(resolve, reject) {
        chrome.debugger.attach({tabId: tab_id}, version, function() {
            if (chrome.runtime.lastError)
                reject(chrome.runtime.lastError);
            else
                resolve();
        });
    });
}

function send_command(tab_id, method, params) {
    return new Promise(function(resolve, reject) {
        chrome.debugger.sendCommand(
            {tabId: tab_id}, method, params,
            function(response) {
                if (chrome.runtime.lastError)
                    reject(chrome.runtime.lastError);
                else
                    resolve(response);
            }
        );
    });
}

function detach_debugger(tab_id) {
    return new Promise(function(resolve, reject) {
        chrome.debugger.detach({tabId: tab_id}, function() {
            if (chrome.runtime.lastError)
                reject(chrome.runtime.lastError);
            else
                resolve();
        });
    });
}

function get_modifiers_bitmask(modifiers) {
    var altKey = /alt/i.test(modifiers) && 1 || 0;
    var ctrlKey = /ctrl/i.test(modifiers) && 2 || 0;
    var metaKey = /meta/i.test(modifiers) && 4 || 0;
    var shiftKey = /shift/i.test(modifiers) && 8 || 0;
    return altKey | ctrlKey | metaKey | shiftKey;
}

function get_key_identifier_from_char(c) {
    var keyCode = c.toUpperCase().charCodeAt(0);
    var s = keyCode.toString(16).toUpperCase();
    while (s.length <= 4)
        s = "0" + s;
    return "U+" + s;
}

function get_key_identifier_from_keycode(code) {
    // the table is build based on https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key#Key_values_on_Windows_(and_char_values_of_IE)
    var ids = {
        0x08: "Backspace",
        0x09: "Tab",
        0x0C: "Clear",
        0x0D: "Enter",
        0x10: "Shift",
        0x11: "Control",
        0x12: "Alt",
        0x13: "Pause",
        0x14: "CapsLock",
        0x15: "KanaMode",
        0x17: "JunjaMode",
        0x18: "HanjaMode",
        0x19: "KanjiMode",
        0x1B: "Esc",
        0x1C: "Convert",
        0x1D: "Nonconvert",
        0x1E: "Accept",
        0x1F: "ModeChange",
        0x21: "PageUp",
        0x22: "PageDown",
        0x23: "End",
        0x24: "Home",
        0x25: "Left",
        0x26: "Up",
        0x27: "Right",
        0x28: "Down",
        0x29: "Select",
        0x2B: "Execute",
        0x2C: "PrintScreen",
        0x2D: "Insert",
        0x2E: "Del",
        0x2F: "Help",
        0x5B: "Win",
        0x5C: "Win",
        0x5D: "Apps",
        0x70: "F1",
        0x71: "F2",
        0x72: "F3",
        0x73: "F4",
        0x74: "F5",
        0x75: "F6",
        0x76: "F7",
        0x77: "F8",
        0x78: "F9",
        0x79: "F10",
        0x7A: "F11",
        0x7B: "F12"
    };

    if (typeof ids[code] != "undefined")
        return ids[code];
    // else return Unicode value
    var s = code.toString(16).toUpperCase();
    while (s.length <= 4)
        s = "0" + s;
    return "U+" + s;
}

function get_windows_virtual_keycode(c) {
    // NOTE: It looks like Chrome uses Unicode code point as keyCode
    // for non-ASCII characters as well
    var keyCode = c.charCodeAt(0);
    return keyCode;
}

MacroPlayer.prototype.dispatchCharKeydownEvent = function(details) {
    return Promise.resolve()
    // var vk = get_windows_virtual_keycode(details.char);
    // var keyid = get_key_identifier_from_char(details.char);
    // var modifiers = get_modifiers_bitmask(details.modifiers);
    // var mplayer = this;
    // return [
    //     {"type": "rawKeyDown",
    //      "windowsVirtualKeyCode": vk,
    //      "keyIdentifier": keyid,
    //      "modifiers": modifiers}
    // ].reduce(function(seq, opts) {
    //     return seq.then(function() {
    //         return send_command(mplayer.tab_id, "Input.dispatchKeyEvent", opts);
    //     });
    // }, Promise.resolve());
};

MacroPlayer.prototype.dispatchCharKeyupEvent = function(details) {
    return Promise.resolve()
    // var vk = get_windows_virtual_keycode(details.char);
    // var keyid = get_key_identifier_from_char(details.char);
    // var modifiers = get_modifiers_bitmask(details.modifiers);
    // var mplayer = this;
    // return send_command(mplayer.tab_id, "Input.dispatchKeyEvent", {
    //     "type": "keyUp",
    //     "windowsVirtualKeyCode": vk,
    //     "keyIdentifier": keyid,
    //     "modifiers": modifiers
    // });
};


MacroPlayer.prototype.dispatchControlKeydownEvent = function(details) {
    var vk = details.key;
    var keyid = get_key_identifier_from_keycode(details.key);
    var modifiers = get_modifiers_bitmask(details.modifiers);
    var mplayer = this;
    return send_command(mplayer.tab_id, "Input.dispatchKeyEvent", {
        "type": "rawKeyDown",
        "windowsVirtualKeyCode": vk,
        "keyIdentifier": keyid,
        "modifiers": modifiers
    });
};

MacroPlayer.prototype.dispatchControlKeyupEvent = function(details) {
    var vk = details.key;
    var keyid = get_key_identifier_from_keycode(details.key);
    var modifiers = get_modifiers_bitmask(details.modifiers);
    var mplayer = this;
    return send_command(mplayer.tab_id, "Input.dispatchKeyEvent", {
        "type": "keyUp",
        "windowsVirtualKeyCode": vk,
        "keyIdentifier": keyid,
        "modifiers": modifiers
    });
};

MacroPlayer.prototype.dispatchCharKeypressEvent = function(details) {
    var vk = get_windows_virtual_keycode(details.char);
    var keyid = get_key_identifier_from_char(details.char);
    var modifiers = get_modifiers_bitmask(details.modifiers);
    var mplayer = this;
    return [
        {"type": "char",
         "text": details.char,
         "modifiers": modifiers}
    ].reduce(function(seq, opts) {
        return seq.then(function() {
            return send_command(mplayer.tab_id, "Input.dispatchKeyEvent", opts);
        });
    }, Promise.resolve());
};

MacroPlayer.prototype.dispatchControlKeypressEvent = function(details) {
    var vk = details.key;
    var keyid = get_key_identifier_from_keycode(details.key);
    var modifiers = get_modifiers_bitmask(details.modifiers);
    var mplayer = this;
    return ["rawKeyDown", "keyUp"]
        .reduce(function(seq, type) {
            return seq.then(function() {
                return send_command(mplayer.tab_id, "Input.dispatchKeyEvent", {
                    "type": type,
                    "windowsVirtualKeyCode": vk,
                    "keyIdentifier": keyid,
                    "modifiers": modifiers
                });
            });
        }, Promise.resolve());
};

MacroPlayer.prototype.dispatchKeyboardEvent = function(details) {
    var char_funcs = {
        "keydown": this.dispatchCharKeydownEvent.bind(this),
        "keyup": this.dispatchCharKeyupEvent.bind(this),
        "keypress": this.dispatchCharKeypressEvent.bind(this)
    };
    var ctrl_funcs = {
        "keydown": this.dispatchControlKeydownEvent.bind(this),
        "keyup": this.dispatchControlKeyupEvent.bind(this),
        "keypress": this.dispatchControlKeypressEvent.bind(this)
    };
    return (details.char ? char_funcs : ctrl_funcs)[details.type](details);
};

function get_mouse_button_name(button) {
    if (button == -1)
        return "none";
    else if (button == 0)
        return "left";
    else if (button == 1)
        return "middle";
    else if (button == 2)
        return "right";
    else
        return "none"; // TODO: should we handle other buttons as well?
}

function get_mouse_event_name(type) {
    if (type == "mousedown")
        return "mousePressed";
    else if (type == "mouseup")
        return "mouseReleased";
    else
        return "mouseMoved";
}

function get_target_center_point(rect) {
    return {
        x: rect.left+rect.width/2,
        y: rect.top+rect.height/2,
    };
}

MacroPlayer.prototype.dispatchMouseEvent = function(details) {
    let point = {}
    if (details.point) {
        point.x = details.point.x-details.targetRect.pageXOffset+
            details.targetRect.xOffset
        point.y = details.point.y-details.targetRect.pageYOffset+
            details.targetRect.yOffset
    } else {
        point = get_target_center_point(details.targetRect)
        point.x += details.targetRect.xOffset
        point.y += details.targetRect.yOffset
    }
    point.x = Math.round(point.x)
    point.y = Math.round(point.y)
    var type = get_mouse_event_name(details.type);
    return send_command(this.tab_id, "Input.dispatchMouseEvent", {
        "type": type,
        "button": get_mouse_button_name(details.button),
        "clickCount": details.clickCount || 0,
        "modifiers": get_modifiers_bitmask(details.modifiers),
        "x": point.x,
        "y": point.y
    });
};


MacroPlayer.prototype.ActionTable["event"] = function (cmd) {
    var type = imns.unwrap(this.expandVariables(cmd[1], "event1")).toLowerCase();
    var selector_type = cmd[2] ? cmd[2].toLowerCase() : "";
    var selector = cmd[3] ? imns.unwrap(this.expandVariables(cmd[3], "event3")) : "";
    var value_type = (cmd[4] || "").toLowerCase();
    var value = cmd[5] ? imns.unwrap(this.expandVariables(cmd[5], "event5")) : 0;
    var modifiers = cmd[6] ?
        imns.unwrap(this.expandVariables(cmd[6], "event6")) : "";

    var data = {scroll: true};
    data[selector_type || "selector"] = selector || ":root";

    this.attachDebugger().then(
        () => communicator.sendMessage(
            "activate-element", data, this.tab_id, this.currentFrame
        )
    ).then(response => {
        if (!response) {
            throw new RuntimeError(chrome.runtime.lastError.message);
        }
        else if (response.error)
            throw new RuntimeError(
                response.error.message, response.error.errnum
            )
        else
            this.clearRetryInterval()
        return response.targetRect
    }).then(targetRect => {
        var button = 0;
        var key = 0;
        var char = "";
        var point = null;

        if (!value_type) {
            ; // do nothing
        } else if (value_type == "button") {
            button = imns.s2i(value);
            if (isNaN(button))
                throw new BadParameter("integer BUTTON value", 3);
        } else if (value_type.toLowerCase() == "key") {
            key = imns.s2i(value);
            if (isNaN(key))
                throw new BadParameter("integer KEY value", 3);
        } else if (value_type.toLowerCase() == "char") {
            char = value;
        } else if (value_type.toLowerCase() == "point") {
            const point_re =
                /^\(\s*(\d+(?:\.\d+)?)\s*\,\s*(\d+(?:\.\d+)?)\s*\)$/;
            var m = null;
            if ( !(m = point_re.exec(value.trim())) )
                throw new BadParameter("(x,y) POINT value", 3);
            point = {x: parseFloat(m[1]), y: parseFloat(m[2])};
        }
        return Promise.resolve().then(() => {
            if (/^mouse/.test(type)) {
                var details = {
                    type: type,
                    point: point,
                    button: button,
                    modifiers: modifiers,
                    targetRect: targetRect
                };
                return this.dispatchMouseEvent(details);
            } else if (/^key/.test(type)) {
                var details = {
                    type: type,
                    key: key,
                    char: char,
                    modifiers: modifiers
                };
                return this.dispatchKeyboardEvent(details);
            } else if (type == "click") {
                // click is a result of mousedown/up
                return [
                    {clickCount: 1, type: "mousedown"},
                    {clickCount: 1, type: "mouseup"}
                ].map(x => ({
                    type: x.type,
                    clickCount: x.clickCount,
                    point: point,
                    button: button,
                    modifiers: modifiers,
                    targetRect: targetRect
                })).reduce((seq, details) => seq.then(
                    () => this.dispatchMouseEvent(details)
                ) , Promise.resolve())
            } else if (type == "dblclick") {
                // dblclick is a result of two mousedown/up
                return [
                    {clickCount: 1, type: "mousedown"},
                    {clickCount: 1, type: "mouseup"},
                    {clickCount: 2, type: "mousedown"},
                    {clickCount: 2, type: "mouseup"}
                ].map(x => ({
                    type: x.type,
                    clickCount: x.clickCount,
                    point: point,
                    button: button,
                    modifiers: modifiers,
                    targetRect: targetRect
                })).reduce((seq, details) => seq.then(
                    () => this.dispatchMouseEvent(details)
                ) , Promise.resolve())
            }
        })
    }).then(() => this.next("EVENT")).catch(e => {
        if (e.errnum == 721)    // if element not found
            this.retry(
                () => {
                    throw e
                }, "Tag waiting... ", "onActivateElement", this.timeout_tag
            )
        else
            this.handleError(e)
    })
};


MacroPlayer.prototype.RegExpTable["events"] =
        "type\\s*=\\s*("+im_strre+")"+
        "(?:\\s+(selector|xpath)\\s*=\\s*("+im_strre+"))?"+
        "(?:\\s+(keys|chars|points)\\s*=\\s*("+im_strre+"))?"+
        "(?:\\s+modifiers\\s*=\\s*("+im_strre+"))?";

MacroPlayer.prototype.ActionTable["events"] = function (cmd) {
    var type = imns.unwrap(this.expandVariables(cmd[1], "events1")).toLowerCase();
    var selector_type = cmd[2] ? cmd[2].toLowerCase() : "";
    var selector = cmd[3] ? imns.unwrap(this.expandVariables(cmd[3], "events3")) : "";
    var value_type = (cmd[4] || "").toLowerCase();
    var value = cmd[5] ? imns.unwrap(this.expandVariables(cmd[5], "events5")) : 0;
    var modifiers = cmd[6] ?
        imns.unwrap(this.expandVariables(cmd[6], "events6")) : "";
    var data = {scroll: true};
    data[selector_type || "selector"] = selector || ":root";
    this.attachDebugger().then(
        () => communicator.sendMessage(
            "activate-element", data, this.tab_id, this.currentFrame
        )
    ).then(response => {
        if (response.error)
            throw new RuntimeError(
                response.error.message, response.error.errnum
            )
        else
            this.clearRetryInterval()

        return response
    }).then(resp => {
        // parse value
        if (value_type.toLowerCase() == "chars") {
            if (resp.isPasswordElement) {
                return this.decrypt(value).then(decryptedString => ({
                    chars: decryptedString.split("")
                }))
            } else {
                return {chars: value.split("")}
            }
        } else if (value_type.toLowerCase() == "keys") {
            let keys_re = /\[\d+(?:\s*,\s*\d+)*\]/
                if ( !keys_re.test(value.trim()) )
                    throw new BadParameter("[k1,..,kn] as KEYS value", 3);
            return {keys: JSON.parse(value)}
        } else if (value_type.toLowerCase() == "points") {
            let points_re = /^(?:\s*\(\d+(?:\.\d+)?\s*\,\s*\d+(?:\.\d+)?\s*\)(?:\s*,\s*)?)+$/
                if ( !points_re.test(value.trim()) )
                    throw new BadParameter("(x,y)[,(x,y)] as POINTS value", 3);
            let point_re = /\(\s*(\d+(?:\.\d+)?)\s*\,\s*(\d+(?:\.\d+)?)\s*\)/g
            let points = []
            while(m = point_re.exec(value)) {
                points.push({x: parseFloat(m[1]), y: parseFloat(m[2])});
            }
            return {points: points, targetRect: resp.targetRect}
        }
    }).then(value => {
        if (type == "mousemove") {
            return value.points.map(point => ({
                type: type,
                point: point,
                targetRect: value.targetRect,
                modifiers: modifiers
            })).reduce((seq, details) => seq.then(
                () => this.dispatchMouseEvent(details)
            ) , Promise.resolve())
        } else if (/^key/.test(type) && value.keys) {
            return value.keys.map(key => ({
                type: type,
                key: key,
                modifiers: modifiers
            })).reduce((seq, details) => seq.then(
                () => this.dispatchKeyboardEvent(details)
            ) , Promise.resolve())
        } else if (/^key/.test(type) && value.chars) {
            return value.chars.map(char => ({
                type: type,
                char: char,
                modifiers: modifiers
            })).reduce((seq, details) => seq.then(
                () => this.dispatchKeyboardEvent(details)
            ), Promise.resolve())
        } else {
            throw RuntimeError("Can not process event type "+type, 711)
        }
    }).then(
        () => this.next("EVENTS")
    ).catch(e => {
        if (e.errnum == 721)    // if element not found
            this.retry(
                () => {
                    throw e
                }, "Tag waiting... ", "onActivateElement", this.timeout_tag
            )
        else
            this.handleError(e)
    })
};


MacroPlayer.prototype.decrypt = function(str) {
    this.waitingForPassword = true
    return Promise.resolve().then(() => {
        if (this.encryptionType == "no") {
            return str
        } else if (this.encryptionType == "stored") {
            let pwd = Storage.getChar("stored-password")
            // stored password is base64 encoded
            pwd = decodeURIComponent(atob(pwd))
            // throws error if password does not match
            return Rijndael.decryptString(str, pwd)
        } else if (this.encryptionType == "tmpkey") {
            let p = Rijndael.tempPassword ? Promise.resolve({
                password: Rijndael.tempPassword
            }) : dialogUtils.openDialog("passwordDialog.html",
                                        "iMacros Password Dialog",
                                        {type: "askPassword"})
            return p.then(result => {
                if (result.canceled) {
                    this.waitingForPassword = false
                    throw new RuntimeError(
                        "Password input has been canceled", 743
                    )
                }
                try {
                    let rv = Rijndael.decryptString(str, result.password)
                    Rijndael.tempPassword = result.password
                    return rv
                } catch(e) {
                    // wrong password, try again
                    return this.decrypt(str)
                }
            })
        } else {
            throw new RuntimeError(
                "Unsupported encryption type: "+this.encryptionType, 711
            )
        }
    }).then(decryptedString => {
        this.waitingForPassword = false
        return decryptedString
    }).catch(e => {
        this.waitingForPassword = false
        throw e
    })
}

// FRAME command http://wiki.imacros.net/FRAME
MacroPlayer.prototype.RegExpTable["frame"] =
    "^(f|name)\\s*=\\s*("+im_strre+")\\s*$";

MacroPlayer.prototype.onFrameComplete = function(data) {
    if (!data.frame) {
        var self = this;
        this.retry(function() {
            self.currentFrame = {number: 0};
            throw new RuntimeError("frame "+param+" not found", 722);
        }, "Frame waiting... ", "onFrameComplete", this.timeout_tag);
    } else {
        this.clearRetryInterval();
        this.currentFrame = data.frame;
        this.next("onFrameComplete");
    }
};

MacroPlayer.prototype.ActionTable["frame"] = function (cmd) {
    var type = cmd[1].toLowerCase();
    var param = imns.unwrap(this.expandVariables(cmd[2], "frame2"));
    var frame_data = new Object();

    if (type == "f") {
        param = imns.s2i(param);
        if (isNaN(param))
            throw new BadParameter("F=<number>", 1);

        // shortcut for main frame
        if (param == 0) {
            this.currentFrame = {number: 0};
            this.next("FRAME");
            return;
        }
    }

    if (type == "f")
        frame_data.number = param;
    else if (type == "name")
        frame_data.name = param;

    var self = this;

    communicator.postMessage("frame-command", frame_data, this.tab_id,
                             this.onFrameComplete.bind(this),
                             {number: 0});
};



// IMAGESEARCH command http://wiki.imacros.net/IMAGESEARCH
MacroPlayer.prototype.RegExpTable["imagesearch"] =
    "^pos\\s*=\\s*("+im_strre+
    ")\\s+image\\s*=\\s*("+im_strre+")\\s+"+
    "confidence\\s*=\\s*("+im_strre+")";

MacroPlayer.prototype.ActionTable["imagesearch"] = function (cmd) {
    var pos = imns.s2i(imns.unwrap(
        this.expandVariables(cmd[1], "imagesearch1")
    ));
    var image = imns.unwrap(this.expandVariables(cmd[2], "imagesearch2"));
    var cl = imns.s2i(imns.unwrap(
        this.expandVariables(cmd[3], "imagesearch3")
    ));

    if (!__is_windows()) {
        throw new UnsupportedCommand("IMAGESEARCH");
    }

    if (!this.afioIsInstalled) {
        throw new RuntimeError(
            "IMAGESEARCH command requires File IO interface", 660
        );
    }

    if (!__is_full_path(image)) {
        // NOTE: we assume here that defdatapath is already set which
        // may not be true under some (rare) circumstances
        var default_dir = afio.openNode(localStorage["defdatapath"]);
    default_dir.append(image);
    image = default_dir.path;
    }

    var mplayer = this;
    communicator.postMessage("webpage-hide-scrollbars",{hide: true}, mplayer.tab_id,()=>{});
    this.captureWebPage(function(_) {
        communicator.postMessage("webpage-hide-scrollbars",{hide: false}, mplayer.tab_id,()=>{});
    // chrome.tabs.captureVisibleTab(this.win_id, {format: "png"}, function(_) {
        const host = "com.ipswitch.imacros.host";
        var msg_no_free_beer = "This feature requires"+
            " the iMacros image recognition library,"+
            " which is part of the commercial iMacros Standard"+
            " and Enterprise Editions";
        var re = /data\:([\w-]+\/[\w-]+)?(?:;(base64))?,(.+)/;
        var m = re.exec(_);
        if (!m) {
            mplayer.handleError(
                new RuntimeError("Can not parse image data"+_), 701
            );
            return;
        }
        console.assert(m[1] == "image/png");
        var request = {
            type: "do_image_search",
            image_data: m[3],
            sample_path: image,
            pos: pos-1,         // zero-based index expected
            cl: cl
        };
        chrome.runtime.sendNativeMessage(host, request, function(result) {
            if (chrome.runtime.lastError) {
                var nf = "Specified native messaging host not found";
                if (chrome.runtime.lastError.message.match(nf)) {
                    mplayer.handleError(
                        new RuntimeError(msg_no_free_beer), 702
                    );
                } else {
                    mplayer.handleError(chrome.runtime.lastError);
                }
                return;
            }

            if (result.type == "error") {
                mplayer.handleError(new RuntimeError(result.error), 703);
                return;
            }

            if(!result.found) {
                mplayer.retry(function() {
                    throw new RuntimeError(
                        "Image specified by "+image+
                            " does not match the web-page", 727);
                }, "Image waiting... ", "onImageSearch", mplayer.timeout_tag*4);
                return;
            }
            mplayer.clearRetryInterval();
            communicator.postMessage(
                "image-search-command",
                result, mplayer.tab_id,
                function() {
                    mplayer.imageX = result.x;
                    mplayer.imageY = result.y;
                    mplayer.next("IMAGESEARCH");
                },
                {number: 0}
            );
        });
    });
};



// ONDOWNLOAD command http://wiki.imacros.net/ONDOWNLOAD
MacroPlayer.prototype.RegExpTable["ondownload"] =
    "^folder\\s*=\\s*("+im_strre+")\\s+"+
    "file\\s*=\\s*("+im_strre+")"+
    "(?:\\s+wait\\s*=(yes|no|true|false))?"+
    "(?:\\s+checksum\\s*=(md5|sha1):(\\S+))?"+
    "\\s*$";

MacroPlayer.prototype.ActionTable["ondownload"] = function (cmd) {
    var obj = new Object();
    var wait = true;
    var folder = imns.unwrap(this.expandVariables(cmd[1], "ondownload1"));
    
    if (folder !== "*" && !this.afioIsInstalled) {
        throw new BadParameter("FOLDER requires File Access for iMacros Extensions. Specify FOLDER=* to save file to the browser's default download folder.");
    }
    
    var file = imns.unwrap(this.expandVariables(cmd[2], "ondownload2"));
    if (typeof cmd[3] != "undefined") {
        var param = imns.unwrap(this.expandVariables(cmd[3], "ondownload3"));
        wait = /^(?:yes|true)$/i.test(param);
    }
    if (typeof cmd[4] != "undefined") {
        // TODO: add checksum check support to afio.exe?
        throw new UnsupportedCommand("ONDOWNLOAD ... CHECKSUM=");
        // if (!wait) {
        //     throw new BadParameter("CHECKSUM requires WAIT=YES", 3);
        // }
        // this.downloadCheckAlg = imns.unwrap(
        //     this.expandVariables(cmd[4], "ondownload4")
        // );
        // this.downloadChecksum = imns.unwrap(
        //     this.expandVariables(cmd[5], "ondownload5")
        // ).toLowerCase();
    }

    // a sanity check to ensure that only one ONDOWNLOAD was set for an action
    if (this.waitForDownloadCreated) {
        throw new Error("only one ONDOWNLOAD command should be used for each download");
    }

    this.waitForDownloadCreated = true;
    this.waitForDownloadCompleted = wait;
    this.downloadFolder = folder;
    this.downloadFilename = file;
    this.shouldDownloadPDF = true;
    if (!this.downloadHooksRegistered) {
        this.downloadHooksRegistered = true
        chrome.downloads.onCreated.addListener(this._onDownloadCreated);
        chrome.downloads.onChanged.addListener(this._onDownloadChanged);
        context.registerDfHandler(this.win_id);
    }
    this.next("ONDOWNLOAD");
};

// a handler passed to a singleton onDeterminingFilename event listener
// stored in context object
MacroPlayer.prototype.onDeterminingFilename = function(dl, suggest) {
    if (!this.activeDownloads.has(dl.id))
        return false;

    //  Get file name and extension from the source uri.
    var filename = "", m = null, name = "", ext = "";
    if ( m = dl.url.match(/\/([^\/?]+)(?=\?.+|$)/) ) {
    name = m[1];
    if (m = name.match(/\.([^\.\s]+)$/)) {
        ext = m[1];
        name = name.replace(/\.[^\.\s]+$/, "");
    }
    }
    var dl_obj = this.activeDownloads.get(dl.id);
    if (dl_obj.downloadFilename == "*") {
        return false;
    } else if (/^\+/.test(dl_obj.downloadFilename)) {
    filename = name+dl_obj.downloadFilename.substring(1)+"."+ext;
    } else {
        // TODO: I'm not sure if we should replace the provided extension
    // if (/\.[^\.\s]+$/i.test(this.downloadFilename))
    //     filename = this.downloadFilename.replace(/\.[^\.\s]+$/, "."+ext);
    // else
    filename = dl_obj.downloadFilename;
    }
    // NOTE: I guess "overwrite" is the proper action here since user
    // should know best if any name conflicts are possible
    suggest({filename: filename, conflictAction: "overwrite"});

    return true;
};



MacroPlayer.prototype.onDownloadCompleted = function(id) {
    // console.log("onDownloadCompleted, id=%d", id);
    var dl_obj = this.activeDownloads.get(id);
    this.activeDownloads.delete(id);

    // do cleanup
    if (this.downloadHooksRegistered && this.activeDownloads.size == 0) {
        chrome.downloads.onCreated.removeListener(this._onDownloadCreated);
        chrome.downloads.onChanged.removeListener(this._onDownloadChanged);
        context.unregisterDfHandler(this.win_id);
        this.downloadHooksRegistered = false
    }

    if (!this.afioIsInstalled) {
        if (this.waitForDownloadCompleted) {
            this.next("onDownloadCompleted");
            this.stopTimer("download");
            this.waitForDownloadCompleted = false;
        }
        return;
    }
    var dest_dir = null;
    if (dl_obj.downloadFolder == "*") {
        dest_dir = this.defDownloadFolder.clone()
    } else {
        dest_dir = afio.openNode(dl_obj.downloadFolder);
    }
    var mplayer = this;
    dest_dir.exists().then(function(exists) {
        if (!exists)
            throw new RuntimeError("Path "+folder+" does not exist", 732);

        var file = afio.openNode(dl_obj.downloadFilename);
        dest_dir.append(file.leafName);
        // set !DOWNLOADED_FILE_NAME
        mplayer.downloadedFilename = dest_dir.path;
        // console.log("onDownloadCompleted, id=%d, file=%s, dest=%s", id,
        //             file.path, dest_dir.path);
        return dest_dir.exists().then(function(exists) {
            // a workaroud  for Windows - remove existing file before moving
            // the downloaded file
            return exists ?  dest_dir.remove() : Promise.resolve();
        }).then(function() {
            return file.moveTo(dest_dir).then(function() {
                if (mplayer.waitForDownloadCompleted) {
                    mplayer.stopTimer("download");
                    mplayer.waitForDownloadCompleted = false;
                    mplayer.next("onDownloadCompleted");
                }
            });
        });
    }).catch(function(err) {
        mplayer.handleError(err);
    });
};


MacroPlayer.prototype.onDownloadCreated = function(dl) {
    // console.log("onDownloadCreated %O", dl);
    if (dl.state != "in_progress")
        return;
    if (dl.referrer && dl.referrer != this.currentURL)
        return;
    console.assert(this.waitForDownloadCreated);
    // a scary warning to handle messed up cases where TAG command
    // that triggers a download precedes ONDOWNLOAD command (see #414)
    if (!this.waitForDownloadCreated) {
        this.handleError(new Error(
            "A download is started but no matching ONDOWNLOAD command was found"
        ));
        return;
    }
    this.waitForDownloadCreated = false;

    // NOTE: it is not guaranteed that this is 'our' download because other
    // tabs with the very same URL may initiate a download at the same time
    var dl_obj = {
        downloadFilename: this.downloadFilename,
        downloadFolder: this.downloadFolder
    };
    this.activeDownloads.set(dl.id, dl_obj);
    this.downloadedSize = dl.fileSize;
    if (this.waitForDownloadCompleted) {
        var mplayer = this;
        this.startTimer(
            "download",
            this.timeout_download,
            "Loading file ",
            function() {
                mplayer.waitForDownloadCompleted = false;
                mplayer.handleError(
                    new RuntimeError("Download timeout", 604));
            });
    } else {
        this.next("onDownloadCreated");
    }
};

MacroPlayer.prototype.onDownloadChanged = function(changeInfo) {
    // console.log("onDownloadChanged %O", changeInfo);
    if (!this.activeDownloads.has(changeInfo.id))
        return;

    if (changeInfo.filename) {
        this.activeDownloads.get(changeInfo.id).downloadFilename =
            changeInfo.filename.current;
        // set !DOWNLOADED_FILE_NAME
        this.downloadedFilename = changeInfo.filename.current;
    }
    if (changeInfo.state && changeInfo.state.current == "complete") {
        this.onDownloadCompleted(changeInfo.id);
    }
};

MacroPlayer.prototype.saveTarget = function(url) {
    var self = this;
    chrome.downloads.download({url: url}, function(dl_id) {
        // NOTE: The download object will be set inside
        // onDownloadCreated handler
        // console.log("download id=%d", dl_id);
        // var dl_obj = {
        //     downloadFilename: this.downloadFilename,
        //     downloadFolder: this.downloadFolder
        // };
        // self.activeDownloads.set(dl_id, dl_obj);
    });
};

// ONERRORDIALOG command http://wiki.imacros.net/ONERRORDIALOG

MacroPlayer.prototype.RegExpTable["onerrordialog"] =
    "^(?:button\\s*=\\s*(?:\\S*))?\\s*(?:\\bcontinue\\s*=\\s*(\\S*))?\\s*$"

MacroPlayer.prototype.ActionTable["onerrordialog"] = function (cmd) {
    var param = cmd[1] ? imns.unwrap(this.expandVariables(cmd[1], "onerrordialog1")) : "";
    if (/^no|false$/i.test(param)) {
        this.shouldStopOnError = true;
    }

    this.next("ONERRORDIALOG");
};


MacroPlayer.prototype.onErrorOccurred = function(data) {
    if (!this.playing || !this.shouldStopOnError)
        return;

    this.handleError(data);
};

// TODO: maybe onscripterror should have another syntax?
// now these are plain references
MacroPlayer.prototype.RegExpTable["onscripterror"] =
    MacroPlayer.prototype.RegExpTable["onerrordialog"];


MacroPlayer.prototype.ActionTable["onscripterror"] =
    MacroPlayer.prototype.ActionTable["onerrordialog"];



// ONLOGIN command http://wiki.imacros.net/ONLOGIN
MacroPlayer.prototype.RegExpTable["onlogin"] =
    "^user\\s*=\\s*("+im_strre+")\\s+"+
    "password\\s*=\\s*("+im_strre+")\\s*$";

MacroPlayer.prototype.ActionTable["onlogin"] = function (cmd) {
    var username = imns.unwrap(this.expandVariables(cmd[1], "onlogin1"));
    var password = imns.unwrap(this.expandVariables(cmd[2], "onlogin2"));
    this.loginData = {
        username: username
    }
    this.waitForAuthDialog = true;
    chrome.webRequest.onAuthRequired.addListener(
        this.onAuth,
        {windowId: this.win_id, urls: ["<all_urls>"]},
        ["blocking"]
    );
    this.decrypt(password).then(decryptedString => {
        this.loginData.password = decryptedString
    }).then(() => this.next("ONLOGIN")).catch(e => this.handleError(e))
};


// PAUSE command http://wiki.imacros.net/PAUSE
MacroPlayer.prototype.RegExpTable["pause"] = "^\\s*$";

MacroPlayer.prototype.ActionTable["pause"] = function (cmd) {
    this.pause();
    this.next("PAUSE");
};


// PROMPT command http://wiki.imacros.net/PROMPT
MacroPlayer.prototype.RegExpTable["prompt"] =
    "^("+im_strre+")"+
    "(?:\\s+("+im_strre+")"+
    "(?:\\s+("+im_strre+"))?)?\\s*$";

MacroPlayer.prototype.ActionTable["prompt"] = function (cmd) {
    if (this.noContentPage("PROMPT"))
        return;

    var x = {};
    x.text = imns.unwrap(this.expandVariables(cmd[1], "prompt1"));

    if (typeof(cmd[2]) != "undefined") {
        if (this.limits.varsRe.test(cmd[2])) {
            x.varnum = imns.s2i(RegExp.$1);
        } else if (/^[^!]\S*/.test(cmd[2])) {
            this.checkFreewareLimits("user_vars", null);
            x.varname = cmd[2];
        } else {
            throw new BadParameter("Unsupported variable "+cmd[2]);
        }
    }

    if (typeof(cmd[3]) != "undefined") {
        x.defval = imns.unwrap(this.expandVariables(cmd[3], "prompt3"));
    }

    try {
        if (typeof (x.varnum) != "undefined" ||
            typeof (x.varname) != "undefined") {
            var mplayer = this;
            let p = dialogUtils.openDialog("promptDialog.html",
                "iMacros Prompt Dialog",
                { type: "askInput", text: x.text, default: x.defval });
            return p.then(function (result) {
                var retobj = {varnum: x.varnum, varname: x.varname};
                retobj.value = "";
                if (!result.canceled) {
                    retobj.value = result.inputValue;
                }
                if (typeof (retobj.varname) != "undefined") {
                    mplayer.setUserVar(retobj.varname, retobj.value);
                } else if (typeof (retobj.varnum) != "undefined") {
                    mplayer.vars[imns.s2i(retobj.varnum)] = retobj.value;
                }
                mplayer.next("onPromptComplete");
                return
            })
        } else {
            var mplayer = this;
            let p = dialogUtils.openDialog("promptDialog.html",
                "iMacros Prompt Dialog",
                { type: "alert", text: x.text });
            return p.then(function (result) {
                mplayer.next("onPromptComplete");
                return
            })

        }

    } catch (e) {
        this.handleError(e);
    }
};

MacroPlayer.prototype.onPromptComplete = function(data) {
    if (typeof(data.varname) != "undefined") {
        this.setUserVar(data.varname, data.value);
    } else if (typeof(data.varnum) != "undefined") {
        this.vars[imns.s2i(data.varnum)] = data.value;
    }
    this.next("onPromptComplete");
};


// PROXY command http://wiki.imacros.net/PROXY
MacroPlayer.prototype.RegExpTable["proxy"] =
    "^address\\s*=\\s*("+im_strre+")"+
    "(?:\\s+bypass\\s*=\\s*("+im_strre+")\\s*)?$";


MacroPlayer.prototype.setProxySettings = function(config) {
    // set new proxy settings
    var mplayer = this;
    chrome.proxy.settings.set(
        {value: config},
        function() {
            mplayer.next("PROXY");
        }
    );
};

MacroPlayer.prototype.storeProxySettings = function(callback) {
    var mplayer = this;
    // first we should store old settings
    chrome.proxy.settings.get(
        {'incognito': false},
        function(config) {
            mplayer.proxySettings = config.value;
            typeof(callback) == "function" && callback();
        }
    );
};


MacroPlayer.prototype.restoreProxySettings = function() {
    if (!this.proxySettings)
        return;
    if (this.proxySettings.mode == "system") {
        chrome.proxy.settings.clear({});
    } else {
        chrome.proxy.settings.set(
            {value: this.proxySettings, 'incognito': false},
            function() {}
        );
    }
};


// for possible bypass values see
// http://code.google.com/chrome/extensions/experimental.proxy.html#bypass_list

MacroPlayer.prototype.ActionTable["proxy"] = function (cmd) {
    var address = imns.unwrap(this.expandVariables(cmd[1], "proxy1"));
    var bypass = cmd[2]? imns.unwrap(this.expandVariables(cmd[2], "proxy2")):
        null;

    if (!chrome.proxy) {
        throw new RuntimeError("PROXY command can not be executed because"+
                               " chrome.proxy module unavailable", 610);
    }

    var addr_re = /^(?:(https?)\s*=\s*)?([\d\w\.]+):(\d+)\s*$/;
    var m = addr_re.exec(address);
    if (!m) {
        throw new BadParameter("server name or IP address with port number", 1);
    }

    var https = (m[1] == "https");
    var server = m[2];
    var port = imns.s2i(m[3]);

    var config = {
        mode: "fixed_servers",
        rules: {
            singleProxy: {}
        }
    };

    config.rules.singleProxy["scheme"] = https ? "https" : "http";
    config.rules.singleProxy["host"] = server;
    config.rules.singleProxy["port"] = port;

    if (bypass) {
        if (!/^null$/i.test(bypass)) {
            config.rules.bypassList = bypass.split(",");
        }
    }
    var mplayer = this;
    if (!this.proxySettings)
        this.storeProxySettings(function() {
            mplayer.setProxySettings(config);
        });
    else
       this.setProxySettings(config);

};


// REFRESH command http://wiki.imacros.net/REFRESH
MacroPlayer.prototype.RegExpTable["refresh"] = "^\\s*$";

MacroPlayer.prototype.ActionTable["refresh"] = function (cmd) {
    if (this.noContentPage("REFRESH"))
        return;

    chrome.tabs.get(this.tab_id, function(tab) {
        if (/^(?:https?|file)/.test(tab.url))
            communicator.postMessage("refresh-command", {}, tab.id,
                                     function() {},
                                     {number: 0});
    });
    // mplayer.next() will be called on load-complete event
};


// utility functions for next two commands

// get file name of the page, e.g. index.html
var __doc_name = function(url) {
    // use the location file name if present
    var name = url;
    if (/\/([^\/?]*)(?:\?.*)?$/.test(url))
        name = RegExp.$1;
    // if name is empy use server name
    if (!name.length) {
        if (/^https?:\/\/(?:www\.)?([^\/]+)/.test(url))
            name = RegExp.$1;
    }

    return name;
};


// ensure that filename has an extension or add .ext
var __ensure_ext = function(filename, ext) {
    if (!(new RegExp("\\."+ext+"$")).test(filename)) {
        return filename+"."+ext;
    } else {
        return filename;
    }
};


// SAVEAS command http://wiki.imacros.net/SAVEAS
MacroPlayer.prototype.RegExpTable["saveas"] =
    "^type\\s*=\\s*(\\S+)\\s+"+
    "folder\\s*=\\s*("+im_strre+")\\s+"+
    "file\\s*=\\s*("+im_strre+")\\s*$";

function getSaveAsFile(mplayer, folder, filename, type) {
    if (!mplayer.afioIsInstalled)
        throw new RuntimeError(
            "SAVEAS requires File IO interface installed", 660
        );

    let f = folder == "*" ?
        mplayer.defDownloadFolder.clone() : afio.openNode(folder)

    return f.exists().then(function(exists) {
        if (!exists) {
            throw new RuntimeError("Path "+folder+" does not exist", 732);
        }
        let defaultName = (type == "extract") ? "extract" : __doc_name(mplayer.currentURL);
        if (filename == "*") {
            filename = defaultName;
        } else if (filename.match(/^\+(.+)$/)) {
            filename = defaultName + RegExp.$1;
        }
        // replace illegal file name characters < > : " / \ | ? * by underscores
        var re = new RegExp('\\s*[:*?|<>\\"/]+\\s*', "g");
        filename = filename.replace(re, "_");
        if (type == "extract") {
            f.append(__ensure_ext(filename, "csv"));
        } else if (type == "mht") {
            f.append(__ensure_ext(filename, "mht"));
        } else if (type == "txt" || type == "htm") {
            f.append(__ensure_ext(filename, type));
        } else if (/^png|jpeg$/.test(type)) {
            f.append(__ensure_ext(filename, type == "jpeg"? "jpg": "png"));
        } else {
            throw new BadParameter("iMacros for Chrome supports only "+
                                   "MHT|HTM|TXT|EXTRACT|PNG|JPEG SAVEAS types")
        }

        return f;
    });
}

MacroPlayer.prototype.ActionTable["saveas"] = function (cmd) {
    if (this.noContentPage("SAVEAS"))
        return;

    var folder = imns.unwrap(this.expandVariables(cmd[2], "saveas2"));
    var type = imns.unwrap(this.expandVariables(cmd[1], "saveas1")).
        toLowerCase();
    var filename = imns.unwrap(this.expandVariables(cmd[3], "saveas3"));

    let mplayer = this;
    getSaveAsFile(mplayer, folder, filename, type).then(f => {
        if (type == "extract") {
            let data = mplayer.getExtractData();
            mplayer.clearExtractData();
            data = data.replace(/\"/g, '""');
            data = '"'+data.replace(/\[EXTRACT\]/g, '"'+
                                    mplayer.dataSourceDelimiter+
                                    '"')+'"';
            afio.appendTextFile(f, data+(__is_windows() ? "\r\n" : "\n"))
                .then(() => mplayer.next("SAVEAS"))
                .catch(err => mplayer.handleError(err));
        } else if (type == "mht") {
            chrome.pageCapture.saveAsMHTML(
                {tabId: mplayer.tab_id},
                function(data) {
                    let reader = new FileReader();
                    reader.onload = function(event) {
                        afio.writeTextFile(f, event.target.result)
                            .then(() => mplayer.next("SAVEAS"))
                            .catch(e => mplayer.handleError(e));
                    };
                    reader.onerror = function(event) {
                        mplayer.handleError(event.target.error);
                    };
                    reader.readAsText(data);
                }
            )
        } else if (type == "txt" || type == "htm") {
            // NOTE: both txt and htm save only topmost frame data
            communicator.postMessage(
                "saveas-command", {type: type}, mplayer.tab_id,
                function(data) {
                    afio.writeTextFile(f, data)
                        .then(() => mplayer.next("SAVEAS"))
                        .catch(e => mplayer.handleError(e));
                },
                {number: 0}
            );
        } else if (/^png|jpeg$/.test(type)) {
            communicator.postMessage("webpage-hide-scrollbars",{hide: true}, mplayer.tab_id,()=>{});
            mplayer.captureWebPage(function(data) {
                communicator.postMessage("webpage-hide-scrollbars",{hide: false}, mplayer.tab_id,()=>{});
                var re = /data\:([\w-]+\/[\w-]+)?(?:;(base64))?,(.+)/;
                var m = re.exec(data);
                var imageData = {
                    image: m[3],
                    encoding: m[2],
                    mimeType: m[1]
                };
                afio.writeImageToFile(f, imageData)
                    .then(() => mplayer.next("SAVEAS"))
                    .catch(e => mplayer.handleError(e));
            }, type);
        }
    }).catch(e => mplayer.handleError(e))
};


// SCREENSHOT command
MacroPlayer.prototype.RegExpTable["screenshot"] =
    "^type\\s*=\\s*(browser|page)\\s+"+
    "folder\\s*=\\s*("+im_strre+")\\s+"+
    "file\\s*=\\s*("+im_strre+")\\s*$";

MacroPlayer.prototype.doSplitCycle = function(canvas, ctx, moves, type, callback) {
    if (moves.length == 0) {
        callback(canvas.toDataURL())
    } else {
        let mplayer = this
        let [move, ...rest] = moves
        communicator.postMessage(
            "webpage-scroll-to",
            {x: move.x_offset, y: move.y_offset},
            this.tab_id,
            () => {
                chrome.tabs.captureVisibleTab(
                    this.win_id, {format: type}, dataURL => {
                        let img = new Image(move.width, move.height)
                        img.src = dataURL
                        img.onload = () => {                            
                            ctx.drawImage(img, move.x_offset, move.y_offset);
                            this.doSplitCycle(canvas, ctx, rest, type, callback)
                        }
                    }
                )
            }, {number: 0}
        )
    }
};

MacroPlayer.prototype.splitPage = function(dmns, type, callback) {
    let overlap = 200; // minimum overlap, to avoid sticky headers.
    let split = function(w, x, xs) {
        if (w == 0) {
            return xs
        } else {
            if(w - x > 0) {
                let n = Math.ceil(w / (x-overlap));
                let delta = Math.ceil(w/n);
                xs = new Array(n).fill(delta);
            } else {
                xs.push(w)
            }            
            return xs
        }
    }
    // steps to perform in x-direction
    let xs = split(dmns.doc_w, dmns.win_w, [])
    // steps to perform in y-direction
    let ys = split(dmns.doc_h, dmns.win_h, [])
    // the two above combined and flattened
    let [moves, ] = ys.reduce(([y_acc, y_offset], y_step) => {
        let [x_moves, ] = xs.reduce(([x_acc, x_offset], x_step) => {
            let move = {
                // if this is the last piece, make the offset as large as its size, so that it sits at the end.
                x_offset: (x_offset + dmns.win_w) <=  dmns.doc_w ? x_offset : dmns.doc_w - dmns.win_w,
                y_offset: (y_offset + dmns.win_h) <=  dmns.doc_h ? y_offset : dmns.doc_h - dmns.win_h,
                width: dmns.win_w,
                height:  dmns.win_h
            }
            return [x_acc.concat(move), x_offset + x_step]
        }, [[], 0])
        return [y_acc.concat(x_moves), y_offset + y_step]
    }, [[], 0])
    let canvas = document.createElementNS("http://www.w3.org/1999/xhtml",
                      "canvas");
    canvas.style.width = dmns.doc_w+"px";
    canvas.style.height = dmns.doc_h+"px";
    canvas.width = dmns.doc_w;
    canvas.height = dmns.doc_h;
    let ctx = canvas.getContext("2d");
    // Start from the end. If starting from the beginning, sticky headers appear, avoiding sticky footers instead.
    moves.reverse();  
    this.doSplitCycle(canvas, ctx, moves, type, callback);
};

MacroPlayer.prototype.captureWebPage = function(callback, type) {
    var mplayer = this;
    communicator.postMessage(
        "query-page-dimensions",
        {}, this.tab_id,
        function(dmns) {
            mplayer.splitPage(dmns, type || "png",  callback);
        },
        {number: 0}
    );
};

MacroPlayer.prototype.ActionTable["screenshot"] = function (cmd) {
    if (this.noContentPage("SCREENSHOT"))
        return;
    if (!this.afioIsInstalled)
        throw new RuntimeError("SCREENSHOT requires File IO interface", 660);

    var folder = imns.unwrap(this.expandVariables(cmd[2], "screenshot2"));
    var type = imns.unwrap(this.expandVariables(cmd[1], "screenshot1")).
        toLowerCase();
    if (type != "page") {
        throw new BadParameter("SCREENSHOT TYPE="+type.toUpperCase()+
                             " is not supported");
    }

    var f = null;
    if (folder == "*") {
        f = this.defDownloadFolder.clone()
    } else {
        f = afio.openNode(folder);
    }

    var file = imns.unwrap(this.expandVariables(cmd[3], "saveas3")), t;

    var mplayer = this;
    f.exists().then(function(exists) {
        if (!exists) {
            throw new RuntimeError("Path "+folder+" does not exist", 732)
        }

        if (file == "*") {
            file = __doc_name(mplayer.currentURL);
        } else if (t = file.match(/^\+(.+)$/)) {
            file = __doc_name(mplayer.currentURL) + t[1];
        }

        // replace illegal file name characters < > : " / \ | ? * by underscores
        var re = new RegExp('\\s*[:*?|<>\\"/]+\\s*', "g");
        file = file.replace(re, "_");
        f.append(__ensure_ext(file, "png"));
        communicator.postMessage("webpage-hide-scrollbars",{hide: true}, mplayer.tab_id,()=>{});
        mplayer.captureWebPage(function(data) {
            communicator.postMessage("webpage-hide-scrollbars",{hide: false}, mplayer.tab_id,()=>{});
            var re = /data\:([\w-]+\/[\w-]+)?(?:;(base64))?,(.+)/;
            var m = re.exec(data);
            var imageData = {
                image: m[3],
                encoding: m[2],
                mimeType: m[1]
            };
            afio.writeImageToFile(f, imageData).then(function() {
                mplayer.next("SCREENSHOT");
            }).catch(function(e) {
                mplayer.handleError(e);
            });
        });
    }).catch(function(err) {
        mplayer.handleError(err);
    });
};


// SEARCH command
MacroPlayer.prototype.RegExpTable["search"] =
    "^source\\s*=\\s*(txt|regexp):("+im_strre+")"+
    "(?:\\s+ignore_case\\s*=\\s*(yes|no))?"+
    "(?:\\s+extract\\s*=\\s*("+im_strre+"))?\\s*$";

MacroPlayer.prototype.ActionTable["search"] = function (cmd) {
    var query = imns.unwrap(this.expandVariables(cmd[2]));
    var extract = cmd[4] ? imns.unwrap(this.expandVariables(cmd[4])) : "";
    var ignore_case = cmd[3] && /^yes$/i.test(cmd[3]) ? "i" : "";
    var search_re;

    // check if EXTRACT is present
    if (extract && !(cmd[1].toLowerCase() == "regexp"))
        throw new BadParameter("EXTRACT has sense only for REGEXP search");

    var data = {
        type: cmd[1].toLowerCase(),
        query: query,
        extract: extract,
        ignore_case: ignore_case
    };

    communicator.postMessage("search-command", data, this.tab_id,
                             this.onSearchComplete.bind(this),
                             this.currentFrame);
};


MacroPlayer.prototype.onSearchComplete = function(data) {
    if (data.error) {
        this.handleError(data.error);
    } else {
        if (data.extract)
            this.showAndAddExtractData(data.extract);
        this.next("onSearchComplete");
    }
};


// SET command http://wiki.imacros.net/SET
MacroPlayer.prototype.RegExpTable["set"] =
    "^(\\S+)\\s+("+im_strre+")\\s*$";


MacroPlayer.prototype.ActionTable["set"] = function (cmd) {
    var param = imns.unwrap(this.expandVariables(cmd[2], "set2"));
    var mplayer = this;
    switch(cmd[1].toLowerCase()) {
    case "!encryption":
        switch(param.toLowerCase()) {
        case "no":
            this.encryptionType = "no"; break;
        case "storedkey": case "yes":
            this.encryptionType = "stored"; break;
        case "tmpkey":
            this.encryptionType = "tmpkey"; break;
        default:
            throw new BadParameter("!ENCRYPTION can be only "+
                                   "YES|NO|STOREDKEY|TMPKEY");
        }

        break;
    case "!downloadpdf":
        // TODO: not very clear what to do with that command
        this.shouldDownloadPDF = /^yes$/i.test(param); break;
    case "!loop":
        if (this.firstLoop) {
            loop = imns.s2i(param)
            if (isNaN(loop))
                throw new BadParameter("!LOOP must be integer");
            this.currentLoop = this.checkFreewareLimits("loops", loop)
            var panel = context[this.win_id].panelWindow;
            if (panel && !panel.closed)
                panel.setLoopValue(this.currentLoop);
        }
        break;
    case "!extract":
        this.clearExtractData();
        if (!/^null$/i.test(param))
            this.addExtractData(param);
        break;
    case "!extractadd":
        this.addExtractData(param); break;
    case "!extract_test_popup":
        this.shouldPopupExtract = /^yes$/i.test(param); break;
    case "!errorignore":
        this.ignoreErrors = /^yes$/i.test(param); break;
    case "!datasource":
        if (!this.afioIsInstalled) {
            throw new RuntimeError(
                "!DATASOURCE requires File IO interface", 660
            );
        }
        this.loadDataSource(param)
            .then(() => this.next("SET"))
            .catch(e => this.handleError(e))
        return;
    case "!datasource_line":
        var x = imns.s2i(param);
        if (isNaN(x) || x <= 0)
            throw new BadParameter("!DATASOURCE_LINE must be positive integer");
        if (this.dataSource.length < x)
            throw new RuntimeError("Invalid DATASOURCE_LINE value: "+
                                   param, 751);
        this.dataSourceLine = x;
        break;
    case "!datasource_columns":
        if (isNaN(imns.s2i(param)))
                throw new BadParameter("!DATASOURCE_COLUMNS must be integer");
        this.dataSourceColumns = imns.s2i(param);
        break;
    case "!datasource_delimiter":
        if (param.length > 1)
            throw new BadParameter("!DATASOURCE_DELIMITER must be single character");
        this.dataSourceDelimiter = param;
        break;
    case "!folder_datasource":
        if (!this.afioIsInstalled) {
            throw new RuntimeError(
                "!FOLDER_DATASOURCE requires File IO interface", 660
            );
        }
        this.dataSourceFolder = afio.openNode(param);
        this.dataSourceFolder.exists().then(exists => {
            if (!exists) {
                this.handleError( new RuntimeError(
                    "can not write to FOLDER_DATASOURCE: "+
                        param+" does not exist or not accessible.", 732
                ));
            }
        }).then(() => {
            this.next("SET");
        }).catch(err => {
            this.handleError(new RuntimeError(
                "can not open FOLDER_DATASOURCE: "+
                    param+", error "+err.message, 732
            ));
        });
        return;
    case "!folder_download":
        if (!this.afioIsInstalled) {
            throw new RuntimeError(
                "!FOLDER_DOWNLOAD requires File IO interface", 660
            );
        }
        this.defDownloadFolder = afio.openNode(param);
        this.defDownloadFolder.exists().then(exists => {
            if (!exists) {
                this.handleError( new RuntimeError(
                    "can not write to FOLDER_DOWNLOAD: "+
                        param+" does not exist or not accessible.", 732
                ));
            }
        }).then(() => {
            this.next("SET");
        }).catch(err => {
            this.handleError(new RuntimeError(
                "can not open FOLDER_DOWNLOAD: "+
                    param+", error "+err.message, 732
            ));
        });
        return;
    case "!timeout": case "!timeout_page":
        var x = imns.s2i(param);
        if (isNaN(x) || x <= 0)
            throw new BadParameter("!TIMEOUT must be positive integer");
        this.timeout = x;
        this.timeout_tag = Math.round(this.timeout/10);
        break;
    case "!timeout_tag": case "!timeout_step":
        var x = imns.s2i(param);
        if (isNaN(x) || x < 0)
            throw new BadParameter("!TIMEOUT_TAG must be positive integer");
        this.timeout_tag = x;
        break;
    case "!timeout_download":
        var x = imns.s2i(param);
        if (isNaN(x) || x < 0)
            throw new BadParameter("!TIMEOUT_DOWNLOAD must be positive integer");
        this.timeout_download = x;
        break;
    case "!timeout_macro":
        var x = parseFloat(param);
        if (isNaN(x) || x <= 0)
            throw new BadParameter("!TIMEOUT_MACRO must be positive number");
        this.globalTimer.setMacroTimeout(x);
        break;
    case "!clipboard":
        imns.Clipboard.putString(param);
        break;
    case "!filestopwatch":
        if (!this.afioIsInstalled)
            throw new RuntimeError(
                "!FILESTOPWATCH requires File IO interface", 660
            );
        var filename = param, file;
        if (__is_full_path(filename) ) { // full path
            file = afio.openNode(filename);
        } else {
            file = this.defDownloadFolder.clone()
            file.append(filename);
        }
        var parent = file.parent;
        var mplayer = this;
        parent.exists().then(function(exists) {
            if (!exists)
                throw new RuntimeError("Path "+parent.path+
                                       " does not exists", 732);
        }).then(function() {
            return afio.appendTextFile(file, "").catch(function(e) {
                    var reason = "";
                    if (/ACCESS_DENIED/.test(e.toString()))
                        reason = ", access denied";
                   throw new RuntimeError(
                        "can not write to STOPWATCH file: "+
                            file.path+reason, 731);
            });
        }).then(function() {
            mplayer.stopwatchFile = file;
            mplayer.shouldWriteStopwatchFile = true;
            mplayer.next("SET");
        }).catch(function(err) {
            mplayer.handleError(err);
        });
        return;
    case "!folder_stopwatch":
        if (param.toLowerCase() == "no") {
            this.shouldWriteStopwatchFile = false;
        } else {
            this.stopwatchFolder = afio.openNode(param);
        // TODO: isWritable is buggy on Windows as it can only check files
        // if (!this.stopwatchFolder.isWritable) {
            //  throw new RuntimeError("can not write to STOPWATCH folder: "+
            //                            "access denied", 731);
            // }
            this.shouldWriteStopwatchFile = true;
    }
        break;
    case "!replayspeed":
        switch(param.toLowerCase()) {
            case "slow":
                this.delay = 2000; break;
            case "medium":
                this.delay = 1000; break;
            case "fast":
                this.delay = 0; break;
            default:
                throw new BadParameter("!REPLAYSPEED can be SLOW|MEDIUM|FAST");
            }
        break;
    case "!playbackdelay":
        let newDelay = parseFloat(param)
        if (isNaN(newDelay) || newDelay <= 0)
            throw new BadParameter("!PLAYBACKDELAY should be a"+
                                   " positive number of seconds");
        this.delay = Math.round(newDelay*1000);
        break;
    case "!file_profiler":
        if (param.toLowerCase() == "no") {
            this.writeProfiler = false;
            this.profiler.file = null;
        } else {
            if (!this.afioIsInstalled) {
                throw new RuntimeError(
                    "!FILE_PROFILER requires File IO interface", 660
                );
            }
            this.writeProfilerData = true;
            this.profiler.enabled = true;
            this.profiler.file = param;
        }
        break;

    case "!linenumber_delta":
        var x = imns.s2i(param);
        if (isNaN(x) || x > 0)
            throw new BadParameter("!LINENUMBER_DELTA must be negative integer or zero");
        this.linenumber_delta = x;
        break;
    case "!useragent":
        if (!this.userAgent) { // we don't want to register more than one handler
            chrome.webRequest.onBeforeSendHeaders.addListener(
                this._onBeforeSendHeaders,
                {windowId: this.win_id, urls: ["<all_urls>"]},
                ["blocking", "requestHeaders"]
            );
        }
        this.userAgent = param;
        break;
    default:
        if (this.limits.varsRe.test(cmd[1])) {
            this.vars[imns.s2i(RegExp.$1)] = param;
        } else if (/^!\S+$/.test(cmd[1])) {
            throw new BadParameter("Unsupported variable "+cmd[1]);
        } else {
            this.setUserVar(cmd[1], param);
        }
    }
    this.next("SET");
};


// SIZE command http://wiki.imacros.net/SIZE
MacroPlayer.prototype.RegExpTable["size"] =
    "^x\\s*=\\s*("+im_strre+")\\s+y=("+im_strre+")\\s*$";

MacroPlayer.prototype.ActionTable["size"] = function (cmd) {
    if (this.noContentPage("SIZE"))
        return;
    var x = imns.s2i(imns.unwrap(this.expandVariables(cmd[1], "size1")));
    var y = imns.s2i(imns.unwrap(this.expandVariables(cmd[2], "size2")));
    if (isNaN(x))
        throw new BadParameter("positive integer", 1)
    if (isNaN(y))
        throw new BadParameter("positive integer", 2)

    var mplayer = this;
    chrome.windows.get(this.win_id, {populate: false}, function(w) {
        communicator.postMessage(
            "query-page-dimensions",
            {}, mplayer.tab_id,
            function(dmns) {
                var delta_x = w.width - dmns.win_w;
                var delta_y = w.height - dmns.win_h;
                chrome.windows.update(
                    mplayer.win_id,
                    {width: x+delta_x, height: y+delta_y},
                    function() {
                        mplayer.next("SIZE");
                    }
                );
            },
            {number: 0}
        );
    });
};

// STOPWATCH command http://wiki.imacros.net/STOPWATCH
MacroPlayer.prototype.RegExpTable["stopwatch"] =
    "^((?:(start|stop)\\s+)?id|label)\\s*=\\s*("+im_strre+")\\s*$";

// add new time watch
MacroPlayer.prototype.addTimeWatch = function(name) {
    this.watchTable[name] = this.globalTimer.getElapsedSeconds();
};


MacroPlayer.prototype.stopTimeWatch = function(name) {
    if (typeof this.watchTable[name] == "undefined")
        throw new RuntimeError("Time watch "+name+" does not exist", 762);
    let elapsed = this.globalTimer.getElapsedSeconds() - this.watchTable[name];
    this.lastWatchValue = elapsed;
    let stamp = new Date(this.globalTimer.macro_start_time + this.watchTable[name]*1000); // time when this timewWatch started
    let x = {id: name, type: "id", elapsedTime: elapsed, timestamp: stamp};
    this.stopwatchResults.push(x);
};


MacroPlayer.prototype.addTimeWatchLabel = function(name) {
    let elapsed = this.globalTimer.getElapsedSeconds();
    this.lastWatchValue = elapsed;
    let stamp = new Date(this.globalTimer.macro_start_time);  // time when the macro started
    let x = {id: name, type: "label", elapsedTime: elapsed, timestamp: stamp};
    this.stopwatchResults.push(x);
};


// command handler
MacroPlayer.prototype.ActionTable["stopwatch"] = function (cmd) {
    var action = cmd[2] ? cmd[2].toLowerCase() : null;
    var use_label = /label$/i.test(cmd[1]);
    var param = imns.unwrap(this.expandVariables(cmd[3], "stopwatch3"));

    // make the watch name uppercase to be compatible with IE version
    param = param.toUpperCase();

    if (!use_label) { // Need a pair of STOPWATCH commands to start and stop the clock, respectively.
        var found = typeof this.watchTable[param] != "undefined";
        switch (action) {
        case "start":
            if (found)
                throw new RuntimeError("stopwatch id="+param+
                                       " already started", 761);
            this.addTimeWatch(param);
            break;
        case "stop":
            if (!found)
                throw new RuntimeError("stopwatch id="+param+
                                       " wasn't started", 762);
            this.stopTimeWatch(param);
            break;
        default:                // old syntax
            if (found)
                this.stopTimeWatch(param);
            else
                this.addTimeWatch(param);
            break;
        }
    } else { // only one STOPWATCH command to stop the clock. Start time is at macro start.
        // save time in sec since macro was started
        this.addTimeWatchLabel(param);
    }
    this.next("STOPWATCH");
};


MacroPlayer.prototype.globalTimer = {
    init: function(mplayer) {
        this.mplayer = mplayer;
        if (this.macroTimeout) {
            clearTimeout(this.macroTimeout);
            this.macroTimeout = null;
        }
    },

    start: function() {
        this.start_time = performance.now(); // attention: this property is in milliseconds!  Relative, since document start.      
        this.macro_start_time = Date.now();  // macro start time in milliseconds, absolute (epoch)
    },

    getElapsedSeconds: function() {
        if (!this.start_time)
            return 0;
        var now = performance.now();
        return (now - this.start_time)/1000;
    },

    setMacroTimeout: function(x) {
        var mplayer = this.mplayer;
        this.macroTimeout = setTimeout( function () {
            if (!mplayer.playing)
                return;
            mplayer.handleError(
                new RuntimeError("Macro replaying timeout of "+x+
                                 "s exceeded", 603)
            );
        }, Math.round(x*1000));
    },

    stop: function() {
        if (this.macroTimeout) {
            clearTimeout(this.macroTimeout);
            this.macroTimeout = null;
        }
    }
};



// TAG command http://wiki.imacros.net/TAG

// regexp for matching att1:"val1"&&att2:val2.. sequence
const im_atts_re = "(?:[-\\w]+:"+im_strre+"(?:&&[-\\w]+:"+im_strre+")*|\\*?)";

MacroPlayer.prototype.RegExpTable["tag"] =
    "^(?:pos\\s*=\\s*(\\S+)\\s+"+
    "type\\s*=\\s*(\\S+)"+
    "(?:\\s+form\\s*=\\s*("+im_atts_re+"))?\\s+"+
    "attr\\s*=\\s*("+im_atts_re+")"+
    "|(selector|xpath)\\s*=\\s*("+im_strre+"))"+
           //"|xpath \\s*=\\s*("+im_strre+"))"+
    "(?:\\s+(content|extract)\\s*=\\s*"+
    "([%$#]"+im_strre+"(?::[%$#]"+im_strre+")*|"+
    "event:"+im_strre+"|"+
    im_strre+"))?\\s*$";

MacroPlayer.prototype.ActionTable["tag"] = function (cmd) {
    if (this.noContentPage("TAG"))
        return;

    // form message to send to content-script
    var data = {
        pos: 0,
        relative: false,
        tagName: "",
        form: null,
        atts: null,
        xpath: null,
        selector: null,
        type: "",
        txt: null,
        cdata: null,
        scroll: true,
        download_pdf: this.shouldDownloadPDF,
        highlight: true
    };

    var isPasswordElement = false;
    // parse attr1:val1&&atr2:val2...&&attrN:valN string
    // into array of regexps corresponding to vals
    const parseAtts = str => {
        if (!str || str == "*")
            return null;
        var arr = str.split(new RegExp("&&(?=[-\\w]+:"+im_strre+")"));
        var parsed_atts = new Object(), at, val, m;
        const re = new RegExp("^([-\\w]+):("+im_strre+")$");
        for (var i = 0; i < arr.length; i++) {
            if (!(m = re.exec(arr[i])))
                throw new BadParameter("incorrect ATTR or FORM specifier: "
                                       +arr[i]);
            at = m[1].toLowerCase();

            if (at.length && at in parsed_atts) {
                throw new BadParameter("Duplicate ATTR specified: " + at.toUpperCase());
            }

            if (at.length) {
                val = imns.unwrap(this.expandVariables(m[2], "tag_attr"+i));
                // While replaying:
                // 1. remove all leading/trailing whitespaces
                // 2. remove all linebreaks in the target string
                val = imns.escapeTextContent(val);
                val = imns.escapeREChars(val);
                val = val.replace(/\*/g, '(?:\n|.)*');
                // 3. treat all <SP> as a one or more whitespaces
                val = val.replace(/ /g, "\\s+");
                parsed_atts[at] = "^\\s*"+val+"\\s*$";
            } else {
                parsed_atts[at] = "^$";
            }
        }

        return parsed_atts;
    };

    if (cmd[5]) {
        if (cmd[5].toLowerCase() == 'xpath') {
            data.xpath = imns.unwrap(this.expandVariables(cmd[6], "tag6"));
        }
        else {
            data.selector = imns.unwrap(this.expandVariables(cmd[6], "tag6"));
        }

    } else {
        data.pos = imns.unwrap(this.expandVariables(cmd[1], "tag1"));
        data.tagName = imns.unwrap(this.expandVariables(cmd[2], "tag2")).
               toLowerCase();
        data.form = parseAtts(cmd[3]);
        data.atts = parseAtts(cmd[4]);
        data.atts_str = cmd[4]; // for error message

        // get POS parameter
        if (/^r(-?\d+)$/i.test(data.pos)) {
            data.pos = imns.s2i(RegExp.$1);
            data.relative = true;
        } else if (/^(\d+)$/.test(data.pos)) {
            data.pos = imns.s2i(RegExp.$1);
            data.relative = false;
        } else {
            throw new BadParameter("POS=<number> or POS=R<number>"+
                                   "where <number> is a non-zero integer", 1);
        }
        // get rid of INPUT:* tag names
        if (/^(\S+):(\S+)$/i.test(data.tagName)) {
            if (!data.atts)
                data.atts = new Object();
            var val = RegExp.$2;
            data.tagName = RegExp.$1.toLowerCase();
            val = imns.escapeREChars(val);
            val = val.replace(/\*/g, '(?:\n|.)*');
            data.atts["type"] = "^"+val+"$";
        }

    }
    if (cmd[7]) {
        data.type = cmd[7].toLowerCase();
        data.rawdata = cmd[8];
        data.txt = imns.unwrap(this.expandVariables(cmd[8], "tag8"));
        if (data.type == "content")
            data.cdata = this.parseContentStr(cmd[8]);
    }

    let p = Promise.resolve(data)
    if (this.shouldDecryptPassword) {
        delete this.shouldDecryptPassword
        p = this.decrypt(data.txt).then(
            plaintext => Object.assign(
                {}, data, {txt: plaintext, passwordDecrypted: true}
            )
        )
    }

    p.then(data => communicator.postMessage(
        "tag-command", data, this.tab_id,
        this.onTagComplete.bind(this),
        this.currentFrame
    )).catch(e => this.handleError(e));
};


MacroPlayer.prototype.parseContentStr = function(cs) {
    var rv = new Object();
    if (/^event:(\S+)$/i.test(cs)) {
        rv.type = "event";
        var etype = RegExp.$1.toLowerCase();
        switch(etype) {
        case "saveitem": case "savepictureas":
        case "savetargetas": case "savetarget":
        case "mouseover": case "fail_if_found":
            rv.etype = etype;
            break;
        default:
            throw new RuntimeError("Unknown event type "+etype+
                                   " for tag command.", 711);
        }
    } else {
        rv.type = "select";
        // regexp for testing if content is $goo:$foo
        const val_re = new RegExp(
            "^(?:([%$#])"+im_strre+")(?::\\1"+im_strre+")*$"
        );
        const idx_re = new RegExp("^\\d+(?::\\d+)*$");

        var m, split_re = null;
        // build regexp for splitting content into values
        if(m = cs.match(val_re)) {
            var non_delimeter =
                "(?:\"(?:[^\"\\\\]|\\\\[0btnvfr\"\'\\\\])*\"|"+
                "eval\\s*\\(\"(?:[^\"\\\\]|\\\\[\\w\"\'\\\\])*\"\\)|"+
                "(?:[^:\\s]|:[^"+m[1]+"])+)";
            split_re = new RegExp("(\\"+m[1]+non_delimeter+")", "g");
        } else if (m = cs.match(idx_re)) {
            split_re = new RegExp("(\\d+)", "g");
        } else if (cs.toLowerCase() =="all") {
            rv.seltype = "all";
            return rv;
        } else {
            // could be some data for input elements
            rv.type = "unknown";
            return rv;
        }

        // split content into values
        var g, opts = new Array();
        while(g = split_re.exec(cs)) {
            opts.push(g[1]);
        }
        rv.seltype = opts.length > 1 ? "multiple" : "single";

        for (var i = 0; i < opts.length; i++) {
            if (/^([%$#])(.*)$/i.test(opts[i])) {
                var typ = RegExp.$1;
                var val = RegExp.$2;
                val = imns.unwrap(this.expandVariables(val, "opts"+i));
                if (typ == "$" || typ == "%") {
                    var re_str = "^\\s*"+imns.escapeREChars(val).
                        replace(/\*/g, '(?:[\r\n]|.)*')+"\\s*$";
                    opts[i] = {typ: typ, re_str: re_str, str: val};
                } else if (typ == "#") {
                    var idx = parseInt(val);
                    if (isNaN(idx))
                        throw new RuntimeError(
                            "Wrong CONTENT specifier "+cs, 711);
                    opts[i] = {typ: "#", idx: idx};
                }
            } else if (/^(\d+)$/i.test(opts[i])) { // indexes 1:2:...
                var idx = parseInt(RegExp.$1);
                if (isNaN(idx))
                    throw new RuntimeError("Wrong CONTENT specifier "+cs,
                                           711);
                opts[i] = {typ: "#", idx: idx};
            }
        }

        rv.opts = opts;
    }

    return rv;
};


MacroPlayer.prototype.handleInputFileTag = function(selector, files) {
    return this.attachDebugger("1.2")
        .then(() => send_command(this.tab_id, "DOM.getDocument"))
        .then(({root: {nodeId}}) => send_command(
            this.tab_id,
            "DOM.querySelector",
            {nodeId, selector}
        ))
        .then(({nodeId}) => send_command(
            this.tab_id,
            "DOM.setFileInputFiles",
            {files, nodeId}
        ))
        .then(() => this.detachDebugger())
        .catch(e => this.handleError(e))
}

// VERSION command http://wiki.imacros.net/VERSION
MacroPlayer.prototype.RegExpTable["version"] = "^(?:build\\s*=\\s*(\\S+))?"+
    "(?:\\s+recorder\\s*=\\s*(\\S+))?\\s*$";
MacroPlayer.prototype.ActionTable["version"] = function (cmd) {
    // do nothing
    this.next("VERSION");
};



// URL command http://wiki.imacros.net/URL
MacroPlayer.prototype.RegExpTable["url"] =
    "^goto\\s*=\\s*("+im_strre+")\\s*$";

MacroPlayer.prototype.ActionTable["url"] = function (cmd) {
    var param = imns.unwrap(this.expandVariables(cmd[1], "url1")),
        scheme = null;

    if (!/^([a-z]+):.*/i.test(param)) {
        param = "http://"+param;
    }
    // Test for javascript: URLs and execute it
    var jsRegex = RegExp("^javascript:\\(?(.+)\\)?$");
    if (jsRegex.test(param)) {
        let matches = jsRegex.exec(param);
        let scriptCode = matches[1];
        chrome.tabs.executeScript(this.tab_id, { code: scriptCode }, () => { this.next("URL"); });
    } else {
        chrome.tabs.update(
            this.tab_id, {url: param},
            () => {
                if (/^javascript:/.test(param)) {
                    // somewhat ugly hack for javascript: urls
                    this.next("URL");
                } else {
                    this.waitingForPageLoad = true;

                    if (!this.timers.has("loading"))
                        this.startTimer(
                            "loading", this.timeout, "Loading ", () => {
                                this.waitingForPageLoad = false;
                                this.handleError(new RuntimeError(
                                    "Page loading timeout"+
                                        ", URL: "+this.currentURL, 602
                                ));
                            }
                        )
                }
            }
        );
    }
};




// TAB command http://wiki.imacros.net/TAB
MacroPlayer.prototype.RegExpTable["tab"] = "^(t\\s*=\\s*(\\S+)|"+
    "close|closeallothers|open|open\\s+new|new\\s+open"+
    ")\\s*$";

MacroPlayer.prototype.ActionTable["tab"] = function (cmd) {
    communicator.postMessage("tab-command", {}, this.tab_id, () => {})
    if (/^close$/i.test(cmd[1])) { // close current tab
        this.detachDebugger().then(() => chrome.tabs.remove(
            this.tab_id, () => this.next("TAB CLOSE")
        ))
    } else if (/^closeallothers$/i.test(cmd[1])) {
        //close all tabs except current
        chrome.tabs.query(
            {windowId: this.win_id, active: false},
            tabs => {
                let ids = tabs.filter(tab => !tab.active).map(tab => tab.id)
                this.startTabIndex = 0
                chrome.tabs.remove(
                    ids, () => this.next("TAB CLOSEALLOTHERS")
                )
            })
    } else if (/open/i.test(cmd[1])) {
        this.detachDebugger().then(() => {
            chrome.tabs.get(this.tab_id, tab => {
                let args = {
                    url: "about:blank",
                    windowId: this.win_id,
                    index: tab.index+1,
                    active: false
                }
                chrome.tabs.create(args, t => this.next("TAB OPEN"))
            })
        })
    } else if (/^t\s*=/i.test(cmd[1])) {
        let n = imns.s2i(this.expandVariables(cmd[2], "tab2"))
        if (isNaN(n))
            throw new BadParameter("T=<number>", 1)
        let tab_num = n+this.startTabIndex-1
        chrome.tabs.query({windowId: this.win_id}, tabs => {
            if (tab_num < 0 || tab_num > tabs.length-1) {
                this.handleError(
                    new RuntimeError("Tab number "+n+" does not exist", 771)
                )
            } else {
                this.detachDebugger().then(() => chrome.tabs.update(
                    tabs[tab_num].id, {active: true},
                    t => this.next("TAB T=")
                ))
            }
        })
    }
};



// WAIT command http://wiki.imacros.net/WAIT
MacroPlayer.prototype.RegExpTable["wait"] = "^seconds\\s*=\\s*(\\S+)\\s*$";

MacroPlayer.prototype.ActionTable["wait"] = function (cmd) {
    var param = Number(imns.unwrap(this.expandVariables(cmd[1], "wait1")));

    if (isNaN(param))
        throw new BadParameter("SECONDS=<number>", 1);
    param = Math.round(param*10)*100; // get number of ms
    if (param == 0)
        param = 10;
    else if (param < 0)
        throw new BadParameter("positive number of seconds", 1);
    this.inWaitCommand = true;
    var mplayer = this;

    this.waitTimeout = setTimeout(function () {
        mplayer.inWaitCommand = false;
        delete mplayer.waitTimeout;
        clearInterval(mplayer.waitInterval);
        delete mplayer.waitInterval;
        mplayer.next("WAIT");
    }, param);

    // show timer
    var start_time = performance.now();
    var total = param/1000;
    mplayer.waitInterval = setInterval(function () {
        if (!mplayer.inWaitCommand) {
            clearInterval(mplayer.waitInterval);
            return;
        }
        let passed = (performance.now() - start_time)/1000
        var remains = total - passed
        if (remains > 0) {
            var text = passed.toFixed(0);
            while(text.length < 3)
                text = "0"+text;
            badge.set(mplayer.win_id, {
                status: "waiting",
                text: text
            });

            var panel = context[mplayer.win_id].panelWindow;
            if (panel && !panel.closed) {
                panel.setStatLine("Waiting "+passed.toFixed(1)+
                                  "("+total.toFixed(1)+")s", "info");
            }
        } else {
            clearInterval(mplayer.waitInterval);
            delete mplayer.waitInterval;
        }
    }, 1000);
};





MacroPlayer.prototype.beforeEachRun = function() {
    // stopwatch-related properties
    this.watchTable = new Object();
    this.stopwatchResults = new Array();
    this.shouldWriteStopwatchFile = true; // default is true
    // last stopwatch value for !STOPWATCHTIME
    this.lastWatchValue = 0;
    this.totalRuntime = 0;
    this.lastPerformance = new Array();
    this.stopwatchFile = null;  // FILESTOPWATCH
    this.stopwatchFolder = null; // FOLDER_STOPWATCH
    // init runtime and waiting timers
    this.timers = new Map();
    this.globalTimer.init(this);
    this.proxySettings = null;
    this.currentFrame = {number: 0};
    // clear waiting flags
    this.waitingForPageLoad = false;
    this.inWaitCommand = false;
    this.waitingForDelay = false;
    // Profiler Log feature
    this.writeProfilerData = Storage.getBool("profiler-enabled") && Storage.getBool("afio-installed");
    this.profiler.file = null;
    // reset profiler
    this.profiler.init();
    this.profiler.enabled = (this.profiler.si_enabled ||
        Storage.getBool("profiler-enabled")) && Storage.getBool("afio-installed");
    // eval expressions storage
    this.__eval_results = {};
    // script errors
    this.shouldStopOnError = false;
    // delta for line numbers in error reports and profiler data
    this.linenumber_delta = 0;
    // reset current line
    this.currentLine = 0;
    // rest navigation pool
    this.activeNavigations = new Set();
    // !DOWNLOADED_FILE_NAME and !DOWNLOADED_SIZE
    this.downloadedFilename = "";
    this.downloadedSize = 0;
    this.userAgent = null;
    // coordinates of the center of an image found by IMAGESEARCH command
    this.imageX = this.imageY = -1;
    // clear extract data
    this.clearExtractData();
};


MacroPlayer.prototype.afterEachRun = function() {
    // form lastPerformance and save STOPWATCH results
    this.saveStopwatchResults();

    // restore proxy settings
    if (this.proxySettings) {
        this.restoreProxySettings();
        this.proxySettings = null;
    }
};


// reset all defaults, should be called on every play
MacroPlayer.prototype.reset = function() {
    // this.vars = new Array();
    // this.userVars = new Map();

    // clear actions array
    this.actions = new Array();
    this.currentAction = null;

    // reset state variables
    this.ignoreErrors = false;
    this.playing = false;
    this.paused = false;
    this.pauseIsPending = false;

    // last error code and message
    this.errorCode = 1;
    this.errorMessage = "OK";
    this.firstLoop = true;

    // datasources
    this.dataSource = new Array();
    this.dataSourceColumns = 0;
    this.dataSourceLine = 0;
    this.dataSourceFile = "";
    this.dataSourceDelimiter = ",";

    // extraction
    this.extractData = "";
    // show extract popup by default only when not looping and not
    // playing from scripting interface
    this.shouldPopupExtract = !(this.cycledReplay || this.client_id);
    this.waitingForExtract = false;
    // replaying delay
    this.delay = Storage.getNumber("replaying-delay"); // milliseconds

    // default timeout tag wait time
    // TODO: maybe store it in localStorage
    this.timeout = 60;  // seconds
    this.timeout_tag = Math.round(this.timeout/10);
    this.timeout_download = this.timeout*5;

    // encryption type
    var typ = Storage.getChar("encryption-type");
    if (!typ.length)
        typ = "no";
    this.encryptionType = typ;

    this.waitingForPassword = false;

    // downloads state
    this.activeDownloads = new Map();
    this.waitForDownloadCompleted = false;
    this.waitForDownloadCreated = false;
    // HTTP authorization expected
    this.waitForAuthDialog = false;

    return new Promise((resolve, reject) => {
        chrome.tabs.query({active: true, windowId: this.win_id}, tabs => {
            this.startTabIndex = tabs[0].index;
            this.currentURL = tabs[0].url;
            this.tab_id = tabs[0].id;
            // test for afio
            afio.isInstalled().then(installed => {
                if ((this.afioIsInstalled = installed)) {
                    let nodes = ["datapath", "savepath", "downpath"].
                        map(what => afio.getDefaultDir(what))
                    Promise.all(nodes).then(([datanode, savenode, downnode]) => {
                        this.dataSourceFolder = datanode
                        this.macrosFolder = savenode
                        this.defDownloadFolder = downnode
                    })
                }
            }).then(resolve).catch(reject) // the only reason for that clumsy
                                           // statement is that
                                           // chrome.tabs.query expects a
                                           // callback
        })});
};


MacroPlayer.prototype.pause = function() {
    if (!this.pauseIsPending) {
        this.pauseIsPending = true
        context.updateState(this.win_id, "paused")
    }
};

MacroPlayer.prototype.unpause = function () {
    if (!this.pauseIsPending) {
        this.paused = false
        context.updateState(this.win_id, "playing")
        this.next("unpause")
    }
};



// Start macro replaying
// @macro is a macro name
// @loopnum - positive integer
// which should be used to specify cycled replaying
MacroPlayer.prototype.play = function(macro, limits, callback) {
    // console.info("Playing macro %O, limits %O", macro, limits);
    const comment = new RegExp("^\\s*(?:'.*)?$");
    this.source = macro.source;
    this.currentMacro = macro.name;

    // save macro id for "Edit" on error dialog
    this.file_id = macro.file_id;
    this.client_id = macro.client_id;
    this.bookmark_id = macro.bookmark_id;
    // save reference to callback
    this.callback = callback;
    this.limits = this.convertLimits(limits)
    // count lines
    var line_re = /\r?\n/g, count = 0;
    while (line_re.exec(this.source))
        count++;
    // TODO: check macro length

    // check number of loops
    this.times = macro.times || 1;
    this.currentLoop = macro.startLoop || 1;
    this.cycledReplay = this.times - this.currentLoop > 0;
    // debugger should be attached at least once for every page if there is an
    // event command
    this.debuggerAttached = false;

    this.reset().then(() => {
        this.checkFreewareLimits("loops", this.times)
        this.checkFreewareLimits("loops", this.currentLoop)
        this.beforeEachRun();
        this.addListeners();
        // we should set before parsing so parse errors can be reported
        this.playing = true;
        this.parseMacro();
    }).then(() => {
        // prepare stack of actions
        this.action_stack = this.actions.slice();
        this.action_stack.reverse();
        context.updateState(this.win_id,"playing");
        var panel = context[this.win_id].panelWindow;
        if (panel && !panel.closed) {
            panel.showLines(this.source);
            panel.setStatLine("Replaying "+self.currentMacro, "info");
        }
        // start replaying
        this.globalTimer.start();
        this.playNextAction("start");
    }).catch(e => this.handleError(e));

};



// parse macro
MacroPlayer.prototype.parseMacro = function() {
    const comment = new RegExp("^\\s*(?:'.*)?$");
    const linenumber_delta_re =
            new RegExp("^\\s*'\\s*!linenumber_delta\\s*:\\s*(-?\\d+)", "i");
    this.linenumber_delta = 0;  // workaround for #381
    // check macro syntax and form list of actions
    this.source = this.source.replace(/\r+/g, ""); // remove \r symbols if any
    var lines = this.source.split("\n");
    for (var i = 0; i < lines.length; i++) {
        // check for !linenubmer_delta
        var m = lines[i].match(linenumber_delta_re);
        if (m) {
            this.linenumber_delta = imns.s2i(m[1]);
            continue;
        }
        if (lines[i].match(comment)) { // skip comments and empty lines
            continue;
        }

        if (/^\s*(\w+)(?:\s+(.*))?$/.test(lines[i])) {
            var command = RegExp.$1.toLowerCase();
            var arguments = RegExp.$2 ? RegExp.$2 : "";
            // check if command is known
            if (!(command in this.RegExpTable))
                throw new SyntaxError("unknown command: "+
                                      command.toUpperCase()+
                                      " at line "+(i+1+this.linenumber_delta));
            // parse arguments
            var args = this.RegExpTable[command].exec(arguments);
            if ( !args )
                throw new SyntaxError("wrong format of "+
                                      command.toUpperCase()+" command"+
                                      " at line "+(i+1+this.linenumber_delta));
            // put parsed action into action list
            this.actions.push({name: command,
                               args: args, line: i+1});
            this.checkFreewareLimits("lines", this.actions.length)

        } else {
            throw new SyntaxError("can not parse macro line "+
                                  (i+1+this.linenumber_delta)
                                  +": "+lines[i]);
        }
    }
};



// exec current action
MacroPlayer.prototype.exec = function(action) {
    if (!this.retryInterval) {
        badge.set(this.win_id, {
            status: "playing",
            text: action.line.toString()
        });

        // highlight action
        var panel = context[this.win_id].panelWindow;
        if (panel && !panel.closed)
            panel.highlightLine(action.line);
    }

    this._ActionTable[action.name](action.args);
};

// delayed start of next action
MacroPlayer.prototype.next = function(caller_id) {
    var mplayer = this;
    if (this.delay) {
        this.waitingForDelay = true;
        if (!this.delayTimeout) {
            this.delayTimeout = setTimeout(function () {
                delete mplayer.delayTimeout;
                mplayer.waitingForDelay = false;
                mplayer.playNextAction(caller_id);
            }, this.delay);
        }
    } else {
        asyncRun(function() {mplayer.playNextAction(caller_id);});
    }
    // stop profile timer
    this.profiler.end("OK", 1, this);
};


MacroPlayer.prototype.playNextAction = function(caller_id) {
    if (!this.playing)
        return;

    var panel = context[this.win_id].panelWindow;
    if (panel && !panel.closed && !this.retryInterval) {
        panel.setStatLine("Replaying "+this.currentMacro, "info");
    }

    // call "each run" initialization routine
    if (caller_id == "new loop")
        this.beforeEachRun();

    if ( this.pauseIsPending ) { // check if player should be paused
        this.pauseIsPending = false;
        this.paused = true;
        return;
    } else if ( this.paused ||
                this.waitingForDelay ||    // replaying delay
                this.waitingForPageLoad || // a page is loading
                this.inWaitCommand ||     // we are in WAIT
                this.waitingForPassword || // asking for a password
                this.waitingForExtract     // extract dialog
              ) {
        if (Storage.getBool("debug"))
            console.debug("("+this.globalTimer.getElapsedSeconds().toFixed(3)+") "+
                          "playNextAction(caller='"+(caller_id || "")+"')"+
                          ", waiting for: "+
                          (this.waitingForDelay ? "delay, " : "")+
                          (this.waitingForPageLoad ? "page load, " : "")+
                          (this.waitingForPassword ? "password, " : "")+
                          (this.waitingForExtract ? "extract, " : "")+
                          (this.inWaitCommand ? "in wait, ": ""));
        // waiting for something
        return;
    }  else {
        // fetch next action
        if ( this.action_stack.length ) {
            this.currentAction = this.action_stack.pop();
            try {
                if (Storage.getBool("debug"))
                    console.debug(
                        "("+this.globalTimer.getElapsedSeconds().toFixed(3)+") "+
                            "playNextAction(caller='"+(caller_id || "")+
                            "')\n playing "+
                            this.currentAction.name.toUpperCase()+
                            " command"+
                            ", line: "+this.currentAction.line
                    );
                this.profiler.start(this.currentAction);
                this.exec(this.currentAction);
                // profiler.end() is called from next() method
            } catch (e) {
                if (e.name && e.name == "InterruptSignal") {
                    this.onInterrupt(e.id);
                } else {
                    this.handleError(e);
                }
            }
        } else {
            this.afterEachRun();
            if (this.currentLoop < this.times) {
                this.firstLoop = false;
                this.currentLoop++;
                var panel = context[this.win_id].panelWindow;
                if (panel && !panel.closed)
                    panel.setLoopValue(this.currentLoop);
                this.action_stack = this.actions.slice();
                this.action_stack.reverse();
                this.next("new loop");
            } else {
                // no more actions left
                this.stop();
            }
        }
    }
};



// handle error
MacroPlayer.prototype.handleError = function (e) {
    this.errorCode = e.errnum ? -1*Math.abs(e.errnum) : -1001;
    this.errorMessage = (e.name ? e.name : "Error")+": "+e.message;
    if (this.currentAction) {
        this.errorMessage += ", line: "+
            (this.currentAction.line+this.linenumber_delta).toString();
    }
    // save profiler data for the broken action
    this.profiler.end(this.errorMessage, this.errorCode, this);
    console.error(this.errorMessage);
    var args = {
        message: this.errorMessage,
        errorCode: this.errorCode,
        win_id: this.win_id,
        macro: {
            source: this.source,
            name: this.currentMacro,
            file_id: this.file_id,
            bookmark_id: this.bookmark_id
        }
    };
    showInfo(args);
    if (this.playing && !this.ignoreErrors) {
        this.stop();
    } else if(this.ignoreErrors) {
        this.next("error handler");
    }
};



// form lastPerformance and save STOPWATCH results
MacroPlayer.prototype.saveStopwatchResults = function() {
    // ensure that macro timeout is cleared
    this.globalTimer.stop();

    // save total run time
    this.totalRuntime = this.globalTimer.getElapsedSeconds();

    // make all values look like 00000.000
    var format = function(x) {
        var m = x.toFixed(3).match(/^(\d+)\.(\d{3})/);
        var s = m[1];
        while (s.length < 5)
            s = "0"+s;

        return s+"."+m[2];
    };

    this.lastPerformance.push(
        {
            name: "TotalRuntime",
            value: this.totalRuntime.toFixed(3).toString()
        }
    );

    if (!this.stopwatchResults.length)
        return;

    // "Date: 2009/11/12  Time: 15:32, Macro: test1.iim, Status: OK (1)"
    let now = new Date();
    let d = imns.formatDate("yyyy/dd/mm", now);
    let t = imns.formatDate("hh:nn", now);

    let newline = __is_windows() ? "\r\n" : "\n";
    let s = "\"Date: "+d+"  Time: "+t+
        ", Macro: "+this.currentMacro+
        ", Status: "+this.errorMessage+" ("+this.errorCode+")\",";
    s += newline;
    for (let r of this.stopwatchResults) {
        let timestamp = imns.formatDate("dd/mm/yyyy,hh:nn:ss", r.timestamp);
        s += timestamp+","+r.id+","+r.elapsedTime.toFixed(3).toString();
        s += newline;
        this.lastPerformance.push(
            {
                name: r.id,
                value: r.elapsedTime.toFixed(3)
            }
        );
    }

    if (!this.shouldWriteStopwatchFile)
        return;

    if (!this.afioIsInstalled) {
        console.error("Saving Stopwatch file requires File IO interface");
        return;
    }

    let file = this.stopwatchFile;
    if (!this.stopwatchFile) {
        if (this.stopwatchFolder)
            file = this.stopwatchFolder;
        else
            file = this.defDownloadFolder.clone()
        let filename = /^(.+)\.iim$/i.test(this.currentMacro) ?
            RegExp.$1 : this.currentMacro;
        file.append("performance_"+filename+".csv");
    }

    afio.appendTextFile(file, s).catch(console.error.bind(console));
};


MacroPlayer.prototype.profiler = {
    // make string representation of Date object
    make_str: function(x) {
        var prepend = function(str, num) {
            str = str.toString();
            var x = imns.s2i(str), y = imns.s2i(num);
            if (isNaN(x) || isNaN(y))
                return;
            while (str.length < num)
                str = '0'+str;
            return str;
        };
        var str = prepend(x.getHours(), 2)+":"+
            prepend(x.getMinutes(), 2)+":"+
            prepend(x.getSeconds(), 2)+"."+
            prepend(x.getMilliseconds(), 3);
        return str;
    },

    init: function() {
        this.profiler_data = new Array();
        this.macroStartTime = new Date();
        this.enabled = false;
    },


    start: function(action) {
        if (!this.enabled)
            return;
        this.currentAction = action;
        this.startTime = new Date();
    },


    end: function(err_text, err_code, mplayer) {
        if (!this.enabled || !this.startTime)
            return;
        var now = new Date();
        var elapsedTime = (now.getTime()-this.startTime.getTime())/1000;

        // form new profiler data object
        var data = {
            Line: this.currentAction.line+mplayer.linenumber_delta,
            StartTime: this.make_str(this.startTime),
            EndTime: this.make_str(now),
            ElapsedSeconds: elapsedTime.toFixed(3),
            StatusCode: err_code,
            StatusText: err_text,
            type: mplayer.ignoreErrors ? "errorignoreyes" : "errorignoreno"
        };

        // add timeout_threshold value if applicable
        if (this.currentAction.name == "tag") {
            var threshold = (mplayer.timeout_tag > 0) ?
                mplayer.timeout_tag : mplayer.timeout/10;
            // get threshold in percents of timeout_tag
            data.timeout_threshold =
                ((elapsedTime/threshold)*100).toFixed();
        } else if (this.currentAction.name == "url") {
            // get threshold in percents of timeout_page
            data.timeout_threshold =
                ((elapsedTime/mplayer.timeout)*100).toFixed();
        }
        // console.log("new profiler data, %O", data);
        this.profiler_data.push(data);

        // clear start data
        delete this.currentAction;
        delete this.startTime;
    },

    getResultingXMLFragment: function(mplayer) {
        if (!this.enabled)
            return "";
        var macroEndTime = new Date();
        var source = imns.trim(mplayer.source).split("\n");
        var doc = document.implementation.createDocument("", "Profile", null);
        var macro = doc.createElement("Macro");
        var name = doc.createElement("Name");
        name.textContent = mplayer.currentMacro;
        macro.appendChild(name);

        var lastStartTime = null; // this is for start/end time of comments

        // this is a counter for profiler_data[]
        var j = mplayer.linenumber_delta == 0 ? 0 : -mplayer.linenumber_delta;
        for (var i = 0; i < source.length; i++) {
            if (j < this.profiler_data.length &&
                this.profiler_data[j].Line == i+1+mplayer.linenumber_delta) {
                var command = doc.createElement("Command");
                var string = doc.createElement("String");
                // first set String node
                string.textContent = imns.trim(source[i]);
                command.appendChild(string);
                var x = this.profiler_data[j];
                for (var y in x) {
                    if (y != "type" && y != "timeout_threshold") {
                        var z = doc.createElement(y);
                        z.textContent = x[y];
                        command.appendChild(z);
                    }
                }
                // set 'type' attribute
                var type = doc.createAttribute("type");
                type.nodeValue = x.type;
                command.setAttributeNode(type);
                // set 'timeout_threshold' attribute
                if (x.timeout_threshold) {
                    var tt = doc.createAttribute("timeout_threshold");
                    tt.nodeValue = x.timeout_threshold;
                    command.setAttributeNode(tt);
                }
                lastStartTime = x.StartTime;
                j++;
                // now append the resulting node to "Macro"
                macro.appendChild(command);
            }
        }

        // add total nodes
        var start = doc.createElement("Start"); // macro start time
        start.textContent = this.make_str(this.macroStartTime);
        var end = doc.createElement("End"); // macro end time
        end.textContent = this.make_str(macroEndTime);
        var elapsed = doc.createElement("ElapsedSeconds"); // macro duration
        var duration = (macroEndTime.getTime()-
                        this.macroStartTime.getTime())/1000;
        elapsed.textContent = duration.toFixed(3);
        var status = doc.createElement("Status"); // error code and text
        var code = doc.createElement("Code");
        code.textContent = mplayer.errorCode;
        var text = doc.createElement("Text");
        text.textContent = mplayer.errorMessage;

        status.appendChild(code);
        status.appendChild(text);
        macro.appendChild(start);
        macro.appendChild(end);
        macro.appendChild(elapsed);
        macro.appendChild(status);

        doc.documentElement.appendChild(macro);
        var s = new XMLSerializer();
        var result = s.serializeToString(doc);

        return result.replace(/^[.\n\r]*<Profile>\s*/, "").
            replace(/\s*<\/Profile>/, "");
    }
};


MacroPlayer.prototype.saveProfilerData = function() {
    if(!this.defDownloadFolder)
        return;
    var xml_frag = this.profiler.getResultingXMLFragment(this);
    var file = null;
    if (this.profiler.file) { // file was set with !FILE_PROFILER
        if (__is_full_path(this.profiler.file)) {
            file = afio.openNode(this.profiler.file);
        } else {
            file = this.defDownloadFolder.clone()
            var leafname = /\.xml$/i.test(this.profiler.file)?
                this.profiler.file : this.profiler.file+".xml";
            file.append(leafname);
        }
    } else {
        file = this.defDownloadFolder.clone()
        file.append("Chrome_Profiler_"+imns.formatDate("yyyy-mm-dd")+".xml");
    }

    file.exists().then(function(exists) {
        if (exists) {
            return afio.readTextFile(file).then(function(x) {
                x = x.replace(/\s*<\/Profile>\s*$/, "\n"+xml_frag+"</Profile>");
                return afio.writeTextFile(file, x);
            });
        } else {
            var x = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"+
                "<?xml-stylesheet type='text/xsl' href='Profiler.xsl'?>\n"+
                "<Profile>\n"+
                "<!--Profiled with iMacros for Chrome "+
                Storage.getChar("version")+" on "+(new Date())+"-->";
            x += xml_frag;
            x += "</Profile>";
            return afio.writeTextFile(file, x);
        }
    }).catch(console.error.bind(console));
};


MacroPlayer.prototype.stop = function() {    // Stop playing
    this.detachDebugger()
    this.playing = false
    this.pauseIsPending = false
    this.paused = false
    this.removeListeners();
    if (this.errorCode != 1) // save stopwatch result in case of error
        this.saveStopwatchResults();

    // clear wait and delay timeout if any
    if (this.delayTimeout) {
        clearTimeout(this.delayTimeout);
        delete this.delayTimeout;
    }
    if (this.waitTimeout) {
        clearTimeout(this.waitTimeout);
        delete this.waitTimeout;
    }
    if (this.waitInterval) {
        clearInterval(this.waitInterval);
        delete this.waitInterval;
    }
    for (var type of this.timers.keys())
        this.stopTimer(type);
    this.timers.clear();

    // stop profile timer
    // NOTE: handleError() saves data from broken action
    this.profiler.end("OK", 1, this);
    // write profiler data if any
    if (this.writeProfilerData) {
        this.saveProfilerData();
    }

    // tell content script do some clean-up
    communicator.postMessage("stop-replaying", {}, this.tab_id,
                             function() {});

    // clear user-set variables
    this.vars = new Array();
    this.userVars.clear();    
    context.updateState(this.win_id,"idle");

    // restore proxy settings
    if (this.proxySettings) {
        this.restoreProxySettings();
        this.proxySettings = null;
    }

    // remove badge text
    badge.clearText(this.win_id);

    // reset panel
    var panel = context[this.win_id].panelWindow;
    if (panel && !panel.closed)
        panel.setLoopValue(1);

    // show macro tree
    if (panel && !panel.closed)
        panel.showMacroTree();

    if (this.client_id) {
        var extra = {
            extractData: this.getExtractData(),
            lastPerformance: this.lastPerformance
        };
        if (this.profiler.si_enabled) {
            delete this.profiler.si_enabled;
            extra.profilerData =
                this.profiler.getResultingXMLFragment(this);
        }
        nm_connector.sendResponse(
            this.client_id,
            this.errorMessage,
            this.errorCode,
            extra
        );
    }

    if (typeof this.callback == "function") {
        var f = this.callback, self = this;
        delete this.callback;
        setTimeout(function() {f(self);}, 0);
    }
};


MacroPlayer.prototype.checkFreewareLimits = function(type, value) {
    let check = (max, msg) => {
        if (value <= max) {
            return value
        } else {
            throw new FreewareLimit(msg + " " + value + " exceeds max value " + max)
        }
    }
    if(!this.limits) 
        return value;
    switch(type) {
    case "lines":
        return check(this.limits.maxMacroLen, "macro length")
    case "loops":
        return check(this.limits.maxIterations, "number of iterations")
    case "csv_rows":
        return check(this.limits.maxCSVRows, "number of CSV rows")
    case "csv_cols":
        return check(this.limits.maxCSVCols, "number of CSV columns")
    case "user_vars":
        if (!this.limits.userVars) {
            throw new FreewareLimit("user defined variables not allowed."+
                                    " Maximum number of variables is " +
                                    this.limits.maxVariables)
        } else {
            return value
        }
    }
}

MacroPlayer.prototype.convertLimits = function(limits) {
    // { "maxVariables" : number|"unlimited",
    //   "maxCSVRows" : number|"unlimited",
    //   "maxCSVCols" : number|"unlimited",
    //   "maxMacroLen" : number|"unlimited",
    //   "maxIterations" : number|"unlimited" }

    let convert = x => x == "unlimited" ? Number.MAX_SAFE_INTEGER : x
    let obj = {}
    for (key in limits) {
        obj[key] = convert(limits[key])
    }
    obj.varsRe = limits.maxVariables == "unlimited" || limits.maxVariables >= 10 ?
        /^!var([0-9]+)$/i : new RegExp("^!var([1-"+limits.maxVariables+"])$", "i");
    obj.userVars = limits.maxVariables == "unlimited" || limits.maxVariables >= 10;

    return Object.freeze(obj)
}

// functions to manipulate extraction results
MacroPlayer.prototype.getExtractData = function () {
    return this.extractData;
};

MacroPlayer.prototype.addExtractData = function(str) {
    if ( this.extractData.length ) {
        this.extractData += "[EXTRACT]"+str;
    } else {
        this.extractData = str;
    }
};

MacroPlayer.prototype.clearExtractData = function() {
    this.extractData = "";
};


// Show Popup for extraction
MacroPlayer.prototype.showAndAddExtractData = function(str) {
    this.addExtractData(str);
    if (!this.shouldPopupExtract)
        return;
    this.waitingForExtract = true;
    var features = "titlebar=no,menubar=no,location=no,"+
        "resizable=yes,scrollbars=yes,status=no,"+
        "width=430,height=380";
    var win = window.open("extractDialog.html",
        null, features);
    win.args = {
        data: str,
        mplayer: this
    };
};



// Datasources
MacroPlayer.prototype.loadDataSource = function(filename) {
    var file;
    if (!__is_full_path(filename)) {
        if (this.dataSourceFolder)
            file = this.dataSourceFolder.clone();
        else
            throw new RuntimeError("Datasource folder is not set", 730)

        file.append(filename);
    } else {
        file = afio.openNode(filename);
    }
    var mplayer = this;
    return file.exists().then(function(exists) {
        if (!exists) {
            throw new RuntimeError("Data source file does not exist", 730)
        }
        mplayer.dataSourceFile = file.path;
        return afio.readTextFile(file).then(function(data) {
            if (!/\r?\n$/.test(data))
                data += "\n";     // add \n to make regexp not so complicated
            mplayer.dataSource = new Array();
            // regexp to match single data field
            // based on http://edoceo.com/utilitas/csv-file-format
            var ws = '[ \t\v]';   // non-crlf whitespace,
            // TODO: should we include all Unicode ws?
            var delim = mplayer.dataSourceDelimiter;
            var field = ws+'*("(?:[^\"]+|"")*"|[^'+delim+'\\n\\r]*)'+ws+
                '*('+delim+'|\\r?\\n|\\r)';
            var re = new RegExp(field, "g"), m, vals = new Array();
            while (m = re.exec(data)) {
                var value = m[1], t;
                if (t = value.match(/^\"((?:[\r\n]|.)*)\"$/))
                    value = t[1];   // unquote the line
                value = value.replace(/\"{2}/g, '"'); // normalize double quotes
                // HACK: every {{!COLn}} variable is "unwrap()-ped" in
                // command handlers so we have to do some trickery to
                // preserve double-quoted strings
                // see fx #362
                if (t = value.match(/^\"((?:[\r\n]|.)*)\"$/))
                    value = '"\\"'+t[1]+'\\""';
                vals.push(value);
                mplayer.checkFreewareLimits("csv_cols", vals.length)
                if (m[2] != delim) {
                    mplayer.dataSource.push(vals.slice(0));
                    let rowCount = mplayer.dataSource.length
                    mplayer.checkFreewareLimits("csv_rows", rowCount)
                    vals = new Array();
                }
            }

            if (!mplayer.dataSource.length) {
                    throw new RuntimeError("Can not parse datasource file "+
                                           filename, 752)
            }
        }).catch(function(err) {
            mplayer.handleError(err);
        });
    });
};


MacroPlayer.prototype.getColumnData = function (col) {
    var line =  this.dataSourceLine || this.currentLoop;

    if (!line)
        line = 1;

    var max_columns = this.dataSourceColumns || this.dataSource[line-1].length;
    if (col > max_columns)
        throw new RuntimeError("Column number "+col+
                               " greater than total number"+
                               " of columns "+max_columns, 753);

    return this.dataSource[line-1][col-1];
};


// functions to access built-in VARiables
MacroPlayer.prototype.getVar = function(idx) {
    var num = typeof idx === "string" ? imns.s2i(idx) : idx;
    return this.vars[num] || "";
};

// functions to access user defined variables
MacroPlayer.prototype.setUserVar = function(name, value) {
    this.checkFreewareLimits("user_vars", null);
    this.userVars.set(name.toLowerCase(), value);
};

MacroPlayer.prototype.getUserVar = function(name) {
    this.checkFreewareLimits("user_vars", null);
    var value = this.userVars.get(name.toLowerCase());
    return value === undefined ? "" : value;
};

MacroPlayer.prototype.hasUserVar = function(name) {
    this.checkFreewareLimits("user_vars", null);
    return this.userVars.has(name.toLowerCase());
};




function InterruptSignal(eval_id) {
    this.id = eval_id;
    this.name = "InterruptSignal";
    this.message = "Script interrupted";
}

MacroPlayer.prototype.do_eval = function (s, eval_id) {
    // check if we already eval-ed the expression
    if (this.__eval_results[eval_id]) {
        var result = this.__eval_results[eval_id].result;
        delete this.__eval_results[eval_id];
        return result.toString();
    } else {
        // there was no expression result so send it to sandbox
        var str = s ? imns.unwrap(s) : "";
        var eval_data = {
            type: "eval_in_sandbox",
            id: eval_id,
            expression: str
        };

        document.getElementById("sandbox").contentWindow.postMessage(eval_data, "*");
        // we should put previos action back to stack
        this.action_stack.push(this.currentAction);
        // interrupt macro execution to wait for sandbox answer
        throw new InterruptSignal(eval_id);
    }
};


MacroPlayer.prototype.onSandboxMessage = function(event) {
    var x = event.data;
    if (!x.type || x.type != "eval_in_sandbox_result")
        return;
    
    var r = x.result;
    // convert undefined or null result to a string value
    if (typeof(x.result) == "undefined") {
        r = "undefined";
    } else if (!r && typeof(r) == "object") {
        r = "null";
    }
    // store the result
    this.__eval_results[x.id] = {
        result: r
    };

    if (x.error) {
        this.handleError(x.error);
    } else {
        this.playNextAction("eval");
    }
};

MacroPlayer.prototype.onInterrupt = function(eval_id) {
    if (Storage.getBool("debug")) {
        console.debug("Caught interrupt exception, eval_id="+eval_id);
    }
};

// This function substitutes all occurrences of
// {{varname}} with the variable value
// Use '#NOVAR#{{' to insert '{{'
// (the function would fail if a variable contains '#novar#{' string)
MacroPlayer.prototype.expandVariables = function(param, eval_id) {
    // first replace all #NOVAR#{{ by #NOVAR#{
    param = param.replace(/#novar#\{\{/ig, "#NOVAR#{");
    // substitute {{vars}}
    var mplayer = this;
    var handleVariable = function (match_str, var_name) {
        var t = null;
        if ( t = var_name.match(mplayer.limits.varsRe) ) {
            return mplayer.getVar(t[1]);
        } else if ( t = var_name.match(/^!extract$/i) ) {
            return mplayer.getExtractData();
        } else if ( t = var_name.match(/^!urlcurrent$/i) ) {
            return mplayer.currentURL;
        } else if ( t = var_name.match(/^!col(\d+)$/i) ) {
            return mplayer.getColumnData(imns.s2i(t[1]));
        } else if ( t = var_name.match(/^!datasource_line$/i) ) {
            return mplayer.dataSourceLine || mplayer.currentLoop;
        } else if ( t = var_name.match(/^!datasource_columns$/i) ) {
            return mplayer.dataSourceColumns;
        } else if ( t = var_name.match(/^!datasource_delimiter$/i) ) {
            return mplayer.dataSourceDelimiter;
        } else if ( t = var_name.match(/^!datasource$/i) ) {
            return mplayer.dataSourceFile;
        } else if ( t = var_name.match(/^!folder_datasource$/i) ) {
            return mplayer.dataSourceFolder ?
                mplayer.dataSourceFolder.path : "__undefined__";
        } else if ( t = var_name.match(/^!folder_download$/i) ) {
            return mplayer.defDownloadFolder ?
                mplayer.defDownloadFolder.path : "__undefined__";
        } else if ( t = var_name.match(/^!folder_macros$/i) ) {
            return mplayer.macrosFolder ?
                mplayer.macrosFolder.path : "__undefined__";
        } else if ( t = var_name.match(/^!now:(\S+)$/i) ) {
            return imns.formatDate(t[1]);
        } else if ( t = var_name.match(/^!loop$/i) ) {
            return mplayer.currentLoop;
        } else if ( t = var_name.match(/^!clipboard$/i) ) {
            return imns.Clipboard.getString() || "";
        }  else if ( t = var_name.match(/^!timeout(?:_page)?$/i) ) {
            return mplayer.timeout.toString();
        } else if ( t = var_name.match(/^!timeout_(?:tag|step)$/i) ) {
            return mplayer.timeout_tag.toString();
        } else if ( t = var_name.match(/^!timeout_download$/i) ) {
            return mplayer.timeout_download.toString();
        } else if ( t = var_name.match(/^!downloaded_file_name$/i) ) {
            return mplayer.downloadedFilename;
        } else if ( t = var_name.match(/^!downloaded_size$/i) ) {
            return mplayer.downloadedSize;
        } else if ( t = var_name.match(/^!stopwatchtime$/i) ) {
            // convert to d+\.d{3} format
            var value = mplayer.lastWatchValue.toFixed(3);
            return value;
        } else if ( t = var_name.match(/^!imagex$/i) ) {
            return mplayer.imageX;
        } else if ( t = var_name.match(/^!imagey$/i) ) {
            return mplayer.imageY;
        } else if ( t = var_name.match(/^!\S+$/) ) {
            throw new BadParameter("Unsupported variable "+var_name);
        } else {                // a user-defined variable
            return mplayer.getUserVar(var_name);
        }
    };


    // check for "eval" command
    var eval_re = new RegExp("^eval\\s*\\((.*)\\)$", "i");
    var match = null;
    if (match = eval_re.exec(param)) {
        var escape = function (s) {
            var x = s.toString();
            return x.replace(/"/g, "\\\\\"").
                replace(/'/g, "\\\\\'").
                replace(/\n/g, "\\\\n").
                replace(/\r/g, "\\\\r");
        };
        var js_str = match[1].replace(/\{\{(\S+?)\}\}/g, function(m, s) {
            return escape(handleVariable(m, s))
        });
        // substitute all #novar#{ by {{
        js_str = js_str.replace(/#novar#\{(?=[^\{])/ig, "{{");
        param = this.do_eval(js_str, eval_id);
    } else {
        param = param.replace(/\{\{(\S+?)\}\}/g, handleVariable);
        // substitute all #novar#{ by {{
        param = param.replace(/#novar#\{(?=[^\{])/ig, "{{");
    }

    return param;
};



======================================================================
FILE PATH: mrecorder.js
======================================================================
/*
Copyright © 1992-2021 Progress Software Corporation and/or one of its subsidiaries or affiliates. All rights reserved.
*/

"use strict";

// An object to encapsulate all recording operations
// on extension side
function Recorder(win_id) {
    this.win_id = win_id;
    this.recording = false;
    communicator.registerHandler("record-action",
                                 this.onRecordAction.bind(this), win_id);
    communicator.registerHandler("password-element-focused",
                                 this.onPasswordElementFocused.bind(this),
                                 win_id)
    communicator.registerHandler("query-state",
                                 this.onQueryState.bind(this), win_id);
    // make bindings of event listeners
    this.onActivated = this.onTabActivated.bind(this);
    this.onCreated = this.onTabCreated.bind(this);
    // this.onUpdated = this.onTabUpdated.bind(this);
    this.onRemoved = this.onTabRemoved.bind(this);
    this.onMoved = this.onTabMoved.bind(this);
    this.onAttached = this.onTabAttached.bind(this);
    this.onDetached = this.onTabDetached.bind(this);

    // Debugger protocol
    // this.onEvent = this.onDebugProtoEvent.bind(this);
    // this.onDetach = this.onDebuggerDetached.bind(this);

    // bindings to monitor network activity
    this.onAuth = this.onAuthRequired.bind(this);
    // this.onRequest = this.onBeforeRequest.bind(this);
    // this.onRedirect = this.onBeforeRedirect.bind(this);
    // this.onSendHeaders = this.onBeforeSendHeaders.bind(this);
    // this.onCompleted = this.onReqCompleted.bind(this);
    // this.onReqError = this.onErrorOccurred.bind(this);
    // this.onHeaders = this.onHeadersReceived.bind(this);
    // this.onResponse = this.onResponseStarted.bind(this);
    // this.onSend = this.onSendHeaders.bind(this);

    this.onCommitted = this.onNavigation.bind(this);
    this._onDownloadCreated = this.onDownloadCreated.bind(this);
    this._onContextMenu = this.onContextMenu.bind(this);
};


Recorder.prototype.checkForFrameChange = function(frame) {
    if (frame.number != this.currentFrameNumber) {
        this.currentFrameNumber = frame.number;
        if (0 && frame.name) {
            this.recordAction("FRAME NAME=\""+frame.name+"\"");
        } else {
            this.recordAction("FRAME F="+frame.number.toString());
        }
    }
};


Recorder.prototype.start = function() {
    // console.info("start recording");
    this.writeEncryptionType = true;
    this.password = null;
    this.canEncrypt = true
    context.updateState(this.win_id,"recording");
    var panel = context[this.win_id].panelWindow;
    if (panel && !panel.closed) {
        panel.showLines();
        panel.setStatLine("Recording...", "info");
    }
    // create array to store recorded actions
    this.actions = new Array();
    var recorder = this;
    chrome.tabs.query({active: true, windowId: this.win_id}, function (tabs) {
        recorder.recording = true;
        // save starting tab index
        recorder.startTabIndex = tabs[0].index;
        // recorder.tab_id = tabs[0].id;
        // add browser events listeners
        recorder.addListeners();
        // reset frame number
        recorder.currentFrameNumber = 0;
        // notify content script that recording was started
        communicator.broadcastMessage("start-recording", {
            args: {favorId: Storage.getBool("recording-prefer-id"),
                   cssSelectors: Storage.getBool("recording-prefer-css-selectors"),
                   recordMode: Storage.getChar("record-mode")}
        }, recorder.win_id);
        // save intial commands
        recorder.recordAction("VERSION BUILD=" + Storage.getChar("version").replace(/\./g, "") + " RECORDER=CR");
        if (!/^chrome:\/\//.test(tabs[0].url)) {
            recorder.recordAction("URL GOTO="+tabs[0].url);
        }
    });
};


Recorder.prototype.stop = function() {
    // console.info("stop recording");
    // notify content script that recording was stopped
    communicator.broadcastMessage("stop-recording", {}, this.win_id);
    context.updateState(this.win_id, "idle");

    this.recording = false;
    this.removeListeners();
    // remove text from badge
    badge.clearText(this.win_id);
    var panel = context[this.win_id].panelWindow;
    if (panel && !panel.closed)
        panel.showMacroTree();
};


Recorder.prototype.beforeRecordAction = function(cmd) {
    // check for double-command
    var match_part = cmd;
    if (/^(tag .*\s+content\s*=)/i.test(cmd))
        match_part = RegExp.$1;
    if (!/^event/i.test(cmd) &&
        this.actions.length &&
        this.actions[this.actions.length-1].indexOf(match_part) == 0)
    {
        // remove previously recorded element if it matches
        // with the current one
        // useful for selectboxes and double clicking
        this.popLastAction()
    }
};

Recorder.prototype.recordAction = function (cmd) {
    this.beforeRecordAction(cmd);
    var panel = context[this.win_id].panelWindow;
    this.actions.push(cmd);
    if (panel && !panel.closed) {
        panel.addLine(cmd);
    }

    badge.set(this.win_id, {
        status: "recording",
        text:  this.actions.length.toString()
    });

    this.afterRecordAction(cmd);
    // console.info("recorded action: "+cmd);
}

Recorder.prototype.recordActions = function(...actions) {
    actions.forEach(this.recordAction.bind(this))
}


Recorder.prototype.afterRecordAction = function(rec) {
}

Recorder.prototype.recordEncryptionType = function() {
    let typ = Storage.getChar("encryption-type")
    if (!typ.length)
        typ = "no"
    let enc_types = {
        "no": "SET !ENCRYPTION NO",
        "stored": "SET !ENCRYPTION STOREDKEY",
        "tmpkey": "SET !ENCRYPTION TMPKEY"
    }
    let password_promise = null
    if (typ == "no") {
        password_promise = Promise.resolve({canceled: true});
    } else if (typ == "stored") {
        let pwd = Storage.getChar("stored-password")
        // stored password is base64 encoded
        pwd = decodeURIComponent(atob(pwd))
        password_promise = Promise.resolve({password: pwd})
    } else if (typ == "tmpkey") {
        password_promise =  Rijndael.tempPassword ?
            Promise.resolve({
                password: Rijndael.tempPassword
            }) : dialogUtils.openDialog("passwordDialog.html",
                                        "iMacros Password Dialog",
                                        {type: "askPassword"})
    }

    password_promise.then(response => {
        this.recordAction(
            enc_types[response.canceled ? "no" : typ]
        )
        if (!response.canceled) {
            this.password = response.password
            if (typ == "tmpkey")
                Rijndael.tempPassword = response.password
        } else {
            this.canEncrypt = false
        }
    })
}

Recorder.prototype.onPasswordElementFocused = function(data, tab_id, callback) {
    typeof (callback) == "function" &&
        callback()

    if (!this.writeEncryptionType)
        return

    this.writeEncryptionType = false

    // onPasswordElementFocused is called when a password element gets focus. To
    // not break the sequence of events we defer writing encryption time until
    // we get click or keyup events. In case the focus was gained by any other
    // means, e.g. throw changing tab we write the encryption type straight
    // away.
    let cur = this.peekLastAction()
    if (cur.indexOf("EVENT TYPE=KEYDOWN") == 0)
        this.pendingEncRecord = "keydown"
    else if (cur.indexOf("EVENT TYPE=MOUSEDOWN") == 0)
        this.pendingEncRecord = "mousedown"
    else
        this.recordEncryptionType()
}

Recorder.prototype.onRecordAction = function(data, tab_id, callback) {
    // console.log("onRecordAction, data="+JSON.stringify(data));
    typeof (callback) == "function" &&   // release resources
        callback();

    if (data._frame) {
        this.checkForFrameChange(data._frame);
    }

    let in_event_mode = Storage.getChar("record-mode") == "event"
    this.recordAction(data.action)
    // test action for password element
    if (!in_event_mode && data.extra && data.extra.encrypt) {
         // handle password
        this.encryptTagCommand()
    } else if (in_event_mode && data.extra) {
        this.packAction(data.extra)
    }
}


Recorder.prototype.removeLastLine = function(n) {
    var num = n || 1;
    var panel = context[this.win_id].panelWindow;
    if (panel && !panel.closed) {
        while (num--)
            panel.removeLastLine();
    }
};

Recorder.prototype.peekLastAction = function() {
    return this.actions.length? this.actions[this.actions.length-1] : ""
}

Recorder.prototype.popLastAction = function() {
    console.assert(this.actions.length > 0, "popLastAction is called"+
                   " but action list is empty")
    this.removeLastLine()
    return this.actions.pop()
}

Recorder.prototype.popLastActions = function(n) {
    console.assert(this.actions.length > n, "popLastActions is called"+
                   " but action list is empty")
    let arr = []
    while (n-- > 0) {
        this.removeLastLine()
        arr.push(this.actions.pop())
    }

    return arr
}

Recorder.prototype.packClickEvent = function(extra) {
    console.assert(this.actions.length >= 2, "click event should be "+
                   "preceeded by at least two actions");
    let mdown_action = "EVENT TYPE=MOUSEDOWN SELECTOR=\""+
        extra.selector+"\""
    let mup_action = "EVENT TYPE=MOUSEUP"
    let [cur, prv, pprv] = this.popLastActions(3)
    if (pprv.indexOf(mdown_action) == 0 &&
        prv.indexOf(mup_action) == 0) {
        this.recordAction(cur)
        if (this.pendingEncRecord == "mousedown") {
            this.recordEncryptionType()
            delete this.pendingEncRecord
        }
    } else {
        this.recordActions(pprv, prv, cur)
    }
}

Recorder.prototype.packDblClickEvent = function(extra) {
    console.assert(this.actions.length >= 2, "dblclick event should be "+
                   "preceeded by at least two actions")
    let click_action = "EVENT TYPE=CLICK SELECTOR=\""+extra.selector+"\""
    let [cur, prv, pprv] = this.popLastActions(3)
    if (prv.indexOf(click_action) == 0 &&
        pprv.indexOf(click_action) == 0) {
        this.recordAction(cur)
    } else {
        this.recordActions(pprv, prv, cur)
    }
}

Recorder.prototype.packMouseMoveEvent = function(extra) {
    const re = new RegExp('^events? type=mousemove\\b.+'+
                          '\\points?="(\\S+)"', "i")
    let [cur, prv] = this.popLastActions(2)
    if (this.actions.length && this.prevTarget == extra.selector) {
        let m = re.exec(prv)
        if ( m ) {
            // TODO: I'm not sure about modifiers.
            // It is possible that user depresses Shift key
            // in the middle of drag operation.
            // However, as only final modifier affects
            // the operation, I think writing last modifier
            // will work in most practical cases.
            this.recordAction(
                "EVENTS TYPE=MOUSEMOVE SELECTOR=\""+extra.selector+"\""+
                    " POINTS=\""+m[1].toString()+
                    ",("+extra.point.x+","+extra.point.y+")\""+
                    (extra.modifiers ?
                     " MODIFIERS=\""+extra.modifiers+"\"" : "")
            )
        }
    } else {
        this.prevTarget = extra.selector
        this.recordActions(prv, cur)
    }
};


Recorder.prototype.packKeyDownEvent = function(extra) {
    // basically it is only needed to save prevTarget as all the work is
    // done on keyup
    this.prevTarget = extra.selector
}

Recorder.prototype.packKeyboardEvents = function(extra) {
    // check if the just recorded keypress action can be merged with previous
    // EVENTS command (for sucessive input)
    const chars_re = new RegExp('^events? type=keypress selector=\"([^\"]+)\"'+
                                ' chars?=\"([^\"]+)\"', "i")
    const keys_re = new RegExp("^events? type=keypress selector=\"([^\"]+)\""+
                              " (keys?)=(?:(\\d+)|\"([^\"]+)\")"+
                              "(?: modifiers=\"([^\"]+)\")?", "i")
    const ch_re = new RegExp("^events? type=keypress selector=\"([^\"]+)\""+
                             " chars?=\"([^\"]+)\"", "i")
    const kd_re = new RegExp("^event type=keypress selector=\"([^\"]+)\""+
                             " key=(\\d+)(?: modifiers=\"([^\"]+)\")?", "i")

    let [cur, prv] = this.popLastActions(2)
    let cur_match = null
    let prv_match = null

    // first check if it is a char event and the previous EVENTS for the same
    // selectors are chars as well
    if ((cur_match = cur.match(ch_re)) &&
        (prv_match = prv.match(chars_re)) &&
        cur_match[1] == prv_match[1]) {
        let ch = imns.unwrap(cur_match[2])
        let chars = imns.unwrap(prv_match[2])
        if (this.encryptKeypressEvent && this.canEncrypt) {
            this.encryptKeypressEvent = false
            // decrypt chars from the previous event
            try {
                ch = Rijndael.decryptString(ch, this.password)
                chars = Rijndael.decryptString(chars, this.password)
            } catch (e) {
                // we can not continue if password is incorrect
                showInfo({
                    message: "Encryption type or stored password was changed"+
                        " while recording!",
                    win_id: this.win_id,
                })
                return
            }
            chars = Rijndael.encryptString(chars + ch, this.password)
        } else {
            chars += ch
        }

        this.recordAction(
            "EVENTS TYPE=KEYPRESS SELECTOR=\""+cur_match[1]+"\""+
                " CHARS=\""+imns.escapeLine(chars)+"\""
        )
    }
    // then check the same for control key sequence
    else if ((cur_match = cur.match(kd_re)) &&
             (prv_match = prv.match(keys_re)) &&
             cur_match[1] == prv_match[1] &&
             cur_match[5] == prv_match[5]) {
        let keys = prv_match[2] == "KEYS" ?
            JSON.parse(prv_match[4]) : [JSON.parse(prv_match[3])]
        keys.push(parseInt(cur_match[2]))
        this.recordAction(
            "EVENTS TYPE=KEYPRESS SELECTOR=\""+cur_match[1]+"\""+
                " KEYS="+"\""+JSON.stringify(keys)+"\""+
                (cur_match[3] && cur_match[3].length ?
                 " MODIFIERS=\""+cur_match[3]+"\"" : "")
        )
    }
    // and if all failed then just leave the commands intact
    else {
        this.recordActions(prv, cur)
    }

    if (this.pendingEncRecord == "keydown") {
        this.recordEncryptionType()
        delete this.pendingEncRecord
    }
}

Recorder.prototype.packSingleKeyPressEvent = function(extra, cur, prv, pprv) {
    // in fact, we need only one key event out of the trhee because on
    // replaying it unfolds into three commands
    this.recordAction(prv)
    this.packKeyboardEvents(extra)
}

Recorder.prototype.packKeyUpDownEvent = function(extra, cur, prv, pprv) {
    if (pprv)
        this.recordAction(pprv) // this should be left intact

    let cmd = "EVENT TYPE=KEYPRESS SELECTOR=\""+extra.selector+"\""+
        " KEY="+extra.key+(extra.modifiers.length ?
                           " MODIFIERS=\""+extra.modifiers+"\"" : "")
    this.recordAction(cmd)
    this.packKeyboardEvents(extra)
}

Recorder.prototype.packKeyUpEvent = function(extra) {
    console.assert(this.actions.length >= 3, "packKeyUpEvent require "+
                   "at least three recorded actions")
    if (this.prevTarget != extra.selector)
        return

    const keydown_str = "EVENT TYPE=KEYDOWN SELECTOR=\""+extra.selector+"\""
    const keypress_re = new RegExp("EVENTS? TYPE=KEYPRESS SELECTOR=\""+
                                   imns.escapeREChars(extra.selector)+"\"")

    let [cur, prv, pprv] = this.popLastActions(3)

    if (keypress_re.test(prv) && pprv.indexOf(keydown_str) == 0) {
        // it is a first key event in a sequence so just collapse three events
        // into one keypress
        this.packSingleKeyPressEvent(cur, extra, prv, pprv)
    } else if (prv.indexOf(keydown_str) == 0) {
        // this is most likely a control key
        this.packKeyUpDownEvent(extra, cur, prv, pprv)
    } else {
        // write events as is because it's not clear what to do
        this.recordActions(pprv, prv, cur)
    }
}

Recorder.prototype.packKeyPressEvent = function(extra) {
    if (!(this.encryptKeypressEvent = extra.encrypt))
        return  // do nothing

    const ch_re = new RegExp("^event type=keypress selector=\"([^\"]+)\""+
                             " char=\"([^\"]+)\"", "i")
    let cur = this.popLastAction()
    let match = cur.match(ch_re)

    if (match) {
        let ch = Rijndael.encryptString(imns.unwrap(match[2]), this.password)
        this.recordAction(
            "EVENTS TYPE=KEYPRESS SELECTOR=\""+match[1]+"\""+
                " CHARS=\""+imns.escapeLine(ch)+"\""
        )
    }
}

Recorder.prototype.packAction = function(extra) {
    // console.log("packAction rec=%s, extra=%O", rec, extra);
    if (extra.pack_type == "click") {
        this.packClickEvent(extra)
    } else if (extra.pack_type == "dblclick") {
        this.packDblClickEvent(extra)
    } else if (extra.pack_type == "mousemove") {
        this.packMouseMoveEvent(extra)
    } else if (extra.pack_type == "keydown") {
        this.packKeyDownEvent(extra)
    } else if (extra.pack_type == "keyup") {
        this.packKeyUpEvent(extra)
    } else if (extra.pack_type == "keypress") {
        this.packKeyPressEvent(extra)
    }
}

Recorder.prototype.encryptTagCommand = function() {
    let cmd = this.popLastAction()
    let m = cmd.match(/^tag\b.+\bcontent=(\S+)\s*$/i)
    if (!m) {
        console.error("encryptTagCommand called but last command"+
                      " has no CONTENT")
        return
    }
    let cyphertext = this.canEncrypt ?
        Rijndael.encryptString(m[1], this.password) : m[1]
    let updated_cmd = cmd.replace(/(content)=(\S+)\s*$/i, "$1="+cyphertext)
    this.recordAction(updated_cmd)
};

Recorder.prototype.saveAs = function() {
    var rec = "SAVEAS TYPE=MHT FOLDER=* FILE=*";
    this.recordAction(rec);
};

Recorder.prototype.capture = function() {
    var rec = "SAVEAS TYPE=PNG FOLDER=* FILE=*";
    this.recordAction(rec);
};



Recorder.prototype.onQueryState = function(data, tab_id, callback) {
    var recorder = this;
    chrome.tabs.get(tab_id, function (tab) {
        if (tab.windowId != recorder.win_id)
            return;
        if (tab.index < recorder.startTabIndex) {
            // don't touch tabs left of start tab
            callback({state: "idle"});
        } else {
            if (recorder.recording) {
                callback({
                    args: {favorId: Storage.getBool("recording-prefer-id"),
                           cssSelectors: Storage.getBool("recording-prefer-css-selectors"),
                           recordMode: Storage.getChar("record-mode")},
                    state: "recording",
                    frameNumber: recorder.currentFrameNumber
                });
            } else {
                callback({state: "idle"});
            }
        }
    });
};


// Add listeners for recording events
// tab selection
Recorder.prototype.onTabActivated = function(activeInfo) {
    if (this.win_id != activeInfo.windowId)
        return;
    var recorder = this;
    chrome.tabs.get(activeInfo.tabId, function (tab) {
        var cur = tab.index - recorder.startTabIndex;
        if (cur < 0) {
            // TODO: add real warning here
            console.warn("Note: Tabs LEFT "+
                         "of the start tab are not recorded.");
            return;
        }
        var cmd = "TAB T="+(cur+1);
        recorder.recordAction(cmd);
        // recorder.detachDebugger(recorder.tab_id)
        //     .then(function() {
        //         return recorder.attachDebugger(activeInfo.tabId);
        //     }).then(function() {
        //         recorder.tab_id = activeInfo.tabId;
        //     }).catch(console.error.bind(console));
    });
};

// tab creation
Recorder.prototype.onTabCreated = function(tab) {
    if (this.win_id != tab.windowId)
        return;
    // console.log("onTabCreated, %O", tab);

    if (!tab.url && !tab.title) // looks like this tab is opened by web page
        return;

    var cmd = "TAB OPEN";
    this.recordAction(cmd);
};

// // tab update
// Recorder.prototype.onTabUpdated = function(tab_id, obj, tab) {
//     if (this.win_id != tab.windowId)
//         return;
//     chrome.tabs.get(tab_id, function (tab) {
//         // TODO: wait for they added 'type' property
//         console.log("onTabUpdated, openerTabId %s", tab.openerTabId);
//         if (obj.status == "loading" && obj.url && !tab.openerTabId) {
//             var cmd = "URL GOTO="+obj.url;
//             recorder.recordAction(cmd);
//         }
//     });
// };


// tab closed
Recorder.prototype.onTabRemoved = function(tab_id) {
    var recorder = this;
    chrome.tabs.get(tab_id, function (tab) {
        if (!tab || recorder.win_id != tab.windowId)
            return;
        var cmd = "TAB CLOSE";
        recorder.recordAction(cmd);
    });
};


// tab move, give a warning
Recorder.prototype.onTabMoved = function(tab_id, obj) {
    if (this.win_id != obj.windowId)
        return;
    // TODO: add real warning
    console.warn("tab move not supported");
};

// tab attached, give a warning
Recorder.prototype.onTabAttached = function(tab_id, obj) {
    if (this.win_id != obj.newWindowId)
        return;
    // TODO: add real warning
    console.warn("tab attachment not supported");

};

// tab detached, give a warning
Recorder.prototype.onTabDetached = function(tab_id, obj) {
    if (this.win_id != obj.oldWindowId)
        return;

    // TODO: add real warning
    console.warn("tab detachment not supported");

};


Recorder.prototype.onDownloadCreated = function(dl) {
    var self = this;
    chrome.tabs.query({active: true, windowId: this.win_id}, function (tabs) {
        if (dl.referrer != tabs[0].url)
            return;
        var prev_rec = self.popLastAction()
        var rec = "ONDOWNLOAD FOLDER=*"+
            " FILE=+_{{!NOW:yyyymmdd_hhnnss}}"+
            " WAIT=YES";
        self.recordAction(rec);
        self.recordAction(prev_rec);
    });
};


Recorder.prototype.onContextMenu = function(info, tab) {
    if (!tab || this.win_id != tab.windowId)
        return;

    var self = this;
    communicator.postMessage(
        "on-rclick",
        { linkUrl: info.linkUrl, frameUrl: info.frameUrl },
        tab.id,
        function(data) {
            var fail_msg = "' Element corresponding to right click action"+
                " was not found.";
            if (!data.found) {
                self.recordAction(fail_msg);
                return;
            }
            self.checkForFrameChange(data._frame);
            var rec = "ONDOWNLOAD FOLDER=*"+
                " FILE=+_{{!NOW:yyyymmdd_hhnnss}}"+
                " WAIT=YES";
            self.recordAction(rec);
            self.recordAction(data.action);
        },
        {number: 0});
};

Recorder.prototype.onNavigation = function(details) {
    var recorder = this;
    chrome.tabs.get(details.tabId, function(tab) {
        if (!tab || tab.windowId != recorder.win_id)
            return;
        // console.log("onNavigation: %O", details);
        if (details.transitionQualifiers.length &&
            details.transitionQualifiers[0] == "forward_back") {
            // TODO: it appeared too complicated to find out
            // if it was Back or Forward button pressed,
            // so it simply records BACK command
            // anyways, there is no FORWARD command ;)
            recorder.recordAction("BACK");
        } else {
            switch(details.transitionType) {
            case "typed": case "auto_bookmark":
                recorder.recordAction("URL GOTO="+tab.url);
                break;
            case "link": case "generated":
                if (details.transitionQualifiers.length &&
                    details.transitionQualifiers[0] == "from_address_bar") {
                    recorder.recordAction("URL GOTO="+tab.url);
                }
                break;
            case "reload":
                recorder.recordAction("REFRESH");
                break;
            }
        }
    });
};


// Recorder.prototype.attachDebugger = function(tab_id) {
//     return new Promise(function(resolve, reject) {
//         chrome.debugger.attach({tabId: tab_id}, "1.1", function() {
//             if (chrome.runtime.lastError)
//                 reject(chrome.runtime.lastError);
//             else
//                 resolve();
//         });
//     });
// };

// Recorder.prototype.detachDebugger = function(tab_id) {
//     return new Promise(function(resolve, reject) {
//         chrome.debugger.detach({tabId: tab_id}, function() {
//             if (chrome.runtime.lastError)
//                 reject(chrome.runtime.lastError);
//             else
//                 resolve();
//         });
//     });
// };

// Recorder.prototype.onDebuggerDetached = function(source, reason) {
//     console.log("onDebuggerDetached, debugee %O, reason %O", source, reason);
// };

// Recorder.prototype.onDebugProtoEvent = function(source, message, params) {
//     console.log("onDebugProtoEvent, debugee %O, message %O, params %O",
//                 source, message, params);
// };

// network events
Recorder.prototype.onAuthRequired = function(details, callback) {
    // console.log("onAuthRequired: %O", details);

    // password encryption

    var enc = {};

    var typ = Storage.getChar("encryption-type");
    if (!typ.length)
        typ = "no";

    switch(typ) {
    case "no":
        enc.encrypt = false;
        if (this.writeEncryptionType) {
            this.writeEncryptionType = false;
            this.recordAction("SET !ENCRYPTION NO");
        }
        break;
    case "stored":      // get password from storage
        enc.encrypt = true;
        if (this.writeEncryptionType) {
            this.writeEncryptionType = false;
            this.recordAction("SET !ENCRYPTION STOREDKEY");
        }
        var pwd = Storage.getChar("stored-password");
        // stored password is base64 encoded
        pwd = decodeURIComponent(atob(pwd));
        enc.key = pwd;
        break;
    case "tmpkey":
        enc.encrypt = true;
        if (this.writeEncryptionType) {
            this.writeEncryptionType = false;
            this.recordAction("SET !ENCRYPTION TMPKEY");
        }

        if (!Rijndael.tempPassword) {    // ask password now
            var features = "titlebar=no,menubar=no,location=no,"+
                "resizable=yes,scrollbars=no,status=no,"+
                "width=350,height=170";
            var win = window.open("passwordDialog.html",
                                  "iMacros Password Dialog" , features);
            win.args = {
                shouldProceed: true,
                type: "loginDialog",
                // CHEAT: passwordDialog will call auth callback
                // with false user/pwd pair so next time onAuthRequired
                // will have temp password
                callback: callback
            };
            return;
        } else {
            enc.key = Rijndael.tempPassword;
        }
        break;
    }

    var features = "titlebar=no,menubar=no,location=no,"+
        "resizable=yes,scrollbars=no,status=no,"+
        "width=350,height=170";
    var win = window.open("loginDialog.html",
                          "iMacros Login Dialog" , features);
    win.args = {
        cypherData: enc,
        details: details,
        callback: callback,
        recorder: this
    };
};


// Recorder.prototype.onBeforeRequest = function(details) {
//     console.log("onBeforeReqeust: %O", details);
// };

// Recorder.prototype.onBeforeRedirect = function(details) {
//     console.log("onBeforeRedirect: %O", details);
// };


// Recorder.prototype.onBeforeSendHeaders = function(details) {
//     console.log("onBeforeSendHeaders: %O", details);
// };

// Recorder.prototype.onReqCompleted = function(details) {
//     console.log("onReqCompleted: %O", details);
// };

// Recorder.prototype.onErrorOccurred = function(details) {
//     console.log("onErrorOccured: %O", details);
// };

// Recorder.prototype.onHeadersReceived = function(details) {
//     console.log("onHeadersReceived: %O", details);
// };

// Recorder.prototype.onResponseStarted = function(details) {
//     console.log("onResponseStarted: O", details);
// };

Recorder.prototype.onSendHeaders = function(details) {
    // console.log("onSendHeaders: %O", details);
};



Recorder.prototype.addListeners = function() {
    // add listeners
    chrome.tabs.onActivated.addListener(this.onActivated);
    chrome.tabs.onCreated.addListener(this.onCreated);
    // chrome.tabs.onUpdated.addListener(this.onUpdated);
    chrome.tabs.onRemoved.addListener(this.onRemoved);
    chrome.tabs.onMoved.addListener(this.onMoved);
    chrome.tabs.onAttached.addListener(this.onAttached);
    chrome.tabs.onDetached.addListener(this.onDetached);
    chrome.downloads.onCreated.addListener(this._onDownloadCreated);
    chrome.contextMenus.onClicked.addListener(this._onContextMenu);
    const cm_title = "Automate Save As command";
    this.cm_id = chrome.contextMenus.create(
        {title: cm_title, contexts: ["link", "audio", "video", "image"]}
    );

    // network events
    chrome.webNavigation.onCommitted.addListener(this.onCommitted);
    chrome.webRequest.onAuthRequired.addListener(
        this.onAuth,
        {windowId: this.win_id, urls: ["<all_urls>"]},
        ["asyncBlocking"]
    );
    // chrome.webRequest.onBeforeRequest.addListener(
    //     this.onRequest,
    //     {windowId: this.win_id, urls: ["<all_urls>"]}
    // );
    // chrome.webRequest.onBeforeRedirect.addListener(
    //     this.onRedirect,
    //     {windowId: this.win_id, urls: ["<all_urls>"]},
    //     ["responseHeaders"]
    // );
    // chrome.webRequest.onBeforeSendHeaders.addListener(
    //     this.onSendHeaders,
    //     {windowId: this.win_id, urls: ["<all_urls>"]},
    //     ["requestHeaders"]
    // );
    // chrome.webRequest.onCompleted.addListener(
    //     this.onCompleted,
    //     {windowId: this.win_id, urls: ["<all_urls>"]},
    //     ["responseHeaders"]
    // );
    // chrome.webRequest.onErrorOccurred.addListener(
    //     this.onReqError,
    //     {windowId: this.win_id, urls: ["<all_urls>"]}
    // );
    // chrome.webRequest.onHeadersReceived.addListener(
    //     this.onHeaders,
    //     {windowId: this.win_id, urls: ["<all_urls>"]},
    //     ["responseHeaders"]
    // );
    // chrome.webRequest.onResponseStarted.addListener(
    //     this.onResponse,
    //     {windowId: this.win_id, urls: ["<all_urls>"]},
    //     ["responseHeaders"]
    // );
    // chrome.webRequest.onSendHeaders.addListener(
    //     this.onSend,
    //     {windowId: this.win_id, urls: ["<all_urls>"]},
    //     ["requestHeaders"]
    // );

    // Debugger protocol events
    // chrome.debugger.onEvent.addListener(this.onEvent);
    // chrome.debugger.onDetach.addListener(this.onDetach);
    // this.attachDebugger(this.tab_id).then(function() {
    //     console.log("debugger attached");
    // }).catch(console.error.bind(console));
};

// remove recording listeners
Recorder.prototype.removeListeners = function() {
    chrome.tabs.onActivated.removeListener(this.onActivated);
    chrome.tabs.onCreated.removeListener(this.onCreated);
    // chrome.tabs.onUpdated.removeListener(this.onUpdated);
    chrome.tabs.onRemoved.removeListener(this.onRemoved);
    chrome.tabs.onMoved.removeListener(this.onMoved);
    chrome.tabs.onAttached.removeListener(this.onAttached);
    chrome.tabs.onDetached.removeListener(this.onDetached);
    chrome.webNavigation.onCommitted.removeListener(this.onCommitted);
    chrome.downloads.onCreated.removeListener(this._onDownloadCreated);
    chrome.contextMenus.onClicked.removeListener(this._onContextMenu);
    chrome.contextMenus.remove(this.cm_id);
    // network events
    chrome.webRequest.onAuthRequired.removeListener(this.onAuth);
    // chrome.webRequest.onBeforeRequest.removeListener(this.onRequest);
    // chrome.webRequest.onBeforeRedirect.removeListener(this.onRedirect);
    // chrome.webRequest.onBeforeSendHeaders.removeListener(this.onSendHeaders);
    // chrome.webRequest.onCompleted.removeListener(this.onCompleted);
    // chrome.webRequest.onErrorOccurred.removeListener(this.onReqError);
    // chrome.webRequest.onHeadersReceived.removeListener(this.onHeaders);
    // chrome.webRequest.onResponseStarted.removeListener(this.onResponse);
    // chrome.webRequest.onSendHeaders.removeListener(this.onSend);

    // Debugger protocol events
    // chrome.debugger.onEvent.removeListener(this.onEvent);
    // chrome.debugger.onDetach.removeListener(this.onDetach);
    // this.detachDebugger(this.tab_id).catch(console.error.bind(console));
};



======================================================================
FILE PATH: mv3_compat.js
======================================================================
/*
 * MV3 Compatibility Layer
 * Provides compatibility shims for MV2 APIs that don't work in MV3
 */

// Replacement for chrome.runtime.getBackgroundPage() in MV3
// Since service workers don't have a background page, we use message passing instead
function getBackgroundContext(callback) {
    // In MV3, we can't access the background page directly
    // Instead, we send a message to the background to get the needed context

    // For now, return a proxy object that forwards calls to the background via messages
    // This is a simplified version - you may need to expand this based on usage

    chrome.runtime.sendMessage({ type: 'GET_BACKGROUND_CONTEXT' }, function(response) {
        if (chrome.runtime.lastError) {
            console.error('[iMacros MV3] Failed to get background context:', chrome.runtime.lastError);
            callback(null);
            return;
        }

        // Create a proxy object that represents the background context
        const bgProxy = {
            // Add methods and properties as needed
            context: response ? response.context : null,

            // Helper to send messages to background
            sendMessage: function(message, callback) {
                chrome.runtime.sendMessage(message, callback);
            },

            // Storage and afio might be accessed
            Storage: response ? response.Storage : null,
            afio: response ? response.afio : null
        };

        callback(bgProxy);
    });
}

// Backward compatibility wrapper
if (typeof chrome !== 'undefined' && chrome.runtime) {
    // Store the original getBackgroundPage if it exists
    const originalGetBackgroundPage = chrome.runtime.getBackgroundPage;

    // Override with our compatibility version
    // In MV3, getBackgroundPage won't work, so we provide this alternative
    if (!chrome.runtime._mv3CompatApplied) {
        chrome.runtime._mv3CompatApplied = true;

        // Try to detect if we're in MV3
        chrome.runtime.getManifest(function() {
            const manifest = chrome.runtime.getManifest();
            if (manifest.manifest_version === 3) {
                console.log('[iMacros MV3] Detected MV3, applying compatibility shims');

                // Note: We can't actually override chrome.runtime.getBackgroundPage
                // So files need to be updated to use getBackgroundContext instead
            }
        });
    }
}

// Export for use in other files
if (typeof window !== 'undefined') {
    window.getBackgroundContext = getBackgroundContext;
}



======================================================================
FILE PATH: nm_connector.js
======================================================================
/*
Copyright © 1992-2021 Progress Software Corporation and/or one of its subsidiaries or affiliates. All rights reserved.
*/


var nm_connector = {

    onInit: function(clientId, args) {
        if (clientId in this.clients) {
            this.sendResponse(clientId,
                              "Can not create new instance. Error: "+
                              "already inited (maybe two iimInit() calls?",
                              -20);
            return;
        }

		function attach(win) {
			cacheClient(win);
			// Open panel if necessary
			if (!args.options || !/-simpleui/i.test(args.options)) {
				openPanel(win.id);
			}
		}

		function cacheClient(win) {
			nm_connector.clients[clientId] = {win_id: win.id};
			nm_connector.sendResponse(clientId, "OK", 1);
		}

		function openNewBrowser() {
			chrome.windows.create({url: "about:blank"}, attach);
		}

		if (args.launched) {
			// reuse the current window
			chrome.windows.getCurrent(attach);
		}
		else if (args.openNewBrowser) {
				openNewBrowser();
        } else {            // reuse any of the "free" existing window
            chrome.windows.getAll({windowTypes: ['normal']}, function(windows) {
                var i, j, saved = false;
                for (i = 0; i < windows.length; i++) {
                    var win = windows[i], found = false;
                    for (j in nm_connector.clients) {
                        if (nm_connector.clients[j].win_id == win.id) {
                            found = true; break;
                        }
                    }
                    if (!found) { // if win.id is not among windows in use
                        attach(win);
                        saved = true; break;
                    }
                }
                if (!saved) {   // if all the windows are in use
                    // then create new window
					openNewBrowser();
                }
            });
        }
    },


    onCapture: function(clientId, args) {
        var win_id = nm_connector.clients[clientId].win_id;
        var type;
        if (/^.*\.(\w+)$/.test(args.path)) {
            if (RegExp.$1 == "jpg") {
                type = "jpeg";
            } else if (RegExp.$1 == "png") {
                type = "png";
            } else {
                nm_connector.sendResponse(clientId,
                                          "Unsupported type "+RegExp.$1, -1);
                return;
            }
        } else {
            // if no file extension is set than assume "png"
            type = "png";
            args.path += ".png";
        }

        afio.isInstalled().then(function(installed) {
            if (!installed) {
                nm_connector.sendResponse(
                    clientId,
                    "Can not instantiate file IO plugin", -1
                );
                return;
            }
            var f = null;
            if (__is_full_path(args.path)) {
                f = afio.openNode(args.path);
            } else {
                 // do not allow references to upper directories
                args.path = args.path.replace("..", "_");
                f = afio.openNode(localStorage["defdownpath"]);
                f.append(args.path);
            }
            chrome.tabs.captureVisibleTab(
                nm_connector.win_id, {format: type},
                function(data) {
                    var re = /data\:([\w-]+\/[\w-]+)?(?:;(base64))?,(.+)/;
                    var m = re.exec(data);
                    var imageData = {
                        image: m[3],
                        encoding: m[2],
                        mimeType: m[1]
                    };
                    afio.writeImageToFile(f, imageData).then(function() {
                        nm_connector.sendResponse(clientId, "OK", 1);
                    }, function(err) {
                        nm_connector.sendResponse(
                            clientId,
                            "Could not write to "+f.path, -2
                        );
                    });
                }
            );
        });

    },


    onPlay: function(clientId, args) {
        var x, win_id = this.clients[clientId].win_id;

        for (x in args.vars) { // save user vars if any
            context[win_id].mplayer.setUserVar(x, args.vars[x]);
        }

        if (args.use_profiler) {
            context[win_id].mplayer.profiler.si_enabled = true;
        }

        if (/^CODE:((?:\n|.)+)$/.test(args.source)) { // if macro is embedded
            var val = RegExp.$1;
            val = val.replace(/\[sp\]/ig, ' ');
            val = val.replace(/\[br\]/ig, '\n');
            val = val.replace(/\[lf\]/ig, '\r');
            //play macro
            getLimits().then(
                limits => context[win_id].mplayer.play(
                    {
                        name: "__noname__.iim",
                        file_id: "",
                        source: val,
                        client_id: clientId
                    },
                    limits
                )
            )
            return;
        }

        // try to load macro from file otherwise
        var name = args.source;
        if (!isMacroFile(name))
            name += ".iim";

        var file;
        if (__is_full_path(name)) {
            // full path is given
            file = afio.openNode(name);
        } else  {
            file = afio.openNode(localStorage["defsavepath"]);
            var nodes = name.split(__psep()).reverse();
            while (nodes.length)
                file.append(nodes.pop());
        }

        file.exists().then(function(exists) {
            if (!exists) {
                nm_connector.sendResponse(
                    clientId, "Can not open macro "+name, -931);
                return;
            }
            afio.readTextFile(file).then(function(val) {
                getLimits().then(
                    limits => context[win_id].mplayer.play(
                        {
                            name: file.leafName,
                            file_id: file.path,
                            source: val,
                            client_id: clientId
                        },
                        limits
                    )
                )
            }, function(e) {
                nm_connector.sendResponse(
                    clientId, "Can not read macro, error "+e.message, -931);
                return;
            });
        }, function(err) {
            nm_connector.sendResponse(
                clientId, "Can not open macro, error "+err.message, -931);
            return;
        });

    },


    handleCommand: function(clientId, cmd) {
        try {
            // console.debug("handleCommand %s for clientId %d", cmd, clientId);
            var request = JSON.parse(cmd);
        } catch(e) {
            console.error(e);
            // should never happen
            this.sendResponse(clientId,
                              "Can not parse request \""+cmd+"\"", -1);
            return;
        }

        switch (request.type) {
        case "init":
            this.onInit(clientId, request.args);
            break;

        case "play":
            this.onPlay(clientId, request.args);
            break;

		case "disconnect":
				delete this.clients[clientId];
				this.sendResponse(clientId, "OK", 1);
				break;

        case "exit":
            var win_id = this.clients[clientId].win_id;
            chrome.windows.getAll(null, function(windows) {
                if (windows.length == 1) {
                    // TODO: there should be a way to find out the pid
                    // There is chrome.procesess in the Chrome dev branch
                    // but it is not known when it moves to stable,
                    // so we try a workaround for now
                    var pid = -1;
                    nm_connector.sendResponse(clientId, "OK", 1,
                                             {waitForProcessId: pid});
                } else {
                    nm_connector.sendResponse(clientId, "OK", 1);
                }

                chrome.windows.remove(win_id, function() {
                    delete nm_connector.clients[clientId];
                });
            });

            break;

        case "show":
            var win_id = this.clients[clientId].win_id;
            var args = {
                message: request.args.message,
                errorCode: 1,
                win_id: win_id,
                macro: null
            };

            showInfo(args);
            this.sendResponse(clientId, "OK", 1);

            break;

        case "capture":
            this.onCapture(clientId, request.args);
            break;
        case "error":
            console.error("Got error from iMacros host: "+request.message);
            break;

        case "info":
            console.info("Got message from iMacros host: "+request.message);
            break;
        }
    },


    startServer: function(args) {
        const si_host = "com.ipswitch.imacros.host";
        this.clients = new Object();
        this.port = chrome.runtime.connectNative(si_host);
        this.port.onMessage.addListener(function(msg) {
            if (chrome.runtime.lastError) {
                console.error(chrome.runtime.lastError);
            } else {
                setTimeout(function() {
                    nm_connector.handleCommand(msg.clientId, msg.request);
                }, 0);
            }
        });
        var init_msg = {type: 'init'};
        if (args)
            init_msg.ac_pipe = args;
        this.port.postMessage(init_msg);
    },

    stopServer: function() {
        if (this.port)
            this.port.disconnect();
    },


    sendResponse: function(clientId, message, errorCode, extra) {
        if (errorCode < 0 && !/error/i.test(message)) {
            message = "Error: "+message;
        }
        message += " ("+errorCode+")";

        var result = {
            status: message,
            errorCode: errorCode
        };

        if (extra) {
            if (extra.extractData)
                result.extractData = extra.extractData.split("[EXTRACT]");
            if (extra.lastPerformance)
                result.lastPerformance = extra.lastPerformance;
            if (extra.waitForProcessId)
                result.waitForProcessId = extra.waitForProcessId;
            if (extra.profilerData)
                result.profilerData = extra.profilerData;
        }

        // console.debug("Sending response %s for clientId %d",
        //               JSON.stringify(result), clientId);
        this.port.postMessage({type: "command_result",
                               clientId: clientId,
                               result: JSON.stringify(result)});
    }
};



======================================================================
FILE PATH: offscreen.js
======================================================================
/*
 * iMacros MV3 Offscreen Document Handler
 * This runs with chrome.* API access (unlike sandbox.html which is sandboxed)
 */

// Define the same exception types as sandbox.js for consistency
function EvalException(msg, num) {
    this.message = msg;
    if (typeof num != "undefined")
        this.errnum = num;
    this.name = "MacroError";
}

function MacroError(txt) {
    throw new EvalException(txt, -1340);
}

// Map to store pending eval requests
const pendingEvals = new Map();

// Listen for messages from sandbox iframe
window.addEventListener('message', function (event) {
    if (event.data && event.data.type === 'eval_in_sandbox_result') {
        const id = event.data.id;
        const sendResponse = pendingEvals.get(id);
        if (sendResponse) {
            sendResponse(event.data);
            pendingEvals.delete(id);
        }
    }
});

// Handle messages from service worker via chrome.runtime.sendMessage
if (chrome && chrome.runtime && chrome.runtime.onMessage) {
    chrome.runtime.onMessage.addListener(function (message, sender, sendResponse) {
        // Handle eval requests
        if (message.type === "eval_in_sandbox") {
            // Store callback
            pendingEvals.set(message.id, sendResponse);

            // Set timeout to prevent memory leak
            setTimeout(() => {
                if (pendingEvals.has(message.id)) {
                    pendingEvals.delete(message.id);
                    sendResponse({
                        type: "eval_in_sandbox_result",
                        id: message.id,
                        error: { message: "Eval request timed out" }
                    });
                }
            }, 5000);

            // Forward to sandbox iframe
            const sandbox = document.getElementById('sandbox');
            if (sandbox && sandbox.contentWindow) {
                sandbox.contentWindow.postMessage(message, '*');
            } else {
                console.error('[iMacros MV3 Offscreen] Sandbox iframe not found');
                sendResponse({
                    type: "eval_in_sandbox_result",
                    id: message.id,
                    error: { message: "Sandbox iframe not found in offscreen document" }
                });
                pendingEvals.delete(message.id);
            }
            return true;  // Keep message channel open for async response
        }

        // Handle clipboard write requests
        if (message.type === "clipboard_write") {
            console.log('[iMacros MV3 Offscreen] Clipboard write requested');

            // Try to write to clipboard using the Clipboard API
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(message.text)
                    .then(function () {
                        console.log('[iMacros MV3 Offscreen] Clipboard write successful');
                        sendResponse({ success: true });
                    })
                    .catch(function (err) {
                        console.warn('[iMacros MV3 Offscreen] Clipboard write via API failed, trying DOM fallback:', err);
                        // Fallback to DOM method
                        try {
                            var textarea = document.createElement('textarea');
                            textarea.value = message.text;
                            textarea.style.position = 'fixed';
                            textarea.style.opacity = '0';
                            document.body.appendChild(textarea);
                            textarea.focus();
                            textarea.select();

                            var success = document.execCommand('copy');
                            document.body.removeChild(textarea);

                            console.log('[iMacros MV3 Offscreen] DOM clipboard write:', success ? 'success' : 'failed');
                            sendResponse({ success: success });
                        } catch (domErr) {
                            console.error('[iMacros MV3 Offscreen] DOM clipboard write failed:', domErr);
                            sendResponse({
                                success: false,
                                error: err.message + " | Fallback: " + domErr.message
                            });
                        }
                    });
                return true;  // Async response
            } else {
                // Fallback: Try DOM-based clipboard method immediately if API not available
                try {
                    var textarea = document.createElement('textarea');
                    textarea.value = message.text;
                    textarea.style.position = 'fixed';
                    textarea.style.opacity = '0';
                    document.body.appendChild(textarea);
                    textarea.focus();
                    textarea.select();

                    var success = document.execCommand('copy');
                    document.body.removeChild(textarea);

                    console.log('[iMacros MV3 Offscreen] DOM clipboard write:', success ? 'success' : 'failed');
                    sendResponse({ success: success });
                } catch (err) {
                    console.error('[iMacros MV3 Offscreen] DOM clipboard write failed:', err);
                    sendResponse({
                        success: false,
                        error: err.message || String(err)
                    });
                }
                return false;  // Sync response
            }
        }

        // Handle clipboard read requests
        if (message.type === "clipboard_read") {
            console.log('[iMacros MV3 Offscreen] Clipboard read requested');

            // Try to read from clipboard using the Clipboard API
            if (navigator.clipboard && navigator.clipboard.readText) {
                navigator.clipboard.readText()
                    .then(function (text) {
                        console.log('[iMacros MV3 Offscreen] Clipboard read successful');
                        sendResponse({ success: true, text: text });
                    })
                    .catch(function (err) {
                        console.warn('[iMacros MV3 Offscreen] Clipboard read via API failed:', err);
                        sendResponse({
                            success: false,
                            error: err.message
                        });
                    });
                return true;  // Async response
            } else {
                console.error('[iMacros MV3 Offscreen] Clipboard API not available');
                sendResponse({
                    success: false,
                    error: "Clipboard API not available"
                });
                return false;
            }
        }

        return false;  // Not our message
    });

    console.log('[iMacros MV3] Offscreen document initialized');
}



======================================================================
FILE PATH: options.js
======================================================================
/*
Copyright © 1992-2021 Progress Software Corporation and/or one of its subsidiaries or affiliates. All rights reserved.
*/

"use strict";


function setSecurityLevel() {
    if (!Storage.isSet("encryption-type"))
        Storage.setChar("encryption-type", "no");
    let type = Storage.getChar("encryption-type");
    if (!/^(?:no|stored|tmpkey)$/.test(type))
        type = "no";
    let stored = Storage.getChar("stored-password");
    if (stored) {
        $("#stored-password-box").val(decodeURIComponent(atob(stored)));
    }

    switch(type) {
    case "no":
        $("#type_no").prop("checked", true);
        $("#stored-password-field").hide()
        $("#temp-password-field").hide()
        break;
    case "stored":
        $("#type_stored").prop("checked", true);
        $("#stored-password-field").show()
        $("#temp-password-field").hide()
        break;
    case "tmpkey":
        $("#type_tmpkey").prop("checked", true);
        $("#stored-password-field").hide()
        $("#temp-password-field").show()
        break;
    }
}

function onSecurityChage(e) {
    let type = e.target.id.substring(5)
    switch(type) {
    case "no":
        $("#stored-password-field").hide()
        $("#temp-password-field").hide()
        break;
    case "stored":
        $("#stored-password-field").show()
        $("#temp-password-field").hide()
        $("#stored-password-box").focus()
        $("#stored-password-box").select()
        break;
    case "tmpkey":
        $("#stored-password-field").hide()
        $("#temp-password-field").show()
        $("#temp-password-box").focus()
        $("#temp-password-box").select()
        break;
    }
    Storage.setChar("encryption-type", type)
}

function updatePanelViews() {
    let bg = chrome.extension.getBackgroundPage()
    for (let x in bg.context) { // update all panels
        var panel = bg.context[x].panelWindow;
        if (panel && !panel.closed) {
            let doc = panel.frames["tree-iframe"].contentDocument;
            doc.defaultView.location.reload();
        }
    }
}

function onPathChange(which) {
    Storage.setChar(which, $("#"+which).val());
    if (which == "defsavepath")
        updatePanelViews()

}


function choosePath(which) {
    var features = "titlebar=no,menubar=no,location=no,"+
        "resizable=yes,scrollbars=no,status=no,"+
        "width=200,height=300";
    var win = window.open("browse.html", "iMacros_browse_dialog", features);

    win.args = {path: Storage.getChar(which), which: which};
}

function savePath(which, path) {
    Storage.setChar(which, path);
    $("#"+which).val(path);
    if (which == "defsavepath")
        updatePanelViews()
}


window.addEventListener("load", function () {
    $("#show-before-play-dialog").prop(
        "checked", Storage.getBool("before-play-dialog")
    ).change(function(event) {
        let checked = event.target.checked
        Storage.setBool("before-play-dialog", checked)
    })

    $("#dock-panel").prop(
        "checked", Storage.getBool("dock-panel")
    ).change(function (event) {
        let checked = event.target.checked
        Storage.setBool("dock-panel", checked);
    })

    if (!Storage.getBool("afio-installed")) {
        $("#file-access-note").addClass("settings-container");
        $("<span class='header'>File Access Not Installed</span>").prependTo("#file-access-note");
        $("<span>The File Access for iMacros Extensions module is currently " +
            "not installed. It is not available in the freeware version. " +
            "The following functionality is not available unless you have an iMacros license and " +
            "<span id='customer' class='a-link no-bold-link'>install the File Access</span> module:</span > ").appendTo("#note-header");
        $("<li>Save or play macro (.iim) files (only macros stored as bookmarks can be saved/played) </li>" +
            "<li>Read input from CSV files (!DATASOURCE command)</li> " +
            "<li>Access the file system via the !FOLDER_XXX variables, e.g. !FOLDER_DATASOURCE, !FOLDER_DOWNLOAD etc.</li>" +
            "<li>Save extracted data (SAVEAS and SAVEITEM commands)</li> " +
            "<li>Save screenshots (using the SAVEAS or SCREENSHOT commands)</li> " +
            "<li>Save stopwatch data to a log file via the STOPWATCH command " +
            "(data can be referenced in macro via the !STOPWATCHTIME variable)</li>" +
            "<li>Profile macro performance</li>").appendTo("#note-list");
        $("<span>See </span><span id='features-comparison' class='a-link no-bold-link'>" +
            "the feature comparison chart</span ><span>.</span> ").appendTo("#file-access-note");
        $("#profiler-enabled-box").addClass("disabled");
        $("#enable-profiler").attr("disabled", "disabled");
        $("#path-settings").addClass("disabled");
        $("#defsavepath").prop('disabled', true)
        $("#defdatapath").prop('disabled', true);
        $("#defdownpath").prop('disabled', true); 
        $("#defsavepath-browse").hide();
        $("#defdatapath-browse").hide();
        $("#defdownpath-browse").hide();
    }

    $("#enable-profiler").prop(
        "checked", Storage.getBool("profiler-enabled")
    ).change(function (event) {
        let checked = event.target.checked
        Storage.setBool("profiler-enabled", checked);
    })

    // paths
    $("#defsavepath").val(Storage.getChar("defsavepath"))
        .on("input", onPathChange.bind(null, "defsavepath"))
    $("#defsavepath-browse").click(choosePath.bind(null, "defsavepath"))
    $("#defdatapath").val(Storage.getChar("defdatapath"))
        .on("input", onPathChange.bind(null, "defdatapath"))
    $("#defdatapath-browse").click(choosePath.bind(null, 'defdatapath'))
    $("#defdownpath").val(Storage.getChar("defdownpath"))
        .on("input", onPathChange.bind(null, 'defdownpath'))
    $("#defdownpath-browse").click(choosePath.bind(null, 'defdownpath'))

    // encryption
    setSecurityLevel()
    $("#type_no").change(onSecurityChage);
    $("#type_stored").change(onSecurityChage);
    $("#type_tmpkey").change(onSecurityChage);
    $("#stored-password-box").on("input", function() {
        let pwd = $("#stored-password-box").val();
        pwd = btoa(encodeURIComponent(pwd));
        Storage.setChar("stored-password", pwd);
    })
    $("#temp-password-box").on("input", function() {
        let bg = chrome.extension.getBackgroundPage()
        bg.Rijndael.tempPassword = $("#temp-password-box").val()
    })

    // links
    $("#more-info-bp").click(function() {
        link(getRedirFromString('bookmarklets'));
    });
    $("#more-info-profiler").click(function() {
        link(getRedirectURL('Performance_Profiler'));
    });
    $("#password-tool-page").click(function() {
        link(getRedirectURL(160));
    });
    $("#more-info-encryption").click(function() {
        link(getRedirectURL('!ENCRYPTION'));
    });
    if (!Storage.getBool("afio-installed")) {
        $("#customer").click(function () {
            link(getRedirFromString('install-afio'));
        });
        $("#features-comparison").click(function () {
            link(getRedirFromString('compare-versions'))
        });
    };

    // record modes
    var record_modes = ["conventional", "event"];
    var record_radio = $("#record-mode-"+Storage.getChar("record-mode"));
    if (!record_radio) {
        alert("Unknown record mode type: "+Storage.getChar("record-mode"))
    } else {
        record_radio.prop("checked", true)
        for (let r of record_modes) {
            $("#record-mode-"+r).change(function(e) {
                Storage.setChar("record-mode", e.target.id.substring(12))
            });
        }
    }

    // replay speed
    let delay = Storage.getNumber("replaying-delay")
    let delay_types = [
        ["fast", x => x <= 100 || isNaN(x), 0],
        ["medium", x => x <= 1000 && x > 100, 800],
        ["slow", x => x > 1000, 2000]
    ]
    for (let [n, p, x] of delay_types) {
        $("#replay-speed-"+n).prop("checked", p(delay))
        $("#replay-speed-"+n).change(
            e => Storage.setNumber("replaying-delay", x)
        )
    }

    $("#more-info-event").click(function() {
        link(getRedirectURL("EVENT"))
    })
    $("#license-link").click(function() {
        link(getRedirFromString("EULA_Freeware"))
    })
    $("#favorid-panel").prop(
        "checked", Storage.getBool("recording-prefer-id")
    ).change(function(e) {
        Storage.setBool("recording-prefer-id", e.target.checked)
    })

    $("#css-selectors").prop(
        "checked", Storage.getBool("recording-prefer-css-selectors")
    ).change(function(e) {
        Storage.setBool("recording-prefer-css-selectors", e.target.checked)
    })
});



======================================================================
FILE PATH: overwriteDialog.js
======================================================================
/*
Copyright © 1992-2021 Progress Software Corporation and/or one of its subsidiaries or affiliates. All rights reserved.
*/

var args;

window.addEventListener("load", function() {
    chrome.windows.getCurrent(null, function(w) {
        // MV3 compatible: Use chrome.runtime.sendMessage instead of getBackgroundPage
        chrome.runtime.sendMessage({
            type: 'GET_DIALOG_ARGS',
            windowId: w.id
        }, function(result) {
            if (chrome.runtime.lastError) {
                console.error("[iMacros] Failed to get dialog args:", chrome.runtime.lastError.message);
                window.close();
                return;
            }
            if (!result || !result.success) {
                console.error("[iMacros] Background failed to get dialog args:", result?.error);
                window.close();
                return;
            }
            args = result.args;

            // Display the macro name
            document.getElementById("macro-name").textContent = args.macroName;

            // Resize and position window
            var mc = document.getElementById("main-container");
            var rc = mc.getBoundingClientRect();
            window.resizeTo(rc.width + 60, rc.height + 60);
            if (window.opener) {
                window.moveTo(
                    window.opener.screenX + window.opener.outerWidth / 2 - (rc.width + 60) / 2,
                    window.opener.screenY + window.opener.outerHeight / 2 - (rc.height + 60) / 2
                );
            }

            // Add event listeners
            document.getElementById("overwrite-button").addEventListener("click", overwrite);
            document.getElementById("save-new-button").addEventListener("click", saveAsNew);
            document.getElementById("cancel-button").addEventListener("click", cancel);

            // Focus on the Save as New button by default
            document.getElementById("save-new-button").focus();
        });
    });
});

function sendResponse(response) {
    chrome.windows.getCurrent(null, function (w) {
        // MV3 compatible: Use chrome.runtime.sendMessage instead of callback
        chrome.runtime.sendMessage({
            type: 'SET_DIALOG_RESULT',
            windowId: w.id,
            response: response
        }, function(result) {
            if (chrome.runtime.lastError) {
                console.error("[iMacros] Failed to send dialog result:", chrome.runtime.lastError.message);
            } else if (!result || !result.success) {
                console.error("[iMacros] Background failed to process dialog result:", result?.error);
            }
            // Always close the window, even if there was an error
            window.close();
        });
    });
}

function overwrite() {
    sendResponse({action: "overwrite"});
}

function saveAsNew() {
    sendResponse({action: "save-new"});
}

function cancel() {
    sendResponse({action: "cancel"});
}



======================================================================
FILE PATH: panel.js
======================================================================
/*
Copyright © 1992-2021 Progress Software Corporation and/or one of its subsidiaries or affiliates. All rights reserved.
*/


function __play(callback) {
    var win_id = args.win_id;
    var bg = chrome.extension.getBackgroundPage();
    var mplayer = bg.context[win_id].mplayer;
    var doc = window.frames["tree-iframe"].contentDocument;
    var container = doc.getElementById("imacros-macro-container");
    var div = doc.getElementById("imacros-bookmark-div");
    var macro = {};
    if (mplayer.paused || mplayer.pauseIsPending) {
        mplayer.unpause();
        return;
    }

    if (div.hasAttribute("file_id")) {
        var node = afio.openNode(div.getAttribute("file_id"));
        macro.file_id = node.path;
        afio.readTextFile(node).then(function(source) {
            macro.source = source;
            macro.name = div.getAttribute("name");
            bg.getLimits().then(limits => mplayer.play(macro, limits, callback))
        }, function(err) {
            // TODO: it would be better to display the error
            // on the info area of the panel
            console.error(err);
            alert("Can not read macro file, error "+err);
        });
    } else if (div.hasAttribute("bookmark_id")) {
        macro.source = container.value;
        macro.bookmark_id = div.getAttribute("bookmark_id");
        macro.name = div.getAttribute("name");
        bg.getLimits().then(limits => mplayer.play(macro, limits, callback))
    }
}

// play-button click handler
function play() {
    if (document.getElementById("play-button").getAttribute("disabled") == "true")
        return;
    __play(false);
}

function playLoop() {
    if (document.getElementById("loop-button").getAttribute("disabled") == "true")
        return;
    var cur = parseInt(document.getElementById("current-loop").value);
    var max = parseInt(document.getElementById("max-loop").value);
    if (cur > max) {
        alert("Current loop value should be less or equivalent max loop value");
        return;
    }

    var win_id = args.win_id;
    var bg = chrome.extension.getBackgroundPage();
    var mplayer = bg.context[win_id].mplayer;
    var doc = window.frames["tree-iframe"].contentDocument;
    var container = doc.getElementById("imacros-macro-container");
    var div = doc.getElementById("imacros-bookmark-div");
    var macro = {
        name: div.getAttribute("name"),
        times: max,
        startLoop: cur
    };

    if (div.hasAttribute("file_id")) {
        var node = afio.openNode(div.getAttribute("file_id"));
        macro.file_id = div.getAttribute("file_id");
        afio.readTextFile(node).then(function(source, err) {
            macro.source = source;
            bg.getLimits().then(limits => mplayer.play(macro, limits))
        }, function(err) {
            console.error(err);
            alert("Can not open "+container.value+
                  ", reason: "+err);
        });
    } else if (div.hasAttribute("bookmark_id")) {
        macro.source = container.value;
        bg.getLimits().then(limits => mplayer.play(macro, limits))
    }
}

// Pause button handler
function pause() {
    if (document.getElementById("pause-button").getAttribute("disabled") == "true")
        return;
    try {
        var win_id = args.win_id;
        var bg = chrome.extension.getBackgroundPage();
        var mplayer = bg.context[win_id].mplayer;
        if (mplayer.playing) {
            mplayer.pause();
        }
    } catch (e) {
        console.error(e);
    }
}

// Edit button handler
function edit() {
    if (document.getElementById("edit-button").getAttribute("disabled") == "true")
        return;
    var bg = chrome.extension.getBackgroundPage();
    var doc = window.frames["tree-iframe"].contentDocument;
    var container = doc.getElementById("imacros-macro-container");
    var div = doc.getElementById("imacros-bookmark-div");
    var source = "", name = div.getAttribute("name");
    var macro = {name: name, win_id: args.win_id};

    if (div.hasAttribute("file_id")) {
        var file_id = div.getAttribute("file_id");
        var node = afio.openNode(file_id);
        afio.readTextFile(node).then(function(source) {
            macro.source = source;
            macro.file_id = file_id;
            bg.edit(macro, true);
        }, function(e) {
            console.error(e);
            alert("Can not open "+container.value+
                  ", reason: "+e);
        });
    } else if (div.hasAttribute("bookmark_id")) {
        source = container.value;
        var bookmark_id = div.getAttribute("bookmark_id");
        macro.source = source;
        macro.bookmark_id = bookmark_id;
        bg.edit(macro, true);
    }
}


// Record button handler
function record() {
    if (document.getElementById("record-button").getAttribute("disabled") == "true")
        return;
    var win_id = args.win_id;
    var bg = chrome.extension.getBackgroundPage();
    var recorder = bg.context[win_id].recorder;
    try {
        recorder.start();
    } catch (e) {
        console.error(e);
    }
}

// Stop button handler
function stop() {
    var win_id = args.win_id;
    var bg = chrome.extension.getBackgroundPage();

    var mplayer = bg.context[win_id].mplayer;
    var recorder = bg.context[win_id].recorder;

    if (mplayer.playing) {
        mplayer.stop();
    } else if (recorder.recording) {
        recorder.stop();
        var recorded_macro = recorder.actions.join("\n");

        var macro = {source: recorded_macro, win_id: win_id,
                     name: "#Current.iim"};

        if (Storage.getChar("tree-type") == "files") {
            afio.isInstalled().then(function(installed) {
                if (installed) {
                    var node = afio.openNode(localStorage["defsavepath"]);
                    node.append("#Current.iim");
                    macro.file_id = node.path;
                    bg.edit(macro, /* overwrite */ true);
                } else {            // no file access
                    bg.edit(macro, true);
                }
            }).catch(console.error.bind(console));
        } else {
            bg.edit(macro, true);
        }
    }
}


// called when a macro is selected in tree-view
function onSelectionChanged(selected) {
    var disable = function (btns) {
        for (var x = 0; x < arguments.length; x++) {
            var b = document.getElementById(arguments[x]+"-button");
            b.setAttribute("disabled", "true");
        }
    };
    var enable = function (btns) {
        for (var x = 0; x < arguments.length; x++) {
            var b = document.getElementById(arguments[x]+"-button");
            b.setAttribute("disabled", "false");
        }
    };

    // change 'disabled' status of buttons
    if (selected) {
        enable("play", "loop", "edit");
    } else {
        disable("play", "loop", "edit");
    }
}


function updatePanel(state) {
    var show = function (btns) {
        for (var x = 0; x < arguments.length; x++) {
            document.getElementById(arguments[x]+"-button").setAttribute("collapsed", "false");
        }
    };
    var hide = function (btns) {
        for (var x = 0; x < arguments.length; x++) {
            document.getElementById(arguments[x]+"-button").setAttribute("collapsed", "true");
        }
    };
    var hideInfo = function() {
        document.getElementById("info-div").setAttribute("hidden", "true");
        document.getElementById("logo-and-links").removeAttribute("hidden");
    };
    var disable = function (btns) {
        for (var x = 0; x < arguments.length; x++) {
            var b = document.getElementById(arguments[x]+"-button");
            b.setAttribute("disabled", "true");
        }
    };
    var enable = function (btns) {
        for (var x = 0; x < arguments.length; x++) {
            var b = document.getElementById(arguments[x]+"-button");
            b.setAttribute("disabled", "false");
        }
    };
    switch(state) {
    case "playing":
        show("pause");
        hide("play");
        enable("stop-replaying");
        disable("loop", "record", "stop-recording", "saveas", "capture", "edit");
        hideInfo();
        break;
    case "paused":
        show("play");
        hide("pause");
        break;
    case "recording":
        enable("stop-recording", "saveas", "capture");
        disable("play", "loop", "record", "edit");
        hideInfo();
        break;
    case "idle":
        show("play");
        hide("pause");
        enable("play", "loop", "record", "edit");
        disable("stop-recording", "stop-replaying", "saveas", "capture");
        break;
    }

}


function onTreeSelect(type) {
    Storage.setChar("tree-type", type);
    var tree_iframe = document.getElementById("tree-iframe");
    if (type == "files") {
        document.getElementById("radio-files-tree").checked="yes";
        tree_iframe.src = "fileView.html";
    } else if (type == "bookmarks") {
        tree_iframe.src = "treeView.html";
        document.getElementById("radio-bookmarks-tree").checked="yes";
    }
}


window.addEventListener("load", function() {
    var bg = chrome.extension.getBackgroundPage();
    args = {win_id: bg.onPanelLoaded(window)};
    var tree_type = Storage.isSet("tree-type") ?
        Storage.getChar("tree-type") : "files";
    afio.isInstalled().then(function(installed) {
        if (!/^(?:files|bookmarks)$/.test(tree_type)) {
            tree_type = installed ? "files" : "bookmarks"
        }
        if (tree_type == "files" && installed) {
            onTreeSelect("files");
        } else {
            onTreeSelect("bookmarks");
        }
    }).catch(console.error.bind(console));
    // attach various event handlers
    document.getElementById("play-button").addEventListener("click", play);
    document.getElementById("pause-button").addEventListener("click", pause);
    document.getElementById("record-button").addEventListener("click", record);
    document.getElementById("stop-replaying-button").addEventListener("click", stop);
    document.getElementById("stop-recording-button").addEventListener("click", stop);
    document.getElementById("saveas-button").addEventListener("click", onSaveAs);
    document.getElementById("capture-button").addEventListener("click", onCapture);
    document.getElementById("loop-button").addEventListener("click", playLoop);
    document.getElementById("edit-button").addEventListener("click", edit);
    document.getElementById("settings-button").addEventListener("click", function() {
        link("options.html")
    });
    document.getElementById("help-button").addEventListener("click", function() {
        link(getRedirectURL('iMacros_for_Chrome'))
    });
    document.getElementById("info-edit-button").addEventListener("click", onInfoEdit);
    document.getElementById("info-help-button").addEventListener("click", onInfoHelp);
    document.getElementById("info-close-button").addEventListener("click", onInfoClose);

    document.getElementById("radio-files-tree").addEventListener("change", function() {
        onTreeSelect('files');
    });
    document.getElementById("radio-bookmarks-tree").addEventListener("change", function() {
        onTreeSelect('bookmarks');
    });

    document.body.oncontextmenu = function(e) {
        e.preventDefault();
        return false;
    };

    setAdDetails();
});


window.addEventListener("beforeunload", function() {
    var bg = chrome.extension.getBackgroundPage();
    chrome.windows.get(bg.context[args.win_id].panelId, function(p) {
        var panelBox = {
            left: p.left, top: p.top,
            width: p.width, height: p.height
        };
        Storage.setObject("panel-box", panelBox);
    });
});


function setLoopValue(val) {
    document.getElementById("current-loop").value = val;
}


// convert bookmarklet-type macro to file or vice versa
function convert() {
    var win_id = args.win_id;
    var bg = chrome.extension.getBackgroundPage();
    var doc = window.frames["tree-iframe"].contentDocument;
    var container = doc.getElementById("imacros-macro-container");
    var div = doc.getElementById("imacros-bookmark-div");
    var macro = {};
    var type;

    if (div.hasAttribute("file_id")) {
        // convert file to bookmarklet
        type = "bookmark";
        var node = afio.openNode(div.getAttribute("file_id"));
        afio.readTextFile(node).then(function(source) {
            macro.source = source;
            macro.name = div.getAttribute("name");
            bg.save(macro, false, function(macro) {
                alert("Macro copied in "+type+" storage");
            });
        }, function(e) {
            console.error(e);
            alert("Can not open "+container.value+
                  ", reason: "+e.message());
        });
    } else if (div.hasAttribute("bookmark_id")) {
        type = "file";
        // convert bookmarklet to file
        macro.source = container.value;
        macro.name = div.getAttribute("name");
        if (!/\.iim$/.test(macro.name))  // append .iim extension
            macro.name += ".iim";
        var node = afio.openNode(localStorage["defsavepath"]);
        node.append(macro.name);
        macro.file_id = node.path;
        bg.save(macro, false, function(macro) {
            alert("Macro copied in "+type+" storage");
        });
    }
}




function showLines(code) {
    document.getElementById("tree-view").setAttribute("hidden", "true");
    document.getElementById("macro-view").removeAttribute("hidden");
    if (code && code.length) {
        document.getElementById("macro-iframe").contentWindow.mv.showLines(code);
    } else {
        document.getElementById("macro-iframe").contentWindow.mv.clearAllLines();
    }
}

function showMacroTree() {
    document.getElementById("tree-view").removeAttribute("hidden");
    document.getElementById("macro-view").setAttribute("hidden", "true");
}

function addLine(txt) {
    document.getElementById("macro-iframe").contentWindow.mv.addLine(txt);
}

function highlightLine(line) {
    document.getElementById("macro-iframe").contentWindow.mv.highlightLine(line);
}

function setStatLine(txt, type) {
    document.getElementById("macro-iframe").contentWindow.mv.setStatLine(txt, type);
}

function removeLastLine() {
    document.getElementById("macro-iframe").contentWindow.mv.removeLastLine();
}


var info_args = null;

function showInfo(args) {
    info_args = args;
    var info_div = document.getElementById("info-div");
    info_div.removeAttribute("hidden");
    document.getElementById("logo-and-links").setAttribute("hidden", "true");

    if (args.errorCode != 1) {
        document.getElementById("info-area").setAttribute("type", "error");
        document.getElementById("info-edit-button").removeAttribute("collapsed");
        document.getElementById("info-help-button").removeAttribute("collapsed");
    } else {
        document.getElementById("info-area").setAttribute("type", "message");
        document.getElementById("info-edit-button").setAttribute("collapsed", "true");
        document.getElementById("info-help-button").setAttribute("collapsed", "true");
    }

    document.getElementById("info-area").textContent = args.message;
}

function onInfoClose() {
    document.getElementById("info-div").setAttribute("hidden", "true");
    document.getElementById("logo-and-links").removeAttribute("hidden");
}


function onInfoHelp() {
    var url = getRedirFromString("error");
	//info_args.errorCode;
    var bg = chrome.extension.getBackgroundPage();
    bg.addTab(url, info_args.win_id);
}

function onInfoEdit() {
    // TODO: pass line number to editor
    // var line = 0;
    // if (/, line:\s*(\d+)(?:\s+\(.*\))?$/.test(info_args.message))
    //     line = parseInt(RegExp.$1);
    var bg = chrome.extension.getBackgroundPage();
    bg.edit(info_args.macro, true);
}

function onSaveAs() {
    if (document.getElementById("saveas-button").getAttribute("disabled") == "true")
        return;
    var win_id = args.win_id;
    var bg = chrome.extension.getBackgroundPage();
    bg.context[win_id].recorder.saveAs();
}

function onCapture() {
    if (document.getElementById("capture-button").getAttribute("disabled") == "true")
        return;
    var win_id = args.win_id;
    var bg = chrome.extension.getBackgroundPage();
    bg.context[win_id].recorder.capture();
}


function setAdDetails() {
    var ad_link = document.getElementById("ad-link");
    var ad_image = document.getElementById("ad-image");
    var ad_image_link = document.getElementById("ad-image-link");
    var bg = chrome.extension.getBackgroundPage();

    bg.isPersonalVersion().then(function(personal) {
        bg.xhr("skin/ads.json", "plain/text")
            .then(function(response) {
                let ads = JSON.parse(response);
                let ad_index = personal ? 0 : Math.floor(Math.random() * ads.length)

                ad_link.innerText = ads[ad_index].ad_text;
                var href = ads[ad_index].ad_link;
                ad_link.addEventListener("click", function() {
                    link(href);
                });
                ad_image_link.addEventListener("click", function() {
                    link(href);
                });
                ad_image.src = "../skin/ads/" + ads[ad_index].ad_img;
            })
    })
}



======================================================================
FILE PATH: passwordDialog.js
======================================================================
/*
Copyright © 1992-2021 Progress Software Corporation and/or one of its subsidiaries or affiliates. All rights reserved.
*/

function sendResponse(response) {
    chrome.windows.getCurrent(null, function(w) {
        let bg = chrome.extension.getBackgroundPage()
        bg.dialogUtils.setDialogResult(w.id, response)
    })
}

function ok() {
    let pwd = document.getElementById("password")
    sendResponse({password: pwd.value});
    window.close()
}

function cancel() {
    sendResponse({canceled: true})
    window.close()
}

window.addEventListener("load", function(evt) {
    document.getElementById("password").focus()
    document.getElementById("more-info-encryption").addEventListener("click", function() {
        link(getRedirectURL('!ENCRYPTION'));
    });
    resizeToContent(window, document.getElementById('container'));
    document.getElementById("password").addEventListener("keypress", function(e) {
        if (e.which == 13) ok();
    });
    document.getElementById("ok-button").addEventListener("click", ok);
    document.getElementById("cancel-button").addEventListener("click", cancel);
    // prevent right-click
    document.body.oncontextmenu = function(e) {
        e.preventDefault();
        return false;
    };
}, true);



======================================================================
FILE PATH: promptDialog.js
======================================================================
﻿/*
Copyright © 1992-2021 Progress Software Corporation and/or one of its subsidiaries or affiliates. All rights reserved.
*/
// Custom prompt function 
// as alternative for JavaScript prompt()

function sendResponse(response) {
    chrome.windows.getCurrent(null, function (w) {
        let bg = chrome.extension.getBackgroundPage();
        bg.dialogUtils.setDialogResult(w.id, response)
    })
}

function getArguments(windowId) {
    let bg = chrome.extension.getBackgroundPage()
    return bg.dialogUtils.getDialogArgs(windowId)
}

function ok() {
    let prompt_value = document.getElementById('prompt-input-text').value;
    sendResponse({ inputValue: prompt_value });
    window.close()
}

function cancel() {
    sendResponse({ canceled: true })
    window.close()
}

window.addEventListener("load", function (evt) {

    chrome.windows.getCurrent(null, function (w) {
        var myArgs = getArguments(w.id);
        document.getElementById("data-field").textContent = myArgs.text;
        var promptInput = document.getElementById("prompt-input-text");
        //document.getElementById("ok-button").addEventListener("click", ok);
        let okButton = document.getElementById("ok-button");
        okButton.addEventListener("click", ok);
        okButton.focus();
        okButton.addEventListener("keydown", function(e) {
            var type = e.type;
            if (type === "keydown"){
                if((e.keyCode === 13) || (e.keyCode === 32)){
                    ok();
                    e.preventDefault();
                }
            }
        });
        // prompt dialog: type = askInput
        if (myArgs.type == "askInput") {
            if (typeof(myArgs.default) != "undefined") {
               promptInput.defaultValue = myArgs.default;
            }
            promptInput.focus();
            promptInput.select();
            promptInput.addEventListener("keypress", function(e) {
                if (e.which == 13) ok();
            });
            var cancelButton = document.createElement("div");
            cancelButton.id = "cancel-button";
            cancelButton.className = "button icon-button";
            cancelButton.innerHTML = "<span>Cancel</span>";
            cancelButton.addEventListener("click", cancel);
            document.getElementById('buttons').appendChild(cancelButton);
            
            resizeToContent(window, document.getElementById('container'));
        }
        // alert dialog: type = alert
        else {
            promptInput.style.display = "none";            
            //document.getElementById("buttons").style.webkitBoxPack = "end"; // moves the button to right
            resizeToContent(window, document.getElementById('container'));
        }
    });
    // document.addeventlistener("keypress", function (e) {
    //    if (e.which == 13) ok();
    // });

    // prevent right-click
    document.body.oncontextmenu = function (e) {
        e.preventDefault();
        return false;
    };
}, true);



======================================================================
FILE PATH: reproduce_issue.js
======================================================================

const im_strre = "(?:\"(?:[^\"\\\\]|\\\\[0btnvfr\"'\\\\])*\"|" +
    "eval\\s*\\(\"(?:[^\"\\\\]|\\\\[\\w\"'\\\\])*\"\\)|" +
    "\\S*)";

const runRegex = new RegExp("^macro\\s*=\\s*(" + im_strre + ")\\s*$", "i");

function testRun(line) {
    const parts = line.trim().split(/\s+/);
    const cmdName = parts[0].toLowerCase();
    const params = line.substring(cmdName.length).trim();
    const match = params.match(runRegex);
    console.log(`Testing RUN: '${line}'`);
    if (match) {
        console.log("Match found!");
        console.log("1:", match[1]);
    } else {
        console.log("No match.");
    }
}

testRun("RUN MACRO=RUN_Test_Sub_Simple.iim");



======================================================================
FILE PATH: rijndael.js
======================================================================
/*
 Crypto utilities


 Original copyright (c) 2001 Fritz Schneider
 
 This software is provided as-is, without express or implied warranty.  
 Permission to use, copy, modify, distribute or sell this software, with or
 without fee, for any purpose and by any individual or organization, is hereby
 granted, provided that the above copyright notice and this paragraph appear 
 in all copies. Distribution as a part of an application or binary must
 include the above copyright notice in the documentation and/or other materials
 provided with the application or distribution.


   As the above disclaimer notes, you are free to use this code however you
   want. However, I would request that you send me an email 
   (fritz /at/ cs /dot/ ucsd /dot/ edu) to say hi if you find this code useful
   or instructional. Seeing that people are using the code acts as 
   encouragement for me to continue development. If you *really* want to thank
   me you can buy the book I wrote with Thomas Powell, _JavaScript:
   _The_Complete_Reference_ :)

   This code is an UNOPTIMIZED REFERENCE implementation of Rijndael. 
   If there is sufficient interest I can write an optimized (word-based, 
   table-driven) version, although you might want to consider using a 
   compiled language if speed is critical to your application. As it stands,
   one run of the monte carlo test (10,000 encryptions) can take up to 
   several minutes, depending upon your processor. You shouldn't expect more
   than a few kilobytes per second in throughput.

   Also note that there is very little error checking in these functions. 
   Doing proper error checking is always a good idea, but the ideal 
   implementation (using the instanceof operator and exceptions) requires
   IE5+/NS6+, and I've chosen to implement this code so that it is compatible
   with IE4/NS4. 

   And finally, because JavaScript doesn't have an explicit byte/char data 
   type (although JavaScript 2.0 most likely will), when I refer to "byte" 
   in this code I generally mean "32 bit integer with value in the interval 
   [0,255]" which I treat as a byte.

   See http://www-cse.ucsd.edu/~fritz/rijndael.html for more documentation
   of the (very simple) API provided by this code.

                                               Fritz Schneider
                                               fritz at cs.ucsd.edu
 
*/


var Rijndael = (function () {
// Rijndael parameters --  Valid values are 128, 192, or 256

    var keySizeInBits = 256;
    var blockSizeInBits = 128;

    // Note: in the following code the two dimensional arrays are indexed as
    //       you would probably expect, as array[row][column]. The state arrays
    //       are 2d arrays of the form state[4][Nb].


    // The number of rounds for the cipher, indexed by [Nk][Nb]
    var roundsArray = [ ,,,,[,,,,10,, 12,, 14],, 
        [,,,,12,, 12,, 14],, 
        [,,,,14,, 14,, 14] ];

    // The number of bytes to shift by in shiftRow, indexed by [Nb][row]
    var shiftOffsets = [ ,,,,[,1, 2, 3],,[,1, 2, 3],,[,1, 3, 4] ];

    // The round constants used in subkey expansion
    var Rcon = [ 
        0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 
        0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 
        0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 
        0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 
        0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91
    ];

// Precomputed lookup table for the SBox
    var SBox = [
        99, 124, 119, 123, 242, 107, 111, 197,  48,
        1, 103,  43, 254, 215, 171, 118, 202, 130,
        201, 125, 250,  89,  71, 240, 173, 212, 162,
        175, 156, 164, 114, 192, 183, 253, 147,  38,
        54,  63, 247, 204,  52, 165, 229, 241, 113,
        216,  49,  21,   4, 199,  35, 195,  24, 150,
        5, 154,   7,  18, 128, 226, 235,  39, 178,
        117,   9, 131,  44,  26,  27, 110,  90, 160,
        82,  59, 214, 179,  41, 227,  47, 132,  83,
        209,   0, 237,  32, 252, 177,  91, 106, 203,
        190,  57,  74,  76,  88, 207, 208, 239, 170,
        251,  67,  77,  51, 133,  69, 249,   2, 127,
        80,  60, 159, 168,  81, 163,  64, 143, 146,
        157,  56, 245, 188, 182, 218,  33,  16, 255,
        243, 210, 205,  12,  19, 236,  95, 151,  68,
        23,  196, 167, 126,  61, 100,  93,  25, 115,
        96, 129,  79, 220,  34,  42, 144, 136,  70,
        238, 184,  20, 222,  94,  11, 219, 224,  50,
        58,  10,  73, 6,  36,  92, 194, 211, 172,
        98, 145, 149, 228, 121, 231, 200,  55, 109,
        141, 213,  78, 169, 108,  86, 244, 234, 101,
        122, 174,   8, 186, 120,  37, 46,  28, 166,
        180, 198, 232, 221, 116,  31,  75, 189, 139,
        138, 112,  62, 181, 102,  72,   3, 246,  14,
        97,  53,  87, 185, 134, 193,  29, 158, 225,
        248, 152,  17, 105, 217, 142, 148, 155,  30,
        135, 233, 206,  85,  40, 223, 140, 161, 137,
        13, 191, 230,  66, 104,  65, 153,  45,  15,
        176,  84, 187, 22 ];

// Precomputed lookup table for the inverse SBox
    var SBoxInverse = [
        82,   9, 106, 213,  48,  54, 165,  56, 191,
        64, 163, 158, 129, 243, 215, 251, 124, 227,
        57, 130, 155,  47, 255, 135,  52, 142,  67,
        68, 196, 222, 233, 203,  84, 123, 148,  50,
        166, 194,  35,  61, 238,  76, 149,  11,  66,
        250, 195,  78,   8,  46, 161, 102,  40, 217,
        36, 178, 118,  91, 162,  73, 109, 139, 209,
        37, 114, 248, 246, 100, 134, 104, 152,  22,
        212, 164,  92, 204,  93, 101, 182, 146, 108,
        112,  72,  80, 253, 237, 185, 218,  94,  21,
        70,  87, 167, 141, 157, 132, 144, 216, 171,
        0, 140, 188, 211,  10, 247, 228,  88,   5,
        184, 179,  69,   6, 208,  44,  30, 143, 202,
        63,  15,   2, 193, 175, 189,   3,   1,  19,
        138, 107,  58, 145,  17,  65,  79, 103, 220,
        234, 151, 242, 207, 206, 240, 180, 230, 115,
        150, 172, 116,  34, 231, 173, 53, 133, 226,
        249,  55, 232,  28, 117, 223, 110,  71, 241,
        26, 113,  29, 41, 197, 137, 111, 183,  98,
        14, 170,  24, 190,  27, 252,  86,  62,  75,
        198, 210, 121,  32, 154, 219, 192, 254, 120,
        205,  90, 244,  31, 221, 168, 51, 136,   7,
        199,  49, 177,  18,  16,  89,  39, 128, 236,
        95,  96,  81, 127, 169,  25, 181,  74,  13,
        45, 229, 122, 159, 147, 201, 156, 239, 160,
        224,  59,  77, 174,  42, 245, 176, 200, 235,
        187,  60, 131,  83, 153,  97, 23,  43,   4,
        126, 186, 119, 214,  38, 225, 105,  20,  99,
        85,  33,  12, 125
    ];

    var SBoxInverse1 = [
        254,  58,  12, 203, 236,  12,   6, 145, 248,
        120, 116, 200, 233, 105,  92, 102,   5, 255,
        30, 243, 104,  63,  61, 137,  85,  39, 118,
        182, 179, 124, 27,  19,  19, 107,  28, 179,
        6,  54, 249, 102,  90,  73,  23, 221, 173,
        247, 249, 134,  51,  49,  65, 116,  79, 147,
        184, 207, 136, 164,  21, 213, 68, 217, 228,
        234, 195, 234,  24, 215, 245,  96, 187, 115,
        62, 128, 212, 236, 136,  55,  75, 208, 166,
        50,  11,   7,  47, 204, 207, 157, 218,  11,
        159,  42, 113, 245,  87, 217
    ];

// This method circularly shifts the array left by the number of elements
// given in its parameter. It returns the resulting array and is used for 
// the ShiftRow step. Note that shift() and push() could be used for a more 
// elegant solution, but they require IE5.5+, so I chose to do it manually. 

    function cyclicShiftLeft(theArray, positions) {
        var temp = theArray.slice(0, positions);
        theArray = theArray.slice(positions).concat(temp);
        return theArray;
    }

    // Cipher parameters ... do not change these
    var Nk = keySizeInBits / 32;                   
    var Nb = blockSizeInBits / 32;
    var Nr = roundsArray[Nk][Nb];

    // Multiplies the element "poly" of GF(2^8) by x. See the Rijndael spec.

    function xtime(poly) {
        poly <<= 1;
        return ((poly & 0x100) ? (poly ^ 0x11B) : (poly));
    }

// Multiplies the two elements of GF(2^8) together and returns the result.
// See the Rijndael spec, but should be straightforward: for each power of
// the indeterminant that has a 1 coefficient in x, add y times that power
// to the result. x and y should be bytes representing elements of GF(2^8)

    function mult_GF256(x, y) {
        var bit, result = 0;
        
        for (bit = 1; bit < 256; bit *= 2, y = xtime(y)) {
            if (x & bit) 
                result ^= y;
        }
        return result;
    }

// Performs the substitution step of the cipher. State is the 2d array of
// state information (see spec) and direction is string indicating whether
// we are performing the forward substitution ("encrypt") or inverse 
// substitution (anything else)

    function byteSub(state, direction) {
        var S;
        if (direction == "encrypt") // Point S to the SBox we're using
            S = SBox;
        else
            S = SBoxInverse;
        for (var i = 0; i < 4; i++) // Substitute for every byte in state
            for (var j = 0; j < Nb; j++)
                state[i][j] = S[state[i][j]];
    }

// Performs the row shifting step of the cipher.

    function shiftRow(state, direction) {
        for (var i=1; i<4; i++)               // Row 0 never shifts
            if (direction == "encrypt")
                state[i] = cyclicShiftLeft(state[i], shiftOffsets[Nb][i]);
        else
            state[i] = cyclicShiftLeft(state[i], Nb - shiftOffsets[Nb][i]);

    }

// Performs the column mixing step of the cipher. Most of these steps can
// be combined into table lookups on 32bit values (at least for encryption)
// to greatly increase the speed. 

    function mixColumn(state, direction) {
        var b = [];             // Result of matrix multiplications
        for (var j = 0; j < Nb; j++) { // Go through each column...
            for (var i = 0; i < 4; i++) { // and for each row in the column...
                if (direction == "encrypt")
                    b[i] = mult_GF256(state[i][j], 2) ^ // perform mixing
                mult_GF256(state[(i+1)%4][j], 3) ^ 
                    state[(i+2)%4][j] ^ 
                    state[(i+3)%4][j];
                else 
                    b[i] = mult_GF256(state[i][j], 0xE) ^ 
                    mult_GF256(state[(i+1)%4][j], 0xB) ^
                    mult_GF256(state[(i+2)%4][j], 0xD) ^
                    mult_GF256(state[(i+3)%4][j], 9);
            }
            for (var i = 0; i < 4; i++) // Place result back into column
                state[i][j] = b[i];
        }
    }

// Adds the current round key to the state information. Straightforward.

    function addRoundKey(state, roundKey) {
        for (var j = 0; j < Nb; j++) { // Step through columns...
            state[0][j] ^= (roundKey[j] & 0xFF); // and XOR
            state[1][j] ^= ((roundKey[j]>>8) & 0xFF);
            state[2][j] ^= ((roundKey[j]>>16) & 0xFF);
            state[3][j] ^= ((roundKey[j]>>24) & 0xFF);
        }
    }

// This function creates the expanded key from the input (128/192/256-bit)
// key. The parameter key is an array of bytes holding the value of the key.
// The returned value is an array whose elements are the 32-bit words that 
// make up the expanded key.

    function keyExpansion(key) {
        var expandedKey = new Array();
        var temp;

        // in case the key size or parameters were changed...
        Nk = keySizeInBits / 32;                   
        Nb = blockSizeInBits / 32;
        Nr = roundsArray[Nk][Nb];

        for (var j=0; j < Nk; j++)     // Fill in input key first
            expandedKey[j] = 
            (key[4*j]) | (key[4*j+1]<<8) | (key[4*j+2]<<16) | (key[4*j+3]<<24);

        // Now walk down the rest of the array filling in expanded key bytes as
        // per Rijndael's spec
        for (j = Nk; j < Nb * (Nr + 1); j++) { // For each word of expanded key
            temp = expandedKey[j - 1];
            if (j % Nk == 0) 
                temp = ( (SBox[(temp>>8) & 0xFF]) |
                         (SBox[(temp>>16) & 0xFF]<<8) |
                         (SBox[(temp>>24) & 0xFF]<<16) |
                         (SBox[temp & 0xFF]<<24) ) ^
                Rcon[Math.floor(j / Nk) - 1];
            else if (Nk > 6 && j % Nk == 4)
                temp = (SBox[(temp>>24) & 0xFF]<<24) |
                (SBox[(temp>>16) & 0xFF]<<16) |
                (SBox[(temp>>8) & 0xFF]<<8) |
                (SBox[temp & 0xFF]);
            expandedKey[j] = expandedKey[j-Nk] ^ temp;
        }
        return expandedKey;
    }

// Rijndael's round functions... 

    function Round(state, roundKey) {
        byteSub(state, "encrypt");
        shiftRow(state, "encrypt");
        mixColumn(state, "encrypt");
        addRoundKey(state, roundKey);
    }

    function InverseRound(state, roundKey) {
        addRoundKey(state, roundKey);
        mixColumn(state, "decrypt");
        shiftRow(state, "decrypt");
        byteSub(state, "decrypt");
    }

    function FinalRound(state, roundKey) {
        byteSub(state, "encrypt");
        shiftRow(state, "encrypt");
        addRoundKey(state, roundKey);
    }

    function InverseFinalRound(state, roundKey){
        addRoundKey(state, roundKey);
        shiftRow(state, "decrypt");
        byteSub(state, "decrypt");  
    }

// encrypt is the basic encryption function. It takes parameters
// block, an array of bytes representing a plaintext block, and expandedKey,
// an array of words representing the expanded key previously returned by
// keyExpansion(). The ciphertext block is returned as an array of bytes.

    function encrypt(block, expandedKey) {
        var i;  
        if (!block || block.length*8 != blockSizeInBits)
            return; 
        if (!expandedKey)
            return;

        block = packBytes(block);
        addRoundKey(block, expandedKey);
        for (i=1; i<Nr; i++) 
            Round(block, expandedKey.slice(Nb*i, Nb*(i+1)));
        FinalRound(block, expandedKey.slice(Nb*Nr)); 
        return unpackBytes(block);
    }

// decrypt is the basic decryption function. It takes parameters
// block, an array of bytes representing a ciphertext block, and expandedKey,
// an array of words representing the expanded key previously returned by
// keyExpansion(). The decrypted block is returned as an array of bytes.

    function decrypt(block, expandedKey) {
        var i;
        if (!block || block.length*8 != blockSizeInBits)
            return;
        if (!expandedKey)
            return;

        block = packBytes(block);
        InverseFinalRound(block, expandedKey.slice(Nb*Nr)); 
        for (i = Nr - 1; i>0; i--) 
            InverseRound(block, expandedKey.slice(Nb*i, Nb*(i+1)));
        addRoundKey(block, expandedKey);
        return unpackBytes(block);
    }
    
// This function packs an array of bytes into the four row form defined by
// Rijndael. It assumes the length of the array of bytes is divisible by
// four. Bytes are filled in according to the Rijndael spec (starting with
// column 0, row 0 to 3). This function returns a 2d array.

    function packBytes(octets) {
        var state = new Array();
        if (!octets || octets.length % 4)
            return;

        state[0] = new Array();  state[1] = new Array(); 
        state[2] = new Array();  state[3] = new Array();
        for (var j=0; j<octets.length; j+= 4) {
            state[0][j/4] = octets[j];
            state[1][j/4] = octets[j+1];
            state[2][j/4] = octets[j+2];
            state[3][j/4] = octets[j+3];
        }
        return state;  
    }

// This function unpacks an array of bytes from the four row format preferred
// by Rijndael into a single 1d array of bytes. It assumes the input "packed"
// is a packed array. Bytes are filled in according to the Rijndael spec. 
// This function returns a 1d array of bytes.

    function unpackBytes(packed) {
        var result = new Array();
        for (var j=0; j<packed[0].length; j++) {
            result[result.length] = packed[0][j];
            result[result.length] = packed[1][j];
            result[result.length] = packed[2][j];
            result[result.length] = packed[3][j];
        }
        return result;
    }

    // This function takes a prospective plaintext (string or array of bytes)
    // and pads it with zero bytes if its length is not a multiple of the block 
    // size. If plaintext is a string, it is converted to an array of bytes
    // in the process. The type checking can be made much nicer using the 
    // instanceof operator, but this operator is not available until IE5.0 so I 
    // chose to use the heuristic below. 

    function formatPlaintext(plaintext) {
        var bpb = blockSizeInBits / 8;               // bytes per block
        var i;

        // if primitive string or String instance
        if (typeof plaintext == "string" || plaintext.indexOf) {
            plaintext = plaintext.split("");
            // Unicode issues here (ignoring high byte)
            for (i=0; i<plaintext.length; i++)
                plaintext[i] = plaintext[i].charCodeAt(0) & 0xFF;
        } 

        for (i = bpb - (plaintext.length % bpb); i > 0 && i < bpb; i--) 
            plaintext[plaintext.length] = 0;
        
        return plaintext;
    }

    // Returns an array containing "howMany" random bytes. 

    function getRandomBytes(howMany) {
        var i;
        var bytes = new Array();
        for (i=0; i<howMany; i++)
            bytes[i] = Math.round(Math.random()*255);
        return bytes;
    }

    var retobj = {
// This function takes an array of bytes (byteArray) and converts them
// to a hexadecimal string. Array element 0 is found at the beginning of
// the resulting string, high nibble first. Consecutive elements follow
// similarly, for example [16, 255] --> "10ff". The function returns a 
// string.

        byteArrayToHex: function (byteArray) {
            var result = "";
            if (!byteArray)
                return;
            for (var i=0; i<byteArray.length; i++)
                result += ((byteArray[i]<16) ? "0" : "") +
                byteArray[i].toString(16);

            return result;
        },

// This function converts a string containing hexadecimal digits to an 
// array of bytes. The resulting byte array is filled in the order the
// values occur in the string, for example "10FF" --> [16, 255]. This
// function returns an array. 

        hexToByteArray: function (hexString) {
            var byteArray = [];
            if (hexString.length % 2)             // must have even length
                return;
            if (hexString.indexOf("0x") == 0 || hexString.indexOf("0X") == 0)
                hexString = hexString.substring(2);
            for (var i = 0; i<hexString.length; i += 2) 
                byteArray[Math.floor(i/2)] =
                parseInt(hexString.slice(i, i+2), 16);
            return byteArray;
        },

        byteArrayToString: function (byteArray) {
            var result = "";
            for(var i = 0; i < byteArray.length; i++)
                result += String.fromCharCode(byteArray[i]);
            return result;
        },

        stringToByteArray: function (s) {
            var result = new Array(s.length);
            for(var i = 0; i < s.length; i++)
                result[i] = s.charCodeAt(i);
            return result;
        },

// rijndaelEncrypt(plaintext, key, mode)
// Encrypts the plaintext using the given key and in the given mode. 
// The parameter "plaintext" can either be a string or an array of bytes. 
// The parameter "key" must be an array of key bytes. If you have a hex 
// string representing the key, invoke hexToByteArray() on it to convert it 
// to an array of bytes. The third parameter "mode" is a string indicating
// the encryption mode to use, either "ECB" or "CBC". If the parameter is
// omitted, ECB is assumed.
// 
// An array of bytes representing the cihpertext is returned. To convert 
// this array to hex, invoke byteArrayToHex() on it. If you are using this 
// "for real" it is a good idea to change the function getRandomBytes() to 
// something that returns truly random bits.

        
        rijndaelEncrypt: function (plaintext, key, mode, bsize) {
            var expandedKey, i, aBlock;
            
            blockSizeInBits = bsize;

            var bpb = blockSizeInBits / 8;          // bytes per block
            var ct;                                 // ciphertext

            if (!plaintext || !key)
                return;
            if (key.length*8 != keySizeInBits)
                return; 
            if (mode == "CBC")
                ct = getRandomBytes(bpb);             // get IV
            else {
                mode = "ECB";
                ct = new Array();
            }

            // convert plaintext to byte array and pad with zeros if necessary. 
            //  plaintext = formatPlaintext(plaintext);

            expandedKey = keyExpansion(key);
            
            for (var block=0; block<plaintext.length / bpb; block++) {
                aBlock = plaintext.slice(block*bpb, (block+1)*bpb);
                if (mode == "CBC")
                    for (var i=0; i<bpb; i++) 
                        aBlock[i] ^= ct[block*bpb + i];
                ct = ct.concat(encrypt(aBlock, expandedKey));
            }

            return ct;
        },

// rijndaelDecrypt(ciphertext, key, mode)
// Decrypts the using the given key and mode. The parameter "ciphertext" 
// must be an array of bytes. The parameter "key" must be an array of key 
// bytes. If you have a hex string representing the ciphertext or key, 
// invoke hexToByteArray() on it to convert it to an array of bytes. The
// parameter "mode" is a string, either "CBC" or "ECB".
// 
// An array of bytes representing the plaintext is returned. To convert 
// this array to a hex string, invoke byteArrayToHex() on it. To convert it 
// to a string of characters, you can use byteArrayToString().

        rijndaelDecrypt: function (ciphertext, key, mode, bsize) {
            var expandedKey;

            blockSizeInBits = bsize;

            var bpb = blockSizeInBits / 8;          // bytes per block
            var pt = new Array();                   // plaintext array
            var aBlock;                             // a decrypted block
            var block;                              // current block number

            if (!ciphertext || !key || typeof ciphertext == "string")
                return;
            if (key.length*8 != keySizeInBits)
                return; 
            if (!mode)
                mode = "ECB";   // assume ECB if mode omitted
            expandedKey = keyExpansion(key);
            
            // work backwards to accomodate CBC mode 
            for (block=(ciphertext.length / bpb)-1; block>0; block--) {
                aBlock = 
                    decrypt(ciphertext.slice(block*bpb,(block+1)*bpb),
                            expandedKey);
                if (mode == "CBC") 
                    for (var i=0; i<bpb; i++) 
                        pt[(block-1)*bpb + i] = aBlock[i] ^
                    ciphertext[(block-1)*bpb + i];
                else 
                    pt = aBlock.concat(pt);
            }

            // do last block if ECB (skips the IV in CBC)
            if (mode == "ECB")
                pt = decrypt(ciphertext.slice(0, bpb), expandedKey).concat(pt);

            return pt;
        },

/**
*
*  Secure Hash Algorithm (SHA256)
*  http://www.webtoolkit.info/
*
*  Original code by Angel Marin, Paul Johnston.
*
**/

        SHA256: function (s) {
            
            var chrsz   = 8;
            var hexcase = 0;
            
            function safe_add (x, y) {
	        var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	        var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	        return (msw << 16) | (lsw & 0xFFFF);
            }
            
            function S (X, n) { return ( X >>> n ) | (X << (32 - n)); }
            function R (X, n) { return ( X >>> n ); }
            function Ch(x, y, z) { return ((x & y) ^ ((~x) & z)); }
            function Maj(x, y, z) { return ((x & y) ^ (x & z) ^ (y & z)); }
            function Sigma0256(x) { return (S(x, 2) ^ S(x, 13) ^ S(x, 22)); }
            function Sigma1256(x) { return (S(x, 6) ^ S(x, 11) ^ S(x, 25)); }
            function Gamma0256(x) { return (S(x, 7) ^ S(x, 18) ^ R(x, 3)); }
            function Gamma1256(x) { return (S(x, 17) ^ S(x, 19) ^ R(x, 10)); }
            
            function core_sha256 (m, l) {
	        var K = new Array(0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5, 0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5, 0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3, 0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174, 0xE49B69C1, 0xEFBE4786, 0xFC19DC6, 0x240CA1CC, 0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA, 0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7, 0xC6E00BF3, 0xD5A79147, 0x6CA6351, 0x14292967, 0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13, 0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85, 0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3, 0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070, 0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5, 0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3, 0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208, 0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2);
	        var HASH = new Array(0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19);
	        var W = new Array(64);
	        var a, b, c, d, e, f, g, h, i, j;
	        var T1, T2;
                
	        m[l >> 5] |= 0x80 << (24 - l % 32);
	        m[((l + 64 >> 9) << 4) + 15] = l;
                
	        for ( var i = 0; i<m.length; i+=16 ) {
	            a = HASH[0];
	            b = HASH[1];
	            c = HASH[2];
	            d = HASH[3];
	            e = HASH[4];
	            f = HASH[5];
	            g = HASH[6];
	            h = HASH[7];
                    
	            for ( var j = 0; j<64; j++) {
		        if (j < 16) W[j] = m[j + i];
		        else W[j] = safe_add(safe_add(safe_add(Gamma1256(W[j - 2]), W[j - 7]), Gamma0256(W[j - 15])), W[j - 16]);
                        
		        T1 = safe_add(safe_add(safe_add(safe_add(h, Sigma1256(e)), Ch(e, f, g)), K[j]), W[j]);
		        T2 = safe_add(Sigma0256(a), Maj(a, b, c));
                        
		        h = g;
		        g = f;
		        f = e;
		        e = safe_add(d, T1);
		        d = c;
		        c = b;
		        b = a;
		        a = safe_add(T1, T2);
	            }
                    
	            HASH[0] = safe_add(a, HASH[0]);
	            HASH[1] = safe_add(b, HASH[1]);
	            HASH[2] = safe_add(c, HASH[2]);
	            HASH[3] = safe_add(d, HASH[3]);
	            HASH[4] = safe_add(e, HASH[4]);
	            HASH[5] = safe_add(f, HASH[5]);
	            HASH[6] = safe_add(g, HASH[6]);
	            HASH[7] = safe_add(h, HASH[7]);
	        }
	        return HASH;
            }
            
            function str2binb (str) {
	        var bin = Array();
	        var mask = (1 << chrsz) - 1;
	        for(var i = 0; i < str.length * chrsz; i += chrsz) {
	            bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (24 - i%32);
	        }
	        return bin;
            }
            
            
            function binb2hex (binarray) {
	        var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
	        var str = "";
	        for(var i = 0; i < binarray.length * 4; i++) {
	            str += hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8+4)) & 0xF) +
		        hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8  )) & 0xF);
	        }
	        return str;
            }
            
            s = this.Utf8Encode(s);
            return binb2hex(core_sha256(str2binb(s), s.length * chrsz));
            
        },

        Utf8Encode: function(string) {
            string = string.replace(/\r\n/g,"\n");
            var utftext = "";
            
            for (var n = 0; n < string.length; n++) {
                
	        var c = string.charCodeAt(n);
                
	        if (c < 128) {
	            utftext += String.fromCharCode(c);
	        }
	        else if((c > 127) && (c < 2048)) {
	            utftext += String.fromCharCode((c >> 6) | 192);
	            utftext += String.fromCharCode((c & 63) | 128);
	        }
	        else {
	            utftext += String.fromCharCode((c >> 12) | 224);
	            utftext += String.fromCharCode(((c >> 6) & 63) | 128);
	            utftext += String.fromCharCode((c & 63) | 128);
	        }
                
            }
            
            return utftext;
        },

        Utf8Decode: function (utftext) {
            var string = "";
            var i = 0;
            var c = c1 = c2 = 0;
            
            while ( i < utftext.length ) {
                
	        c = utftext.charCodeAt(i);
                
	        if (c < 128) {
	            string += String.fromCharCode(c);
	            i++;
	        }
	        else if((c > 191) && (c < 224)) {
	            c2 = utftext.charCodeAt(i+1);
	            string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
	            i += 2;
	        }
	        else {
	            c2 = utftext.charCodeAt(i+1);
	            c3 = utftext.charCodeAt(i+2);
	            string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
	            i += 3;
	        }
                
            }
            
            return string;
        },

        _keyStr: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
        byteArrayToBase64: function (input) {
            var output = "";
            var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
            var i = 0;
            
            while (i < input.length) {
	        chr1 = input[i++];
	        chr2 = input[i++];
	        chr3 = input[i++];
                
	        enc1 = chr1 >> 2;
	        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
	        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
	        enc4 = chr3 & 63;
                
	        if (isNaN(chr2)) {
	            enc3 = enc4 = 64;
	        } else if (isNaN(chr3)) {
	            enc4 = 64;
	        }
                
	        output = output +
	            this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) +
	            this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);
                
            }
            
            return output;
        },


        byteArrayFromBase64: function (input) {
            var output = new Array();
            var chr1, chr2, chr3;
            var enc1, enc2, enc3, enc4;
            var i = 0;
            
            input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
            
            while (i < input.length) {
                
	        enc1 = this._keyStr.indexOf(input.charAt(i++));
	        enc2 = this._keyStr.indexOf(input.charAt(i++));
	        enc3 = this._keyStr.indexOf(input.charAt(i++));
	        enc4 = this._keyStr.indexOf(input.charAt(i++));
                
	        chr1 = (enc1 << 2) | (enc2 >> 4);
	        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
	        chr3 = ((enc3 & 3) << 6) | enc4;
                
	        output.push(chr1);
                
	        if (enc3 != 64) {
	            output.push(chr2);
	        }
	        if (enc4 != 64) {
	            output.push(chr3);
	        }
                
            }
            return output;
        },
        
        encryptString: function (message, password) {
            // a sequence to test if text were decrypted properly
            const _magic = "length@:";
            message = _magic.replace("length", message.length)+message;
            var key = this.hexToByteArray(this.SHA256(password));
            var plaintext = this.stringToByteArray(this.Utf8Encode(message));
            // encrypt with block size = 128 => AES
            var cyphertext = this.rijndaelEncrypt(plaintext, key, "CBC", 256);

            return this.byteArrayToBase64(cyphertext);
        },

        testDecryptedString: function(plaintext) {            
             // remove trailing zero symbols
             plaintext = plaintext.replace(/\0+$/, '');
             // check if message is decrypted properly
             if (/\0/.test(plaintext)) // there should be no zeroes
                return { success: false, result: '' };
             plaintext = this.Utf8Decode(plaintext);
             // check for magic sequence
             if (!/^(\d+)@:/.test(plaintext)) // no magic sequence 
                 return { success: false, result: '' };
             var length = parseInt(RegExp.$1);
             plaintext = plaintext.replace(/^(\d+)@:/, '');
             if (length != plaintext.length) // original length differs
                return { success: false, result: '' };        
            
            return { success: true, result: plaintext };
        },

        decryptString: function (cyphertextBase64, password) {
            var key = this.hexToByteArray(this.SHA256(password));
            var cyphertext = this.byteArrayFromBase64(cyphertextBase64);
            // Try first with block size = 128 (AES)
            var plaintext = this.rijndaelDecrypt(cyphertext, key, "CBC", 128);
            plaintext = this.byteArrayToString(plaintext);
            // test decrypted string
            var test = this.testDecryptedString(plaintext);
            if (!test.success) {                
                // try again with block size = 256 (legacy)
                plaintext = this.rijndaelDecrypt(cyphertext, key, "CBC", 256);
                plaintext = this.byteArrayToString(plaintext);
                test = this.testDecryptedString(plaintext);
                if (!test.success)
                    throw new RuntimeError("Decryption failed, bad password", 942);
            }
            return test.result;
        }

    };

    return retobj;
})();



======================================================================
FILE PATH: sandbox.js
======================================================================
/*
Copyright © 1992-2021 Progress Software Corporation and/or one of its subsidiaries or affiliates. All rights reserved.
*/

function EvalException(msg, num) {
    this.message = msg;
    if (typeof num != "undefined")
        this.errnum = num;
    this.name = "MacroError";
}

function MacroError(txt) {
    throw new EvalException(txt, -1340);
}

window.addEventListener("message", function(event) {
    if (!event.data.type || event.data.type != "eval_in_sandbox")
        return;
    var response = {
        type: "eval_in_sandbox_result",
        id: event.data.id
    };
    try {
        response.result = eval(event.data.expression);
    } catch(e) {
        console.error(e);
        response.error = {
            name: e.name,
            message: e.message,
            errnum: e.errnum
        };
    }
    
    event.source.postMessage(response, event.origin);
});



======================================================================
FILE PATH: SOAPClient.js
======================================================================
//*<JasobNoObfs>*/
/*
Copyright © 1992-2021 Progress Software Corporation and/or one of its subsidiaries or affiliates. All rights reserved.
*/
/*</JasobNoObfs>*/



var EXPORTED_SYMBOLS = ["SOAPClient"];

var SOAPClient = (function () {

    var WSDL_cache = new Object();

    var xmlns_schema="http://www.w3.org/2001/XMLSchema";
    var xmlns_wsdl="http://schemas.xmlsoap.org/wsdl/";

    
    function WSDLObject(url, xmlDoc) {
        this.url = url;
        this.doc = xmlDoc;
        // assume that all the namespace definitions are provided
        // in document element
        this.nsTable = new Object();
        this.reverseNsTable = new Object();
        var atts = this.doc.documentElement.attributes;
        for (var i = 0; i < atts.length; i++) {
            if (/^xmlns:(.*)$/.test(atts[i].name)) {
                this.nsTable[RegExp.$1] = atts[i].value;
                this.reverseNsTable[atts[i].value] = RegExp.$1;
            }
        }

        // query method names
        this.methods = new Object();
        
        var wsdl_prefix = this.reverseNsTable[xmlns_wsdl] ?
            this.reverseNsTable[xmlns_wsdl]+":" : "";
        var operations = this.doc.evaluate(
            "//"+wsdl_prefix+"portType/"+wsdl_prefix+"operation",
            this.doc, this.resolveNS.bind(this),
            // XPathResult.ORDERED_NODE_ITERATOR_TYPE
            5,
            null
        );

        var op = null;
        while (op = operations.iterateNext()) {
            if (!op.hasAttribute('name'))
                continue;       // unlikely but for peace of mind
            var op_name = op.getAttribute('name'); 
            this.methods[op_name] = {};
            // assume that the operation contains input/output specifiers which
            // is not always true as they can be specified in bindings 
            var input_tagName = wsdl_prefix+"input";
            var output_tagName = wsdl_prefix+"output";
            for(var i = 0; i < op.children.length; i++) {
                var tagName = op.children[i].tagName;
                if (tagName == input_tagName) {
                    if (op.children[i].hasAttribute('message')) {
                        var msg_name = op.children[i].getAttribute('message');
                        this.methods[op_name].input = {
                            typeObject: this.getType(msg_name)
                        };
                    }
                } else if (tagName == output_tagName) {
                    if (op.children[i].hasAttribute('message')) {
                        var msg_name = op.children[i].getAttribute('message');
                        this.methods[op_name].output = {
                            typeObject: this.getType(msg_name)
                        };
                    }
                }
            }
        }
        // __loginf("WSDLObject created, methods="+this.methods.toSource());
    };


    WSDLObject.prototype.getType = function(messageName) {
        var schema_prefix = this.reverseNsTable[xmlns_schema] ?
            this.reverseNsTable[xmlns_schema]+":" : "";
        var wsdl_prefix = this.reverseNsTable[xmlns_wsdl] ?
            this.reverseNsTable[xmlns_wsdl]+":" : "";
        
        // TODO: Here we assume that <wsdl:message>/<wsdl:part> refer to
        // Schema element containing type definition but the types can also
        // be defined using one or more <wsdl:part> elements with 'type'
        // attribute. We ignore such case.

        // NOTE: That part I don't really understand. operations in portType
        // refers to messages using prefixed names. In order to find
        // corresponding message I have to remove the prefix because
        // <wsdl:message> 'name' attributes do not use prefixes
        var msg_name = messageName.replace(/^\w+:/, "");
        var part_element = this.doc.evaluate(
            "//"+wsdl_prefix+"message[@name=\""+msg_name+"\"]/"+
                wsdl_prefix+"part",
            this.doc, this.resolveNS.bind(this),
            // XPathResult.FIRST_ORDERED_NODE_TYPE
            9, null
        ).singleNodeValue;
        
        if (!part_element) {
            throw new Error("No type definition for "+messageName);
        }
        // see above for that .replace
        var el_name = part_element.getAttribute("element").replace(/^\w+:/, "");
        var schema_element = this.doc.evaluate(
            "//"+schema_prefix+"element[@name=\""+el_name+"\"]",
            this.doc, this.resolveNS.bind(this),
            // XPathResult.FIRST_ORDERED_NODE_TYPE
            9, null
        ).singleNodeValue;

        if (!schema_element) {
            throw new Error("No type definition for "+messageName);
        }
        
        // NOTE: we use very simplistic approach here assuming that element is
        // of complex type consisting only of simple types and has no
        // additional complex members
        var typeObject = {};
        var nodes = this.doc.evaluate(
            "./"+schema_prefix+"complexType/"+schema_prefix+"sequence/"+
                schema_prefix+"element",
            schema_element, this.resolveNS.bind(this),
            /* XPathResult.ORDERED_NODE_ITERATOR_TYPE */ 5, null
        )
        var n = null;
        while(n = nodes.iterateNext()){
            // ignore Schema restriction and any other complexities here
            // just assume it is one of primitive types
            typeObject[n.getAttribute('name')] = {
                type: n.getAttribute('type').replace(
                    new RegExp("^"+schema_prefix), ""
                )
            };
        }

        return typeObject;
    };

    WSDLObject.prototype.resolveNS = function(ns) {
        var uri = this.nsTable[ns];
        if (!uri)
            throw Error("Unable to resolve namespace "+ns);
        return uri;
    };

    // assume that args is a plain JS object
    WSDLObject.prototype.argsToXML = function(method, args) {
        // __loginf("argsToXML, method="+method+", args="+args.toSource());
        var m = this.methods[method];
        if (!m || !m.input || !m.input.typeObject) {
            throw new Error("Input type not specified for method "+method);
        }
        var type_object = m.input.typeObject;
        var s = "";
        // TODO: from all the variety of XML Schema types
        // we use only three (which maybe too much of simplification)
        // __loginf("input type object="+type_object.toSource());
        var tns = this.doc.documentElement.getAttribute("targetNamespace");
        var prefix = this.reverseNsTable[tns] ?
            this.reverseNsTable[tns]+":" : "";
        
        for (var x in args) {
            if (type_object[x].type == "string" ) {
                s += "<"+prefix+x+">"+
                    args[x].replace(/&/g, "&amp;").
                    replace(/</g, "&lt;").
                    replace(/>/g, "&gt;")+
                    "</"+prefix+x+">";
            } else if (type_object[x].type == "boolean") {
                s += "<"+prefix+x+">"+
                    (args[x] ? "true" : "false")+
                    "</"+prefix+x+">";
            } else if (type_object[x].type == "integer") {
                s += "<"+prefix+x+">"+
                    args[x].toString()+
                    "</"+prefix+x+">";
            } else {
                throw new Error("Unsupported type "+type_object[x]);
            }
        }
        //__loginf("argsToXML result="+s);
        return s;
    };


    WSDLObject.prototype.makeSoapEnvelope = function(method, args) {
        var targetNamespace = this.doc.documentElement.
            getAttribute("targetNamespace");

        var env = "<?xml version=\"1.0\" encoding=\"utf-8\"?>"+
            "<soap-env:Envelope"+
            " xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\""+
            " xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\""+
            " xmlns:soap-env=\"http://www.w3.org/2003/05/soap-envelope\"";
        for (var x in this.nsTable) {
            env += " xmlns:"+x+"=\""+this.nsTable[x]+"\"";
        }
        env += ">";
        var prefix = this.reverseNsTable[targetNamespace] ?
            this.reverseNsTable[targetNamespace]+":" : "";
        var suffix = this.reverseNsTable[targetNamespace] ?
            ":"+this.reverseNsTable[targetNamespace] : "";
        env += "<soap-env:Body>"+
            "<"+prefix+method+" xmlns"+suffix+"=\""+targetNamespace+"\">"+
            this.argsToXML(method, args)+
            "</"+prefix+method+"></soap-env:Body>"+
            "</soap-env:Envelope>";

        return env;
    };
        
    WSDLObject.prototype.parseRetObject = function(method, xml) {
        var m = this.methods[method];
        if (!m || !m.output)
            return null;        // no response is assumed
        
        var type_object = m.output.typeObject;
        var rv = {};

        // var nsTable = new Object();
        // var reverseNsTable = new Object();
        // var atts = xml.documentElement.attributes;
        // for (var i = 0; i < atts.length; i++) {
        //     if (/^xmlns:(.*)$/.test(atts[i].name)) {
        //         nsTable[RegExp.$1] = atts[i].value;
        //         reverseNsTable[atts[i].value] = RegExp.$1;
        //     }
        // }
        
        // var resolveNS = function(prefix) {
        //     return nsTable[prefix];
        // };
        
        var tns = this.doc.documentElement.getAttribute("targetNamespace");
        for (var x in type_object) {
            var n = xml.getElementsByTagNameNS(tns, x);
            if (!n.length) {
                throw new Error("No value for parameter "+x+" in response");
            }
            var param = n[0];
            var value = param.textContent;
            if (type_object[x].type == "string") {
                rv[x] = value;
            } else if (type_object[x].type == "boolean") {
                rv[x] = /^\s*true\s*$/.test(value);
            } else if (type_object[x].type == "integer") {
                rv[x] = Number(value);
            } else {
                throw new Error("Data type "+type_object[x].type+
                                " is not supported");
            }
        }

        // __loginf("return value="+rv.toSource());
        return rv;
    };

    WSDLObject.prototype.invoke = function(method, args, callback) {
        // console.log("WSDLObject.invoke, method="+method+", args="+
        //             JSON.stringify(args));
        try {
            var m = this.methods[method];
            if (!m)
                throw Error("No "+method+" method found");

            var req = new XMLHttpRequest();
            req.open('POST', this.url, true);
            var self = this;
            req.onreadystatechange = function() {
                if (req.readyState == 4) {
                    if(req.status == 200) {
                        try {
                            // console.log("response="+req.responseText);
                            var rv = self.parseRetObject(
                                method, req.responseXML
                            );
                            callback(rv);
                        } catch(e) {
                            callback(null, e);
                        }
                    } else {
                        var err = new Error("Method "+method+" call failed"+
                                            ", status: "+req.statusText+
                                            " ("+req.status+")");
                        callback(null, err);
                    }
                }
            };
            var targetNamespace = this.doc.documentElement.
                getAttribute("targetNamespace");
            req.setRequestHeader("SOAPAction", targetNamespace+method);
            req.setRequestHeader("Content-Type", "text/xml; charset=utf-8");
            
            var env = this.makeSoapEnvelope(method, args);
            // __loginf("WSDLObject.invoke request="+env);
            req.send(env);
            
        } catch(e) {
            callback(null, e);
        }
    };
    

    function retrieveWSDL(ws_url, callback) {
        var url = ws_url;
        if (!/\?WSDL$/.test(url))
            url += "?WSDL";
        var req = new XMLHttpRequest();
        req.open('GET', url, true);
        req.onreadystatechange = function() {
            if (req.readyState == 4) {
                if(req.status == 200) {
                    try {
                        var wsdl = new WSDLObject(ws_url, req.responseXML);
                        WSDL_cache[ws_url] = wsdl;
                        callback(wsdl);
                    } catch(e) {
                        callback(null, e);
                    }
                } else {
                    var err = new Error("Request failed status: "+
                                        req.statusText+" ("+req.status+")");
                    callback(null, err);
                }
            }
        };

        req.send(null);
    }


    function SOAPClientImp(){}
    
    SOAPClientImp.prototype.invoke = function(ws_url, method, args, callback) {
        var wsdl = WSDL_cache[ws_url];
        if (!wsdl) {
            retrieveWSDL(ws_url, function(_wsdl, err) {
                if (!_wsdl && err) {
                    callback(null, err);
                } else {
                    _wsdl.invoke(method, args, callback);
                }
            });
        } else {
            wsdl.invoke(method, args, callback);
        }
    };

    return new SOAPClientImp();
}) ();



======================================================================
FILE PATH: treeView.js
======================================================================
/*
Copyright © 1992-2021 Progress Software Corporation and/or one of its subsidiaries or affiliates. All rights reserved.
*/

window.addEventListener("load", function (event) {
    TreeView.build();

    chrome.bookmarks.onChanged.addListener( function (id, x) {
        // TODO: listen to only iMacros descendants change
        window.location.reload();
    });
    chrome.bookmarks.onChildrenReordered.addListener( function (id, x) {
        // TODO: listen to only iMacros descendants change
        window.location.reload();
    });
    chrome.bookmarks.onCreated.addListener( function (id, x) {
        // TODO: listen to only iMacros descendants change
        window.location.reload();
    });
    chrome.bookmarks.onRemoved.addListener( function (id, x) {
        // TODO: listen to only iMacros descendants change
        window.location.reload();
    });

    window.top.onSelectionChanged(TreeView.selectedItem != null);
    document.body.oncontextmenu = function(e) {
        e.preventDefault()
    }

}, true);


window.addEventListener("iMacrosRunMacro", function(evt) {
    document.getElementById("imacros-bookmark-div").setAttribute("name", evt.detail.name);
    document.getElementById("imacros-macro-container").value = evt.detail.source;
});

function getiMacrosFolderId() {
    return new Promise((resolve, reject) => {
        chrome.bookmarks.getTree(tree => {
            // first find iMacros subtree or create if not found
            // (code duplicates one in addToBookmarks(),
            // TODO: do something with that)
            let iMacrosFolder = tree[0].children[0].children.find(
                child => child.title == "iMacros"
            )
            if (typeof iMacrosFolder == "undefined") {
                let bookmarksPanelId = tree[0].children[0].id
                chrome.bookmarks.create(
                    {parentId: bookmarksPanelId, title: "iMacros"},
                    folder => resolve(folder.id)
                )
            } else {
                resolve(iMacrosFolder.id)
            }
        })
    })
}

var TreeView = {
    // build tree from iMacros bookmarks folder
    build: function () {
        getiMacrosFolderId().then(id => TreeView.buildSubTree_jstree(id))
    },

    buildSubTree_jstree: function (id, parent) {
        if (!parent) {
            parent = document.getElementById("jstree");
        }

        chrome.bookmarks.getSubTree(id, function (treeNodes) {
            const createNode = function(text, id, type, hasChildren) {
                return {
                    'text': text,
                    'id': id,
                    'type': type,
                    'children': hasChildren
                }
            }

            const mapTree = function(nodes) {
                return nodes.filter(node => {
                    // skip non-macro bookmarks
                    if (node.url && !/iMacrosRunMacro/.test(node.url)) {
                        return false
                    } else {
                        return true
                    }
                }).map(node => {
                    let rv = {a_attr: {}}
                    if (node.url) {
                        rv.type = "macro"
                        rv.a_attr.bookmarklet = node.url
                    } else {
                        rv.type = "folder"
                        if (node.children)
                            rv.children = mapTree(node.children)
                    }
                    rv.title = node.title
                    rv.text = node.title
                    rv.id = node.id
                    rv.parentId = node.parentId
                    rv.a_attr.bookmark_id = node.id
                    node.type = rv.type
                    rv.a_attr.type = node.type
                    return rv
                })
            }

            let data = mapTree(treeNodes);
            if (!data[0].state) {
                data[0].state = {opened: true}
            }

            let onNewFolder = function () {
                var new_name = prompt("Enter new folder name", "New folder");
                var item = TreeView.selectedItem;
                var root_id;
                if (item.type == "folder") {
                    root_id = item.id;
                } else {
                    root_id = item.parentId;
                }

                chrome.bookmarks.getChildren(root_id, function (arr) {
                    // add ...(n) to the folder name if such name already present
                    var names = {}, count = 0, stop = false;
                    for (var i = 0; i < arr.length; i++) {
                        names[arr[i].title] = true;
                    }
                    while (!stop && count < arr.length + 1) {
                        if (names[new_name]) {
                            count++;
                            if (/\(\d+\)$/.test(new_name))
                                new_name = new_name.replace(/\(\d+\)$/,
                                                            "(" + count + ")");
                            else
                                new_name += " (" + count + ")";
                        } else {
                            stop = true;
                        }
                    }
                    chrome.bookmarks.create(
                        {
                            parentId: root_id,
                            title: new_name
                        },
                        function (folder) {
                            TreeView.buildSubTree(folder.id);
                        }
                    );
                });
            }

            let onRename = function () {
                var item = TreeView.selectedItem;
                if (!item) {
                    alert("Error: no item selected");
                    return;
                }
                var bookmark_id = item.id;
                var old_name = item.text;
                var new_name = prompt("Enter new name", old_name);
                if (!new_name)
                    return;
                if (item.type == "folder") {
                    chrome.bookmarks.update(bookmark_id, { title: new_name });
                } else if (item.type == "macro") {
                    chrome.bookmarks.get(bookmark_id, function (x) {
                        var url = x[0].url;
                        // change macro name in URL
                        try {
                            var m = url.match(/, n = \"([^\"]+)\";/);
                            url = url.replace(
                                    /, n = \"[^\"]+\";/,
                                ", n = \"" + encodeURIComponent(new_name) + "\";"
                            );
                        } catch (e) {
                            console.error(e);
                        }
                        chrome.bookmarks.update(
                            bookmark_id, { title: new_name, url: url }
                        );
                    });
                }
            }

            let onRemove = function () {
                var item = TreeView.selectedItem;
                if (!item) {
                    alert("Error: no item selected");
                    return;
                }
                var bookmark_id = item.id;
                if (!bookmark_id) {
                    alert("Can not delete " + item.type + " " + item.text);
                    return;
                }

                if (item.type == "macro") {
                    var yes = confirm("Are you sure you want to remove macro " +
                                      item.text +
                                      " ?");
                    if (yes) {
                        chrome.bookmarks.remove(bookmark_id, function () {
                            TreeView.selectedItem = null;
                        });
                    }
                } else if (item.type == "folder") {
                    var yes = confirm("Are you sure you want to remove folder " +
                                      item.text +
                                      " and all its contents?");
                    if (yes)
                        chrome.bookmarks.removeTree(bookmark_id, function () {
                            TreeView.selectedItem = null;
                        });
                }
            }

            const customMenu = function(node) {
                TreeView.selectedItem = node.original;

                var items = {
                    'Edit': {
                        'label': 'Edit',
                        'action': function () { window.top.edit(); }
                    },
                    'Convert': {
                        'label': 'Convert',
                        'action': function () { window.top.convert(); }
                    },
                    'New Folder': {
                        'label': 'New Folder',
                        'action': onNewFolder
                    },
                    'Rename': {
                        'label': 'Rename',
                        'action': onRename
                    },
                    'Remove': {
                        'label': 'Remove',
                        'action': onRemove
                    },
                    'Refresh Tree': {
                        'label': 'Refresh Tree',
                        'action': function () { window.location.reload(); }
                    }
                }

                if (node.type === 'folder') {
                    delete items.Edit;
                    delete items.Convert;
                }

                return items;
            };

            jQuery('#jstree_container').jstree({
                core: {
                    "check_callback": function (operation, node, parent, position, more) {
                        if (more.dnd && operation === "move_node") {
                            if(parent.id === "#") {
                                return false; // prevent moving a child above or below the root
                            }
                        }

                        return true; // allow everything else
                    },

                    data: data
                },
                types: {
                    "folder": {

                    },
                    "macro": {
                         icon: 'X'//'/skin/imglog.png'
                    }
                },
                contextmenu: {
                    items: customMenu
                },
                plugins: ['state', 'dnd', 'types', 'contextmenu', 'wholerow']
            });


            const getChildren = function(bookmarkId) {
                return new Promise((resolve, reject) => {
                    chrome.bookmarks.getChildren(bookmarkId, resolve)
                })
            }

            const namePrecedes = function(name, what) {
                if (name[0] == "#" && what[0] == "#")
                    return name.substring(1) < what.substring(1)
                else
                    return name < what
            }

            const findInsertionIndex = function(srcNode, subTree) {
                let place = subTree.find(node => {
                    if (srcNode.url && node.url) {
                        return namePrecedes(srcNode.title, node.title)
                    } else if (!srcNode.url && node.url) {
                        return true
                    } else if (srcNode.url && !node.url) {
                        return false
                    } else {
                        return srcNode.title < node.title
                    }
                })
                return place ? place.index : subTree.length
            }

            jQuery(document).on('dnd_stop.vakata', function (e, data) {
                let sourceId = data.element.getAttribute("bookmark_id")
                let targetId = data.event.target.getAttribute("bookmark_id")
                chrome.bookmarks.get([sourceId, targetId], ([src, tgt]) => {
                    let parentId = tgt.url? tgt.parentId : tgt.id
                    getChildren(parentId).then(children => {
                        let index = findInsertionIndex(src, children)
                        console.log("insertion index", index)
                        chrome.bookmarks.move(
                            src.id,
                            { parentId, index},
                            function () { window.location.reload()}
                        )
                    })
                })
            });

            jQuery('#jstree_container').on('select_node.jstree', function (e, data) {
                var element = e.target;
                TreeView.selectedItem = element;
                if (data.node.type == 'macro') {
                    TreeView.selectedItem.type = "macro";
                    var div = document.getElementById("imacros-bookmark-div");
                    if (div.hasAttribute("file_id"))
                        div.removeAttribute("file_id");
                    div.setAttribute("bookmark_id", data.node.id);
                    div.setAttribute("name", data.node.text);
                    var bookmarklet = data.node.a_attr.bookmarklet;
                    var m = /var e_m64 = "([^"]+)"/.exec(bookmarklet);
                    if (!m) {
                        console.error("Can not parse bookmarklet " + data.node.text);
                        return;
                    }
                    document.getElementById("imacros-macro-container").value = decodeURIComponent(atob(m[1]));
                    window.top.onSelectionChanged(true);

                    e.preventDefault();

                }
                //folder
                else {
                    TreeView.selectedItem.type = "folder";
                    window.top.onSelectionChanged(false);
                }
            });

            jQuery('#jstree_container').on('dblclick.jstree', function (e, data) {

                var target_node = jQuery('#jstree_container').jstree(true).get_node(e.target.getAttribute("bookmark_id"));

                if (target_node.type == 'macro') {
                    setTimeout(function () { window.top.play(); }, 200);
                }
            });
        });
    }
};



======================================================================
FILE PATH: utils.js
======================================================================
/*
Copyright © 1992-2021 Progress Software Corporation and/or one of its subsidiaries or affiliates. All rights reserved.
*/

// Some utility functions
(function () {
    var timers = new Array();
    var onMessage = function(event) {
        if (event.source != window || 
            !event.data.type || 
            event.data.type != "asyncRun")
            return;
        
        var f = timers.shift();
        if (f) f();
    };

    window.asyncRun = function(f) {
        timers.push(f);
        window.postMessage({type: "asyncRun"}, "*");
    };

    window.addEventListener("message", onMessage);
}) ();


// Open URL in a new window
function link(url) {
    window.open(url);
}


function __is_windows() {
    return /^win(32)?/i.test(navigator.platform);
}

function __psep() {
    return __is_windows() ? "\\" : "/";
}

function __is_full_path(path) {
    if (__is_windows()) {
        return /^[a-z]:/i.test(path);
    } else {
        return /^\//.test(path);
    }
}

var imns = {

    // Returns number if and only if num is an integer or
    // a string representation of an integer,
    // otherwise returns NaN
    s2i: function(num) {
        var s = num.toString();
        s = this.trim(s);
        if (!s.length)
            return Number.NaN;
        var n = parseInt(s);
        if (n.toString().length != s.length)
            return Number.NaN;
        return n;
    },

    // escape \n, \t, etc. chars in line
    escapeLine: function(line) {
        var values_to_escape = {
                "\\u005C": "\\\\",
                "\\u0000": "\\0",
                "\\u0008": "\\b",
                "\\u0009": "\\t",
                "\\u000A": "\\n",
                "\\u000B": "\\v",
                "\\u000C": "\\f",
                "\\u000D": "\\r",
                "\\u0022": "\\\"",
                "\\u0027": "\\'"};

        // var values_to_escape = {
        //         "\\": "\\\\",
        //         "\0": "\\0",
        //         "\b": "\\b",
        //         "\t": "\\t",
        //         "\n": "\\n",
        //         "\v": "\\v",
        //         "\f": "\\f",
        //         "\r": "\\r",
        //         "\"": "\\\"",
        //         "'": "\\'"};
        
        for (var x in values_to_escape) {
            line = line.replace(new RegExp(x, "g"), values_to_escape[x]);
        }

        return line;
    },

    // replace all white-space symbols by <..>
    wrap: function (line) {
        const line_re = new RegExp("^\"((?:\n|.)*)\"$");

        var m = null;
        if (m = line.match(line_re)) { // it is a quoted string
            line = this.escapeLine(m[1]);
            
            // add quotes
            line = "\""+line+"\"";
        } else {
            line = line.replace(/\t/g, "<SP>");
            line = line.replace(/\n/g, "<BR>");
            line = line.replace(/\r/g, "<LF>");
            line = line.replace(/\s/g, "<SP>");
        }

        return line;
    },

    // Unwraps a line 
    // If the line is a quoted string then the following escape sequences
    // are translated:
    // \0 The NUL character (\u0000).
    // \b Backspace (\u0008).
    // \t Horizontal tab (\u0009).
    // \n Newline (\u000A).
    // \v Vertical tab (\u000B).
    // \f Form feed (\u000C).
    // \r Carriage return (\u000D).
    // \" Double quote (\u0022).
    // \' Apostrophe or single quote (\u0027).
    // \\ Backslash (\u005C).
    // \xXX The Latin-1 character specified by the two hexadecimal digits XX.
    // \uXXXX The Unicode character specified by four hexadecimal digits XXXX.
    // Otherwise <BR>, <LF>, <SP> are replaced by \n, \r, \x31 resp.

    unwrap: function(line) {
        const line_re = new RegExp("^\"((?:\n|.)*)\"$");
        var m = null;
        
        var handleSequence = function(s) {
            if (s == "\\\\") {
                return "\u005C";
            } else if (s == "\\0") {
                return "\u0000";
            } else if (s == "\\b") {
                return "\u0008";
            } else if (s == "\\t") {
                return "\u0009";
            } else if (s == "\\n") {
                return "\u000A";
            } else if (s == "\\v") {
                return "\u000B";
            } else if (s == "\\f") {
                return "\u000C";
            } else if (s == "\\r") {
                return "\u000D";
            } else if (s == "\\\"") {
                return "\u0022";
            } else if (s == "\\\'") {
                return "\u0027"
            } else {
                // function to replace \x|u sequence
                var replaceChar = function (match_str, char_code) {
                    return String.fromCharCode(parseInt("0x"+char_code));
                };
                if (/^\\x/.test(s))// replace \xXX by its value
                    return s.replace(/\\x([\da-fA-F]{2})/g, replaceChar);
                else if (/^\\u/.test(s)) // replace \uXXXX by its value
                    return s.replace(/\\u([\da-fA-F]{4})/g, replaceChar);
            }
        };

        var esc_re = new RegExp("\\\\(?:[0btnvfr\"\'\\\\]|x[\da-fA-F]{2}|u[\da-fA-F]{4})", "g");
        
        if (m = line.match(line_re)) {
            line = m[1];        // 'unquote' the line
            // replace escape sequences by their value
            line = line.replace(esc_re, handleSequence);
        } else {
            line = line.replace(/<br>/gi, '\n');
            line = line.replace(/<lf>/gi, '\r');
            line = line.replace(/<sp>/gi, ' ');
        }

        return line;
    },
    
    formatDate: function(str, date) {
        var  prependDate = function(str, num) {
            str = str.toString(); 
            var x = imns.s2i(str), y = imns.s2i(num);
            if (isNaN(x) || isNaN(y))
                return;
            while (str.length < num)
                str = '0'+str;
            return str;
        };
        var now = date ? date : new Date();
        str = str.replace(/yyyy/g, prependDate(now.getFullYear(), 4));
        str = str.replace(/yy/g, now.getFullYear().toString().substr(-2));
        str = str.replace(/mm/g, prependDate(now.getMonth()+1, 2));
        str = str.replace(/dd/g, prependDate(now.getDate(), 2));
        str = str.replace(/hh/g, prependDate(now.getHours(), 2));
        str = str.replace(/nn/g, prependDate(now.getMinutes(), 2));
        str = str.replace(/ss/g, prependDate(now.getSeconds(), 2));

        return str;
    },
    
    // escape chars which are of special meaning in regexp
    escapeREChars: function(str) {
        var chars = "^$.+?=!:|\\/()[]{}", res = "", i, j;

        for ( i = 0; i < str.length; i++) {
            for (j = 0; j < chars.length; j++) {
                if (str[i] == chars[j]) {
                    res += "\\";
                    break;
                }
            }
            res += str[i];
        }

        return res;
    },

    escapeTextContent: function(str) {
        // 1. remove all leading/trailing white spaces
        str = this.trim(str);
        // 2. remove all linebreaks
        str = str.replace(/[\r\n]+/g, "");
        // 3. all consequent white spaces inside text are replaced by one
        str = str.replace(/\s+/g, " ");

        return str;
    },


    trim: function(s) {
        return s.replace(/^\s+/, "").replace(/\s+$/, "");
    },

    Clipboard: {
        _check_area: function(str) {
            var x;
            if (!(x = document.getElementById("clipboard-area"))) {
                x = document.createElement("textarea");
                x.id = "clipboard-area";
                x.setAttribute("contentEditable", "true");
                document.body.appendChild(x);    
            }
            return x;
        },

        putString: function(str) {
            var x = this._check_area();
            x.value = str;
            x.focus();
            x.select();
            document.execCommand("Copy");
        },

        getString: function() {
            var x = this._check_area();
            x.focus();
            document.execCommand("Paste");
            
            return x.value;
        }
    }
};




// App exceptions

// Classes for reporting syntax and runtime errors

// Returns error with message=msg and optional position of
// bad parameter set by num
function BadParameter(msg, num) {
    this.message = typeof(num) != "undefined" ? "expected "+msg+
        " as parameter "+num : msg;
    this.name = "BadParameter";
    this.errnum = 711;
}

BadParameter.prototype = Error.prototype;


function UnsupportedCommand(msg) {
    this.message = "command "+msg+" is not supported in the current version";
    this.name = "UnsupportedCommand";
    this.errnum = 712;
}

UnsupportedCommand.prototype = Error.prototype;

// Returns error with message=msg, optional error number num
// sets mplayer.errorCode
function RuntimeError(msg, num) {
    this.message = msg;
    if (typeof num != "undefined")
        this.errnum = num;
    this.name = "RuntimeError";
}

RuntimeError.prototype = Error.prototype;

function FreewareLimit(msg) {
    this.message = "Freeware version limit exceeded: "+msg;
    this.errnum = 800;
    this.name = "FreewareLimit";
}

FreewareLimit.prototype = Error.prototype;

SyntaxError.prototype.
    __defineGetter__("errnum", function() { return 710; });


function normalize_error(e) {
    return {name: e.name, message: e.message, errnum: e.errnum};
}



// preference storage
var Storage = {
    isSet: function(key) {
        return typeof(localStorage[key]) != "undefined";
    },

    setBool: function(key, value) {
        localStorage[key] = Boolean(value);
    },

    getBool: function(key) {
        var value = localStorage[key];
        return value ? value.toString() != "false" : false;
    },

    setChar: function(key, value) {
        localStorage[key] = String(value);
    },

    getChar: function(key) {
        var value = localStorage[key];
        return value ? value.toString() : "";
    },

    setNumber: function(key, value) {
        var val = Number(value);
        if (!isNaN(val))
            localStorage[key] = val;
    },

    getNumber: function(key) {
        return localStorage[key];
    },

    setObject: function(key, value) {
        var s = JSON.stringify(value);
        localStorage[key] = s;
    },

    getObject: function(key) {
        var s = localStorage[key];
        if (typeof s != "string")
            return null;
        try {
            return JSON.parse(s);
        } catch(e) {
            return null;
        }
    }
};


// resize window to fit its content
function resizeToContent(win, container) {
    var rect = container.getBoundingClientRect();
    var width = (win.outerWidth-win.innerWidth)+rect.width;
    var height = (win.outerHeight-win.innerHeight)+rect.height;
    // that +30 is for window's titlebar which seems missing when
    // outerWidth-innerWidth is calculated
    win.resizeTo(width, height+30);
}


// open a dialog and return promise which resolves on a message from the
// known popup window
var dialogUtils = (function () {
    "use strict";

    let dialogResolvers = new Map()
    let dialogArgs = new Map()

    return {
        setArgs(win, args) {
			dialogArgs.set(win, args);
        },

        getArgs(win) {
            if (!dialogArgs.has(win))
                throw new Error("dialogUtils error: bad dialog win reference")
            return dialogArgs.get(win);
        },
		
        setDialogResult(win_id, response) {
            if (!dialogResolvers.has(win_id))
                throw new Error("dialogUtils error: bad dialog id")
            dialogResolvers.get(win_id)(response)
            dialogResolvers.delete(win_id)
            dialogArgs.delete(win_id)
        },

        getDialogArgs(win_id) {
            if (!dialogArgs.has(win_id))
                throw new Error("dialogUtils error: bad dialog id")
            return dialogArgs.get(win_id)
        },

        openDialog(url, name, args = {}, pos) {
            return new Promise(function(resolve, reject) {
                chrome.windows.create({
                    url: url,
                    type: "popup",
                    width: pos && pos.width || undefined,
                    height: pos && pos.height || undefined,
                    left: pos && pos.left || undefined,
                    top: pos && pos.top || undefined
                }, function(w) {
                    dialogArgs.set(w.id, args)
                    dialogResolvers.set(w.id, resolve)
                })
            })
        }
    }
})();

function getRedirectURL(id_or_kw) {
    const version = chrome.runtime.getManifest().version
    const prefix = `http://rd.imacros.net/redirect.aspx?type=CR&version=${version}`
    if (typeof id_or_kw == "number") {
        return `${prefix}&helpid=${id_or_kw}`
    } else if (typeof id_or_kw == "string") {
        return `${prefix}&helpid=102&kw=${id_or_kw}`
    }
}

function getRedirFromString(idString) {
	const version = chrome.runtime.getManifest().version
    const prefix = `http://rd.imacros.net/redirect.aspx?type=CR&version=${version}`
	return `${prefix}&helpid=${idString}`
}

// returns true if fileName's extension is of a macro file (e.g. .iim or .IIM)
function isMacroFile(fileName) {
    return /\.iim$/i.test(fileName);
}



======================================================================
FILE PATH: variable-manager.js
======================================================================
/*
 * VariableManager - Manages global and local variables for macro execution
 * 
 * This class separates global variables (shared across macros) from local variables
 * (specific to each macro execution context).
 */

function VariableManager() {
    // Global variables (shared across all macros)
    this.globalVars = new Map();

    // Local variables (specific to each macro execution)
    this.localContext = {};

    // List of local variable names
    this.LOCAL_VARS = [
        'LINE', 'LOOP', 'LOOP1', 'LOOP2', 'LOOP3',
        'LOOP4', 'LOOP5', 'LOOP6', 'LOOP7', 'LOOP8',
        'LOOP9', 'LOOP10', 'ERRORIGNORE', 'REPLAYSPEED',
        'TABNUMBER'
    ];

    // Initialize standard variables
    this.initializeStandardVars();
}

/**
 * Initialize standard global and local variables
 */
VariableManager.prototype.initializeStandardVars = function () {
    // Initialize standard global variables (VAR0-VAR9)
    for (let i = 0; i <= 9; i++) {
        this.globalVars.set('VAR' + i, '');
    }

    // Initialize other standard global variables
    this.globalVars.set('EXTRACT', '');
    this.globalVars.set('CLIPBOARD', '');
    this.globalVars.set('TIMEOUT_PAGE', 60);
    this.globalVars.set('TIMEOUT_STEP', 10);
    this.globalVars.set('DATASOURCE', '');
    this.globalVars.set('DATASOURCE_LINE', 0);
    this.globalVars.set('DATASOURCE_COLUMNS', 0);

    // Initialize local variables
    this.localContext.LINE = 1;
    this.localContext.LOOP = 0;
    for (let i = 1; i <= 10; i++) {
        this.localContext['LOOP' + i] = 0;
    }
    this.localContext.TABNUMBER = 1;
    this.localContext.ERRORIGNORE = false;
    this.localContext.REPLAYSPEED = 'FAST';
};

/**
 * Get a variable value
 * @param {string} name - Variable name (with or without '!' prefix)
 * @returns {*} Variable value or empty string if not found
 */
VariableManager.prototype.getVar = function (name) {
    // Remove '!' prefix if present
    name = name.replace(/^!/, '');

    // Check if it's a local variable
    if (this.LOCAL_VARS.includes(name)) {
        return this.localContext[name] !== undefined ?
            this.localContext[name] : '';
    }

    // Return global variable
    return this.globalVars.has(name) ?
        this.globalVars.get(name) : '';
};

/**
 * Set a variable value
 * @param {string} name - Variable name (with or without '!' prefix)
 * @param {*} value - Variable value
 */
VariableManager.prototype.setVar = function (name, value) {
    // Remove '!' prefix if present
    name = name.replace(/^!/, '');

    // Check if it's a local variable
    if (this.LOCAL_VARS.includes(name)) {
        this.localContext[name] = value;
    } else {
        // Set as global variable
        this.globalVars.set(name, value);
    }
};

/**
 * Create a snapshot of the local context
 * @returns {Object} Deep copy of local context
 */
VariableManager.prototype.snapshotLocalContext = function () {
    return JSON.parse(JSON.stringify(this.localContext));
};

/**
 * Restore local context from a snapshot
 * @param {Object} snapshot - Snapshot to restore
 */
VariableManager.prototype.restoreLocalContext = function (snapshot) {
    this.localContext = JSON.parse(JSON.stringify(snapshot));
};

/**
 * Get all variables (both global and local) as a plain object
 * Used for EVAL command
 * @returns {Object} All variables
 */
VariableManager.prototype.getAllVars = function () {
    const allVars = {};

    // Copy global variables
    for (let [key, value] of this.globalVars) {
        allVars[key] = value;
    }

    // Copy local variables
    for (let key in this.localContext) {
        allVars[key] = this.localContext[key];
    }

    return allVars;
};

/**
 * Reset local context to initial state
 * Used when starting a new macro execution
 */
VariableManager.prototype.resetLocalContext = function () {
    this.localContext = {
        LINE: 1,
        LOOP: 0,
        LOOP1: 0, LOOP2: 0, LOOP3: 0, LOOP4: 0, LOOP5: 0,
        LOOP6: 0, LOOP7: 0, LOOP8: 0, LOOP9: 0, LOOP10: 0,
        TABNUMBER: this.localContext.TABNUMBER || 1,
        ERRORIGNORE: false,
        REPLAYSPEED: this.localContext.REPLAYSPEED || 'FAST'
    };
};

/**
 * Clear all global variables (reset to initial state)
 */
VariableManager.prototype.clearGlobalVars = function () {
    this.globalVars.clear();
    this.initializeStandardVars();
};

/**
 * Check if a variable exists
 * @param {string} name - Variable name
 * @returns {boolean} True if variable exists
 */
VariableManager.prototype.hasVar = function (name) {
    name = name.replace(/^!/, '');
    return this.LOCAL_VARS.includes(name) || this.globalVars.has(name);
};

/**
 * Delete a global variable
 * @param {string} name - Variable name
 */
VariableManager.prototype.deleteVar = function (name) {
    name = name.replace(/^!/, '');
    if (!this.LOCAL_VARS.includes(name)) {
        this.globalVars.delete(name);
    }
};



======================================================================
FILE PATH: VirtualFileService.js
======================================================================
/*
Copyright © 1992-2021 Progress Software Corporation and/or one of its subsidiaries or affiliates. All rights reserved.
*/

(function (global) {
    'use strict';

    const DEFAULT_DIRECTORIES = [
        '/VirtualMacros/',
        '/VirtualMacros/Datasources/',
        '/VirtualMacros/Downloads/',
        '/VirtualMacros/Logs/'
    ];

    const DEFAULT_CONFIG = {
        defsavepath: '/VirtualMacros/',
        defdatapath: '/VirtualMacros/Datasources/',
        defdownpath: '/VirtualMacros/Downloads/',
        deflogpath: '/VirtualMacros/Logs/'
    };

    const STORAGE_KEYS = {
        tree: 'vfs_tree',
        config: 'vfs_config',
        stats: 'vfs_stats',
        deleted: 'vfs_recently_deleted'
    };

    const LEGACY_STORAGE_KEYS = {
        tree: 'vfs_data',
        config: 'vfs_config',
        stats: 'vfs_stats'
    };

    const CHUNK_PREFIX = 'vfs_chunk_';
    const MAX_STORAGE_SIZE = 8 * 1024 * 1024; // 8MB soft limit
    const MAX_FILE_SIZE = 2 * 1024 * 1024; // 2MB per file
    const CHUNK_SIZE = 1024 * 1024; // 1MB chunks
    const RECENTLY_DELETED_TTL = 24 * 60 * 60 * 1000;

    function now() {
        return Date.now();
    }

    function globToRegex(pattern) {
        const escaped = pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        return new RegExp(escaped.replace(/\\\*/g, '.*'));
    }

    class VirtualFileService {
        constructor(options = {}) {
            this.chunkSize = options.chunkSize || CHUNK_SIZE;
            this.storageKeys = Object.assign({}, STORAGE_KEYS, options.storageKeys || {});
            this.maxStorageSize = options.maxStorageSize || MAX_STORAGE_SIZE;
            this.maxFileSize = options.maxFileSize || MAX_FILE_SIZE;
            this.tree = {};
            this.config = Object.assign({}, DEFAULT_CONFIG);
            this.stats = {
                totalSize: 0,
                lastAccess: {},
                lastChange: 0
            };
            this.recentlyDeleted = [];
            this.initialized = false;
            this.initializingPromise = null;
            this.listeners = new Map();
        }

        isReady() {
            return this.initialized;
        }

        async init() {
            if (this.initialized) {
                return;
            }
            if (this.initializingPromise) {
                return this.initializingPromise;
            }

            this.initializingPromise = this._loadFromStorage()
                .catch((err) => {
                    console.error('VFS initialization failed, rebuilding structure', err);
                    return this._initDefaultStructure();
                })
                .then(() => {
                    this.initialized = true;
                    this._purgeDeleted();
                })
                .finally(() => {
                    this.initializingPromise = null;
                });

            return this.initializingPromise;
        }

        async _loadFromStorage() {
            const keys = [
                this.storageKeys.tree,
                this.storageKeys.config,
                this.storageKeys.stats,
                this.storageKeys.deleted,
                LEGACY_STORAGE_KEYS.tree,
                LEGACY_STORAGE_KEYS.config,
                LEGACY_STORAGE_KEYS.stats
            ];
            const result = await this._storageGet(keys);
            const legacyTree = result[LEGACY_STORAGE_KEYS.tree];
            const legacyConfig = result[LEGACY_STORAGE_KEYS.config];
            const legacyStats = result[LEGACY_STORAGE_KEYS.stats];

            this.tree = result[this.storageKeys.tree] || {};
            this.config = Object.assign({}, DEFAULT_CONFIG, result[this.storageKeys.config] || {});
            this.stats = Object.assign({ totalSize: 0, lastAccess: {}, lastChange: 0 }, result[this.storageKeys.stats] || {});
            this.recentlyDeleted = Array.isArray(result[this.storageKeys.deleted]) ? result[this.storageKeys.deleted] : [];

            if (Object.keys(this.tree).length === 0 && legacyTree && Object.keys(legacyTree).length) {
                await this._migrateLegacyData({
                    tree: legacyTree,
                    config: legacyConfig,
                    stats: legacyStats
                });
                await this._storageRemove([LEGACY_STORAGE_KEYS.tree]);
                return;
            }

            if (Object.keys(this.tree).length === 0) {
                await this._initDefaultStructure();
            } else {
                this._ensureRootEntry();
            }
        }

        _ensureRootEntry() {
            const existing = this.tree['/'];
            if (!existing || existing.type !== 'dir') {
                this.tree['/'] = {
                    type: 'dir',
                    modified: existing && existing.modified ? existing.modified : now(),
                    children: {}
                };
            }
        }

        async _initDefaultStructure() {
            this.tree = {};
            this._ensureRootEntry();
            DEFAULT_DIRECTORIES.forEach((dir) => {
                this.tree[this._normalizePath(dir)] = { type: 'dir', modified: now(), children: {} };
            });
            this.config = Object.assign({}, DEFAULT_CONFIG);
            this.stats = { totalSize: 0, lastAccess: {}, lastChange: now() };
            this.recentlyDeleted = [];
            await this._persist();
        }

        async _migrateLegacyData(legacyData = {}) {
            console.info('VirtualFileService migrating legacy storage data');
            const legacyTree = legacyData.tree || {};
            const paths = Object.keys(legacyTree);
            this.tree = {};
            for (const path of paths) {
                const entry = legacyTree[path];
                if (!entry || !entry.type) {
                    continue;
                }
                const normalizedPath = this._normalizePath(path);
                if (entry.type === 'dir') {
                    this.tree[normalizedPath] = { type: 'dir', modified: entry.modified || now(), children: {} };
                } else if (entry.type === 'file') {
                    const content = typeof entry.content === 'string' ? entry.content : '';
                    const chunks = await this._writeChunks(content, null);
                    const size = typeof entry.size === 'number' ? entry.size : this._calculateSize(content);
                    this.tree[normalizedPath] = {
                        type: 'file',
                        size,
                        chunks,
                        modified: entry.modified || now()
                    };
                }
            }
            this._ensureRootEntry();
            for (const dir of DEFAULT_DIRECTORIES) {
                const normalizedDir = this._normalizePath(dir);
                const existing = this.tree[normalizedDir];
                if (!existing) {
                    // Create missing default directory
                    this.tree[normalizedDir] = { type: 'dir', modified: now(), children: {} };
                } else if (existing.type !== 'dir') {
                    // Edge case: file exists at default directory path - replace with directory
                    // Clean up orphaned chunks before replacing file entry with directory
                    if (existing.chunks && existing.chunks.length > 0) {
                        await this._removeChunks(existing.chunks);
                    }
                    console.warn(`VirtualFileService: Replacing file entry with directory at ${normalizedDir}`);
                    this.tree[normalizedDir] = { type: 'dir', modified: now(), children: {} };
                }
            }
            const legacyStats = legacyData.stats || {};
            const legacyAccess = legacyStats.lastAccess || {};
            const totalSize = Object.values(this.tree).reduce((sum, entry) => {
                if (entry.type === 'file') {
                    return sum + (entry.size || 0);
                }
                return sum;
            }, 0);
            this.config = Object.assign({}, DEFAULT_CONFIG, legacyData.config || {});
            this.stats = {
                totalSize,
                lastAccess: Object.assign({}, legacyAccess),
                lastChange: now()
            };
            this.recentlyDeleted = [];
            await this._persist();
        }

        async _persist() {
            await this._storageSet({
                [this.storageKeys.tree]: this.tree,
                [this.storageKeys.config]: this.config,
                [this.storageKeys.stats]: this.stats,
                [this.storageKeys.deleted]: this.recentlyDeleted
            });
        }

        _storageGet(keys) {
            const uniqueKeys = Array.from(new Set((keys || []).filter(Boolean)));
            return new Promise((resolve, reject) => {
                if (typeof chrome !== 'undefined' && chrome.storage && chrome.storage.local) {
                    chrome.storage.local.get(uniqueKeys, (result) => {
                        if (chrome.runtime.lastError) {
                            reject(new Error(chrome.runtime.lastError.message));
                            return;
                        }
                        resolve(result || {});
                    });
                } else {
                    const result = {};
                    let lastError = null;
                    uniqueKeys.forEach((key) => {
                        try {
                            const raw = localStorage.getItem(key);
                            result[key] = raw ? JSON.parse(raw) : undefined;
                        } catch (err) {
                            console.warn('VFS localStorage read failed for key', key, err);
                            lastError = lastError || err;
                        }
                    });
                    if (lastError) {
                        reject(lastError);
                    } else {
                        resolve(result);
                    }
                }
            });
        }

        _storageSet(items) {
            return new Promise((resolve, reject) => {
                if (typeof chrome !== 'undefined' && chrome.storage && chrome.storage.local) {
                    chrome.storage.local.set(items, () => {
                        if (chrome.runtime.lastError) {
                            reject(new Error(chrome.runtime.lastError.message));
                        } else {
                            resolve();
                        }
                    });
                } else {
                    let lastError = null;
                    Object.keys(items).forEach((key) => {
                        try {
                            localStorage.setItem(key, JSON.stringify(items[key]));
                        } catch (err) {
                            console.warn('VFS localStorage write failed for key', key, err);
                            lastError = lastError || err;
                        }
                    });
                    if (lastError) {
                        reject(lastError);
                    } else {
                        resolve();
                    }
                }
            });
        }

        _storageRemove(keys) {
            const targets = (keys || []).filter(Boolean);
            if (!targets.length) {
                return Promise.resolve();
            }
            return new Promise((resolve, reject) => {
                if (typeof chrome !== 'undefined' && chrome.storage && chrome.storage.local) {
                    chrome.storage.local.remove(targets, () => {
                        if (chrome.runtime.lastError) {
                            reject(new Error(chrome.runtime.lastError.message));
                        } else {
                            resolve();
                        }
                    });
                } else {
                    let lastError = null;
                    targets.forEach((key) => {
                        try {
                            localStorage.removeItem(key);
                        } catch (err) {
                            console.warn('VFS localStorage remove failed for key', key, err);
                            lastError = lastError || err;
                        }
                    });
                    if (lastError) {
                        reject(lastError);
                    } else {
                        resolve();
                    }
                }
            });
        }

        async _removeChunks(chunkIds) {
            if (!chunkIds || chunkIds.length === 0) return;
            const removals = chunkIds.map((id) => CHUNK_PREFIX + id);
            await this._storageRemove(removals);
        }

        _normalizePath(path) {
            if (!path) return '/';

            // Check for Windows absolute paths (e.g., C:\, D:\, C:/)
            // Virtual filesystem only supports virtual paths like /VirtualMacros/
            if (/^[a-z]:[/\\]/i.test(path)) {
                throw new Error('Virtual filesystem does not support absolute file system paths. Use virtual paths like /VirtualMacros/ or enable native file access for real paths.');
            }

            if (__is_windows()) {
                path = path.replace(/\\/g, '/');
            }
            path = path.replace(/\/+/g, '/');
            if (!path.startsWith('/')) {
                path = '/' + path;
            }
            if (path.length > 1 && path.endsWith('/')) {
                path = path.slice(0, -1);
            }
            return path;
        }

        _ensureDirPath(path) {
            if (!path.endsWith('/')) {
                return path + '/';
            }
            return path;
        }

        _getEntry(path) {
            return this.tree[this._normalizePath(path)] || null;
        }

        _setEntry(path, entry) {
            const normalized = this._normalizePath(path);
            this.tree[normalized] = entry;
            this.stats.lastAccess[normalized] = now();
            this.stats.lastChange = now();
        }

        _deleteEntry(path) {
            const normalized = this._normalizePath(path);
            delete this.tree[normalized];
            delete this.stats.lastAccess[normalized];
            this.stats.lastChange = now();
        }

        _getChildrenPaths(path) {
            const prefix = this._ensureDirPath(this._normalizePath(path));
            return Object.keys(this.tree).filter((p) => p !== path && p.startsWith(prefix));
        }

        _calculateSize(content) {
            if (!content) return 0;
            return new Blob([content]).size;
        }

        async _checkQuota(delta) {
            if (delta <= 0) return;
            if (this.stats.totalSize + delta <= this.maxStorageSize) return;
            await this._cleanupOldFiles(delta);
            if (this.stats.totalSize + delta > this.maxStorageSize) {
                throw new Error('Storage quota exceeded. Please delete some files.');
            }
        }

        async _cleanupOldFiles(requiredBytes = 0) {
            const entries = Object.entries(this.stats.lastAccess)
                .filter(([path]) => this.tree[path] && this.tree[path].type === 'file')
                .sort((a, b) => a[1] - b[1]);
            let cleaned = 0;
            const target = Math.max(requiredBytes, this.maxStorageSize * 0.2);
            for (const [path] of entries) {
                const entry = this.tree[path];
                if (!entry) continue;
                await this.node_remove(path);
                cleaned += entry.size || 0;
                if (this.stats.totalSize + requiredBytes <= this.maxStorageSize || cleaned >= target) {
                    break;
                }
            }
            if (this.stats.totalSize + requiredBytes > this.maxStorageSize) {
                console.warn('VFS: Unable to free sufficient storage', {
                    requiredBytes,
                    cleaned
                });
            }
        }

        async _writeChunks(content, existingEntry) {
            const chunkIds = [];
            const payload = {};
            for (let offset = 0; offset < content.length; offset += this.chunkSize) {
                const chunkId = this._generateChunkId();
                chunkIds.push(chunkId);
                payload[CHUNK_PREFIX + chunkId] = content.slice(offset, offset + this.chunkSize);
            }
            if (Object.keys(payload).length) {
                await this._storageSet(payload);
            }
            if (existingEntry && existingEntry.chunks) {
                await this._removeChunks(existingEntry.chunks);
            }
            return chunkIds;
        }

        async _readChunks(entry, path = '') {
            if (!entry || !entry.chunks || entry.chunks.length === 0) {
                return entry && entry.content ? entry.content : '';
            }
            const keys = entry.chunks.map((id) => CHUNK_PREFIX + id);
            const result = await this._storageGet(keys);
            return entry.chunks.map((id) => {
                const key = CHUNK_PREFIX + id;
                if (result[key] == null) {
                    throw new Error('Missing file chunk data for ' + (path || 'entry'));
                }
                return result[key] || '';
            }).join('');
        }

        _generateChunkId() {
            const hasCrypto = typeof crypto !== 'undefined' && typeof crypto.getRandomValues === 'function';
            if (hasCrypto) {
                const buffer = new Uint32Array(2);
                crypto.getRandomValues(buffer);
                return buffer[0].toString(36) + buffer[1].toString(36) + Date.now().toString(36);
            }
            const a = Math.floor(Math.random() * 0xFFFFFFFF);
            const b = Math.floor(Math.random() * 0xFFFFFFFF);
            return a.toString(36) + b.toString(36) + Date.now().toString(36);
        }

        _emit(event, payload) {
            const listeners = this.listeners.get(event);
            if (!listeners) return;
            listeners.forEach((cb) => {
                try {
                    cb(payload);
                } catch (err) {
                    console.error('VFS listener error', err);
                }
            });
        }

        on(event, handler) {
            if (!this.listeners.has(event)) {
                this.listeners.set(event, new Set());
            }
            const set = this.listeners.get(event);
            set.add(handler);
            return () => set.delete(handler);
        }

        watchPath(path, handler) {
            const normalized = this._normalizePath(path);
            return this.on('change', (event) => {
                if (event && event.path && this._normalizePath(event.path).startsWith(normalized)) {
                    handler(event);
                }
            });
        }

        async node_exists(path) {
            await this.init();
            return !!this._getEntry(path);
        }

        async node_isDir(path) {
            await this.init();
            const entry = this._getEntry(path);
            return !!entry && entry.type === 'dir';
        }

        async node_isWritable() {
            await this.init();
            return true;
        }

        async node_isReadable(path) {
            return this.node_exists(path);
        }

        async node_copyTo(srcPath, dstPath) {
            await this.init();
            const entry = this._getEntry(srcPath);
            if (!entry) throw new Error('Source does not exist: ' + srcPath);
            if (entry.type === 'dir') {
                await this.makeDirectory(dstPath);
                const children = this._getChildrenPaths(srcPath);
                for (const childPath of children) {
                    const relative = childPath.replace(this._ensureDirPath(this._normalizePath(srcPath)), '');
                    const target = this._ensureDirPath(this._normalizePath(dstPath)) + relative;
                    const childEntry = this._getEntry(childPath);
                    if (childEntry.type === 'dir') {
                        await this.makeDirectory(target);
                    } else {
                        const data = await this.readTextFile(childPath);
                        await this.writeTextFile(target, data);
                    }
                }
            } else {
                const data = await this.readTextFile(srcPath);
                await this.writeTextFile(dstPath, data);
            }
        }

        async node_moveTo(srcPath, dstPath) {
            await this.node_copyTo(srcPath, dstPath);
            await this.node_remove(srcPath);
        }

        async node_remove(path) {
            await this.init();
            const normalized = this._normalizePath(path);
            const entry = this._getEntry(normalized);
            if (!entry) throw new Error('Path does not exist: ' + normalized);
            if (entry.type === 'dir') {
                const children = this._getChildrenPaths(normalized)
                    .sort((a, b) => {
                        const depthA = a.split('/').length;
                        const depthB = b.split('/').length;
                        if (depthA === depthB) {
                            return b.length - a.length;
                        }
                        return depthB - depthA;
                    });
                for (const child of children) {
                    await this.node_remove(child);
                }
            } else {
                if (entry.size) {
                    this.stats.totalSize = Math.max(0, this.stats.totalSize - entry.size);
                }
                await this._removeChunks(entry.chunks);
            }
            this.recentlyDeleted.push({ path: normalized, removedAt: now() });
            this._deleteEntry(normalized);
            await this._persist();
            this._emit('change', { type: 'delete', path: normalized, timestamp: now() });
        }

        async readTextFile(path) {
            await this.init();
            const entry = this._getEntry(path);
            if (!entry) throw new Error('File does not exist: ' + path);
            if (entry.type === 'dir') throw new Error('Path is a directory: ' + path);
            this.stats.lastAccess[this._normalizePath(path)] = now();
            return this._readChunks(entry, this._normalizePath(path));
        }

        async writeTextFile(path, data) {
            await this.init();
            const normalized = this._normalizePath(path);
            const entry = this._getEntry(normalized);
            const size = this._calculateSize(data);
            if (size > this.maxFileSize) {
                throw new Error('File size exceeds limit: ' + size + ' bytes');
            }
            const parent = normalized === '/' ? '/' : normalized.substring(0, normalized.lastIndexOf('/')) || '/';
            if (parent && parent !== normalized) {
                const parentEntry = this._getEntry(parent);
                if (!parentEntry || parentEntry.type !== 'dir') {
                    await this.makeDirectory(parent);
                }
            }
            const delta = size - (entry && entry.size ? entry.size : 0);
            await this._checkQuota(delta);
            const chunks = await this._writeChunks(data || '', entry);
            this._setEntry(normalized, {
                type: 'file',
                size,
                chunks,
                modified: now()
            });
            this.stats.totalSize += delta;
            await this._persist();
            this._emit('change', { type: 'write', path: normalized, size, timestamp: now() });
        }

        async appendTextFile(path, data) {
            await this.init();
            const existing = await this.node_exists(path) ? await this.readTextFile(path) : '';
            await this.writeTextFile(path, existing + (data || ''));
        }

        async getNodesInDir(path, filter) {
            await this.init();
            const normalized = this._normalizePath(path);
            const entry = this._getEntry(normalized);
            if (!entry || entry.type !== 'dir') {
                throw new Error('Not a directory: ' + path);
            }
            const prefix = this._ensureDirPath(normalized);
            const nodes = [];
            Object.entries(this.tree).forEach(([nodePath, nodeEntry]) => {
                if (!nodePath.startsWith(prefix) || nodePath === normalized) return;
                const remainder = nodePath.substring(prefix.length);
                if (remainder.includes('/')) return;
                nodes.push({
                    _path: nodePath,
                    _is_dir_int: nodeEntry.type === 'dir' ? 1 : 0,
                    path: nodePath,
                    is_dir: nodeEntry.type === 'dir'
                });
            });
            if (typeof filter === 'string' && filter.length) {
                // 特殊フィルタ ":is_dir" はディレクトリのみを返す
                if (filter === ':is_dir') {
                    return nodes.filter((n) => n._is_dir_int === 1);
                }
                const regex = globToRegex(filter);
                return nodes.filter((n) => regex.test(n._path));
            }
            return nodes;
        }

        async getLogicalDrives() {
            await this.init();
            // Virtual filesystem only supports virtual root, not real OS drives
            // Real drive access requires native host or File System Access API
            return [{ _path: '/', _is_dir_int: 1 }];
        }

        async getDefaultDir(name) {
            await this.init();
            const key = 'def' + name;
            const path = this.config[key];
            if (!path) throw new Error('Default directory not configured: ' + name);
            const normalized = this._normalizePath(path);
            if (!(await this.node_exists(normalized))) {
                await this.makeDirectory(normalized);
            }
            return { _path: normalized, _is_dir_int: 1 };
        }

        async makeDirectory(path) {
            await this.init();
            const normalized = this._normalizePath(path);
            const existing = this._getEntry(normalized);
            if (existing) {
                if (existing.type === 'dir') {
                    return;
                }
                throw new Error('Path exists as file: ' + path);
            }
            const parent = normalized === '/' ? '/' : normalized.substring(0, normalized.lastIndexOf('/')) || '/';
            if (parent !== normalized && !(await this.node_isDir(parent))) {
                await this.makeDirectory(parent);
            }
            this._setEntry(normalized, { type: 'dir', modified: now(), children: {} });
            await this._persist();
            this._emit('change', { type: 'mkdir', path: normalized, timestamp: now() });
        }

        async writeImageToFile(path, imageData) {
            if (!imageData || !imageData.image || !imageData.encoding || !imageData.mimeType) {
                throw new Error('Invalid image data');
            }
            await this.writeTextFile(path, JSON.stringify(imageData));
        }

        async queryLimits() {
            await this.init();
            return {
                maxFileSize: this.maxFileSize,
                maxStorageSize: this.maxStorageSize,
                currentSize: this.stats.totalSize,
                availableSize: Math.max(0, this.maxStorageSize - this.stats.totalSize)
            };
        }

        async exportTree() {
            await this.init();
            const files = {};
            const fileEntries = Object.entries(this.tree).filter(([, entry]) => entry.type === 'file');
            for (const [path] of fileEntries) {
                files[path] = await this.readTextFile(path);
            }
            return {
                exportedAt: new Date().toISOString(),
                config: this.config,
                stats: this.stats,
                files
            };
        }

        async importTree(bundle) {
            if (!bundle || typeof bundle !== 'object' || !bundle.files) {
                throw new Error('Invalid import bundle');
            }
            await this._initDefaultStructure();
            for (const [path, content] of Object.entries(bundle.files)) {
                await this.writeTextFile(path, content);
            }
            this.config = Object.assign({}, this.config, bundle.config || {});
            await this._persist();
            this._emit('change', { type: 'import', timestamp: now() });
        }

        _purgeDeleted() {
            const cutoff = now() - RECENTLY_DELETED_TTL;
            this.recentlyDeleted = this.recentlyDeleted.filter((entry) => entry.removedAt >= cutoff);
        }

        async queryLimits() {
            return {
                maxFileSize: this.maxFileSize,
                maxStorageSize: this.maxStorageSize,
                currentUsage: this.stats.totalSize
            };
        }
    }

    global.VirtualFileService = VirtualFileService;
})(this);



======================================================================
FILE PATH: WindowsPathMappingService.js
======================================================================
/**
 * WindowsPathMappingService.js
 *
 * Windowsの実際のパス（C:\Users\...など）をFile System Access APIで
 * 選択したディレクトリにマッピングして管理するサービス
 *
 * 機能:
 * - Windowsの実パスを検出
 * - パスに対応するディレクトリハンドルを管理
 * - 複数のパスマッピングをIndexedDBに永続化
 * - ユーザーにディレクトリ選択を促す
 */

// IndexedDB設定
const PATH_MAPPING_IDB_NAME = 'iMacrosPathMapping';
const PATH_MAPPING_IDB_VERSION = 1;
const PATH_MAPPING_STORE_NAME = 'pathMappings';

/**
 * file:// URI形式のパスをWindowsパスに変換
 * 例: file:///C:/Users/... -> C:/Users/...
 */
function stripFileUriPrefix(path) {
    if (!path) return '';

    // file:/// または file:// プレフィックスを削除
    if (path.startsWith('file:///')) {
        path = path.substring(8); // 'file:///' を削除
    } else if (path.startsWith('file://')) {
        path = path.substring(7); // 'file://' を削除
    }

    return path;
}

/**
 * Windowsパスを正規化（大文字小文字を統一、スラッシュを統一）
 */
function normalizeWindowsPath(path) {
    if (!path) return '';

    // file:// URI形式の場合は変換
    path = stripFileUriPrefix(path);

    // バックスラッシュをスラッシュに変換
    let normalized = path.replace(/\\/g, '/');

    // 末尾のスラッシュを削除
    if (normalized.length > 1 && normalized.endsWith('/')) {
        normalized = normalized.slice(0, -1);
    }

    // Windowsパスは大文字小文字を区別しないため、小文字に統一
    normalized = normalized.toLowerCase();

    return normalized;
}

/**
 * パスがWindowsの絶対パスかどうかを判定
 * 例: C:\Users\..., D:\Documents\..., file:///C:/Users/...
 */
function isWindowsAbsolutePath(path) {
    if (!path) return false;

    // file:// URI形式の場合は変換
    path = stripFileUriPrefix(path);

    // C:\ や C:/ の形式
    return /^[a-z]:[/\\]/i.test(path);
}

/**
 * 2つのパスのうち、一方が他方の親パスかどうかを判定
 */
function isParentPath(parentPath, childPath) {
    const normalizedParent = normalizeWindowsPath(parentPath);
    const normalizedChild = normalizeWindowsPath(childPath);

    if (normalizedParent === normalizedChild) {
        return true;
    }

    return normalizedChild.startsWith(normalizedParent + '/');
}

/**
 * パスから相対パスを計算
 */
function getRelativePath(basePath, fullPath) {
    const normalizedBase = normalizeWindowsPath(basePath);
    const normalizedFull = normalizeWindowsPath(fullPath);

    if (normalizedBase === normalizedFull) {
        return '';
    }

    if (!normalizedFull.startsWith(normalizedBase + '/')) {
        return null; // 関係ないパス
    }

    return normalizedFull.substring(normalizedBase.length + 1);
}

class WindowsPathMappingService {
    constructor(options = {}) {
        this.db = null;
        this.mappings = new Map(); // normalizedPath -> { originalPath, handle, timestamp }
        this.options = {
            autoPrompt: options.autoPrompt !== false,
            ...options
        };
    }

    /**
     * ブラウザがFile System Access APIをサポートしているかチェック
     */
    static isSupported() {
        return typeof window !== 'undefined' &&
            'showDirectoryPicker' in window;
    }

    /**
     * IndexedDBを初期化
     */
    async _initDB() {
        if (this.db) return this.db;

        return new Promise((resolve, reject) => {
            const request = indexedDB.open(PATH_MAPPING_IDB_NAME, PATH_MAPPING_IDB_VERSION);

            request.onerror = () => reject(request.error);
            request.onsuccess = () => {
                this.db = request.result;
                resolve(this.db);
            };

            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains(PATH_MAPPING_STORE_NAME)) {
                    // normalizedPathをキーとして使用
                    db.createObjectStore(PATH_MAPPING_STORE_NAME);
                }
            };
        });
    }

    /**
     * サービスを初期化（保存されたマッピングを読み込み）
     */
    async init() {
        if (!WindowsPathMappingService.isSupported()) {
            console.debug('File System Access API is not supported (Windows Path Mapping not needed on this platform)');
            return false;
        }

        try {
            const db = await this._initDB();

            // 保存されたすべてのマッピングを読み込み
            const mappings = await this._loadAllMappings();

            // 各マッピングのパーミッションを確認
            for (const [normalizedPath, mapping] of Object.entries(mappings)) {
                try {
                    const hasPermission = await this._verifyPermission(mapping.handle, 'readwrite');

                    if (hasPermission) {
                        this.mappings.set(normalizedPath, mapping);
                        console.info(`[WindowsPathMapping] Restored mapping: ${mapping.originalPath}`);
                    } else {
                        console.warn(`[WindowsPathMapping] Permission lost for: ${mapping.originalPath}`);
                        // パーミッションが失われている場合は削除
                        await this._removeMappingFromDB(normalizedPath);
                    }
                } catch (err) {
                    console.warn(`[WindowsPathMapping] Failed to verify mapping: ${mapping.originalPath}`, err);
                    await this._removeMappingFromDB(normalizedPath);
                }
            }

            return true;
        } catch (err) {
            console.error('Failed to initialize WindowsPathMappingService:', err);
            return false;
        }
    }

    /**
     * IndexedDBからすべてのマッピングを読み込み
     */
    async _loadAllMappings() {
        const db = await this._initDB();

        return new Promise((resolve, reject) => {
            const transaction = db.transaction([PATH_MAPPING_STORE_NAME], 'readonly');
            const store = transaction.objectStore(PATH_MAPPING_STORE_NAME);
            const request = store.openCursor();
            const mappings = {};

            request.onsuccess = (event) => {
                const cursor = event.target.result;
                if (cursor) {
                    mappings[cursor.key] = cursor.value;
                    cursor.continue();
                } else {
                    resolve(mappings);
                }
            };

            request.onerror = () => reject(request.error);
        });
    }

    /**
     * マッピングをIndexedDBに保存
     */
    async _saveMappingToDB(normalizedPath, mapping) {
        const db = await this._initDB();

        return new Promise((resolve, reject) => {
            const transaction = db.transaction([PATH_MAPPING_STORE_NAME], 'readwrite');
            const store = transaction.objectStore(PATH_MAPPING_STORE_NAME);
            const request = store.put(mapping, normalizedPath);

            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
        });
    }

    /**
     * IndexedDBからマッピングを削除
     */
    async _removeMappingFromDB(normalizedPath) {
        if (!this.db) return;

        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([PATH_MAPPING_STORE_NAME], 'readwrite');
            const store = transaction.objectStore(PATH_MAPPING_STORE_NAME);
            const request = store.delete(normalizedPath);

            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
        });
    }

    /**
     * ディレクトリハンドルの許可を確認・要求
     */
    async _verifyPermission(handle, mode = 'read') {
        const options = {};
        if (mode === 'readwrite') {
            options.mode = 'readwrite';
        }

        // 既に許可があるかチェック
        if ((await handle.queryPermission(options)) === 'granted') {
            return true;
        }

        // ユーザーに許可を要求
        if ((await handle.requestPermission(options)) === 'granted') {
            return true;
        }

        return false;
    }

    /**
     * Windowsパスに対応するマッピングを取得
     * パス自体が登録されている場合、または親パスが登録されている場合に返す
     */
    async getMapping(windowsPath) {
        if (!isWindowsAbsolutePath(windowsPath)) {
            return null;
        }

        const normalizedPath = normalizeWindowsPath(windowsPath);

        // 完全一致するマッピングを探す
        if (this.mappings.has(normalizedPath)) {
            return this.mappings.get(normalizedPath);
        }

        // 親パスのマッピングを探す（最も長い親パスを優先）
        let bestMatch = null;
        let bestMatchLength = 0;

        for (const [mappedPath, mapping] of this.mappings.entries()) {
            if (isParentPath(mappedPath, normalizedPath)) {
                if (mappedPath.length > bestMatchLength) {
                    bestMatch = mapping;
                    bestMatchLength = mappedPath.length;
                }
            }
        }

        return bestMatch;
    }

    /**
     * Windowsパスからディレクトリハンドルと相対パスを取得
     */
    async resolveWindowsPath(windowsPath) {
        if (!isWindowsAbsolutePath(windowsPath)) {
            throw new Error(`Not a Windows absolute path: ${windowsPath}`);
        }

        const mapping = await this.getMapping(windowsPath);

        if (!mapping) {
            // マッピングが見つからない場合、ユーザーにディレクトリ選択を促す
            if (this.options.autoPrompt) {
                const newMapping = await this.promptForPath(windowsPath);
                if (newMapping) {
                    return this.resolveWindowsPath(windowsPath);
                }
            }

            throw new Error(
                `No File System Access mapping found for path: ${windowsPath}\n` +
                `Please select the directory using promptForPath() or enable Native File Access.`
            );
        }

        // 相対パスを計算
        const normalizedRequestedPath = normalizeWindowsPath(windowsPath);
        const normalizedMappedPath = normalizeWindowsPath(mapping.originalPath);
        const relativePath = getRelativePath(normalizedMappedPath, normalizedRequestedPath);

        return {
            handle: mapping.handle,
            relativePath: relativePath || '',
            mappedPath: mapping.originalPath
        };
    }

    /**
     * ユーザーにディレクトリ選択ダイアログを表示して、Windowsパスをマッピング
     */
    async promptForPath(windowsPath) {
        if (!isWindowsAbsolutePath(windowsPath)) {
            throw new Error(`Not a Windows absolute path: ${windowsPath}`);
        }

        try {
            // file:// URI形式の場合は変換してから処理
            const cleanPath = stripFileUriPrefix(windowsPath);

            // ユーザーにメッセージを表示
            console.info(`[WindowsPathMapping] Please select directory for: ${cleanPath}`);

            // ディレクトリ選択ダイアログを表示
            const handle = await window.showDirectoryPicker({
                mode: 'readwrite',
                startIn: 'documents'
            });

            // マッピングを保存（正規化されたWindowsパスを使用）
            const normalizedPath = normalizeWindowsPath(cleanPath);
            const mapping = {
                originalPath: cleanPath,
                normalizedPath: normalizedPath,
                handle: handle,
                timestamp: Date.now()
            };

            this.mappings.set(normalizedPath, mapping);
            await this._saveMappingToDB(normalizedPath, mapping);

            console.info(`[WindowsPathMapping] Mapping created: ${cleanPath}`);

            return mapping;
        } catch (err) {
            if (err.name === 'AbortError') {
                console.log('User cancelled directory selection');
            } else {
                console.error('Failed to select directory:', err);
            }
            return null;
        }
    }

    /**
     * マッピングを削除
     */
    async removeMapping(windowsPath) {
        const normalizedPath = normalizeWindowsPath(windowsPath);

        this.mappings.delete(normalizedPath);
        await this._removeMappingFromDB(normalizedPath);

        console.info(`[WindowsPathMapping] Mapping removed: ${windowsPath}`);
    }

    /**
     * すべてのマッピングを削除
     */
    async clearAllMappings() {
        this.mappings.clear();

        if (!this.db) return;

        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([PATH_MAPPING_STORE_NAME], 'readwrite');
            const store = transaction.objectStore(PATH_MAPPING_STORE_NAME);
            const request = store.clear();

            request.onsuccess = () => {
                console.info('[WindowsPathMapping] All mappings cleared');
                resolve();
            };
            request.onerror = () => reject(request.error);
        });
    }

    /**
     * 現在のすべてのマッピングを取得
     */
    getAllMappings() {
        const result = [];
        for (const [normalizedPath, mapping] of this.mappings.entries()) {
            result.push({
                originalPath: mapping.originalPath,
                normalizedPath: normalizedPath,
                timestamp: mapping.timestamp
            });
        }
        return result;
    }
}

// グローバルインスタンスを作成（シングルトン）
if (typeof window !== 'undefined') {
    window.WindowsPathMappingService = WindowsPathMappingService;
}

if (typeof module !== 'undefined' && module.exports) {
    module.exports = WindowsPathMappingService;
}


